<!DOCTYPE html><html><head><title>Coccinelle Semantic Patch Repository</title></head><body><center><h2>Coccinelle Semantic Patch Repository</h2></center><p>About Coccinelle: <a href=http://coccinelle.lip6.fr/>http://coccinelle.lip6.fr/</a><br>Mailing list: <a href=mailto:cocci@systeme.lip6.fr>cocci@systeme.lip6.fr</a> - <a href=https://systeme.lip6.fr/mailman/listinfo/cocci>https://systeme.lip6.fr/mailman/listinfo/cocci</a><p>
<A HREF=README.html>Short index</A><P>
<A HREF=9p/category2a_p9_client_walk.cocci>9p/category2a_p9_client_walk.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function p9_client_walk returns an ERR pointer,
	but never returns a NULL pointer. So a NULL test that comes after an
	IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = p9_client_walk(...)
	... when != x = E
	*  if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=9p/p9_client_walk.cocci>9p/p9_client_walk.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function p9_client_walk returns an ERR pointer,
	but never returns a NULL pointer. So a NULL test that comes after an
	IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = p9_client_walk(...)
	... when != x = E
	*  if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=aaci/category2a_aaci_init_card.cocci>aaci/category2a_aaci_init_card.cocci</A>  -  Bad NULL test
<pre>
	----------------------------
	
	
	In case of error, the function aaci_init_card returns an ERR pointer,
	but never returns a NULL pointer. We have noticed a bad NULL test,
	which comes after a call to this function. Rather than doing an IS_ERR
	test, we suggest to duplicate the label out: one label for the case
	where aaci_init_card returns a valid pointer, and another for the case
	where aaci_init_card returns an ERR pointer.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x =  aaci_init_card(...)
	... when != x = E
	*  if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=acl/patch.cocci>acl/patch.cocci</A>  -  Add missing call to posix_acl_release
<pre>
	fs/jffs2/acl.c
	
	Send to:
	dwmw2@infradead.org, linux-mtd@lists.infradead.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] fs/jffs2: Add missing call to posix_acl_release
	
	------------------------------------------------------
	
	
	posix_acl_clone does a memory allocation and sets a reference count, so
	posix_acl_release is needed afterwards to free it.
	
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	identifier E;
	expression E1, E2;
	int ret;
	statement S;
	@@
	
	  T E;
	  <+...
	(
	  E = \(posix_acl_clone\|posix_acl_alloc\|posix_acl_dup\)(...);
	  if (E == NULL) S
	|
	  if ((E = \(posix_acl_clone\|posix_acl_alloc\|posix_acl_dup\)(...)) == NULL) S
	)
	  ... when != E2 = E
	      when strict
	(
	  posix_acl_release(E);
	|
	  E1 = E;
	|
	+ posix_acl_release(E);
	  return;
	|
	+ posix_acl_release(E);
	  return ret;
	)
	  ...+>
	// </smpl>
	
</pre>
<A HREF=acpi/category2b_back_device_reg.cocci>acpi/category2b_back_device_reg.cocci</A>  -  dereference without an error test
<pre>
	----------------------------
	
	
	After a variable is assigned the result of backlight_device_register, an error
	test should be performed before a dereference. 
	
	A simplified version of the semantic match that finds this problem is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	// <smpl>
	@def0@
	expression x;
	position p0;
	@@
	
	x@p0 = backlight_device_register(...)
	
	@protected@
	expression def0.x,E;
	position def0.p0;
	position p;
	statement S;
	@@
	x@p0
	... when != x = E
	if (!IS_ERR(x) && ...) {<... x@p ...>} else S
	
	@unprotected@
	expression def0.x,E;
	identifier fld;
	position def0.p0;
	position p != protected.p;
	@@
	x@p0
	... when != x = E
	* x@p->fld
	// </smpl>
	
</pre>
<A HREF=acpid/acpi.cocci>acpid/acpi.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=after_netif/after_netif.cocci>after_netif/after_netif.cocci</A>  -  Fix use of skb after netif_rx
<pre>
	fpavlic@de.ibm.com, wangchen@cn.fujitsu.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 3/3] Fix use of skb after netif_rx
	
	------------------------------------------------------
	
	
	Recently, Wang Chen submitted a patch
	(d30f53aeb31d453a5230f526bea592af07944564) to move a call to netif_rx(skb)
	after a subsequent reference to skb, because netif_rx may call kfree_skb on
	its argument.  netif_rx_ni calls netif_rx, so the same problem occurs in
	the files below.
	
	I have left the updating of dev->last_rx after the calls to netif_rx_ni
	because it seems time dependent, but moved the other field updates before.
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression skb, e,e1;
	@@
	
	(
	 netif_rx(skb);
	|
	 netif_rx_ni(skb);
	)
	  ... when != skb = e
	(
	  skb = e1
	|
	* skb
	)
	// </smpl>
	
</pre>
<A HREF=after_netif/after_netif_modif.cocci>after_netif/after_netif_modif.cocci</A>  -  Fix use of skb after netif_rx
<pre>
	fpavlic@de.ibm.com, wangchen@cn.fujitsu.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 3/3] Fix use of skb after netif_rx
	
	------------------------------------------------------
	
	
	Recently, Wang Chen submitted a patch
	(d30f53aeb31d453a5230f526bea592af07944564) to move a call to netif_rx(skb)
	after a subsequent reference to skb, because netif_rx may call kfree_skb on
	its argument.  netif_rx_ni calls netif_rx, so the same problem occurs in
	the files below.
	
	I have left the updating of dev->last_rx after the calls to netif_rx_ni
	because it seems time dependent, but moved the other field updates before.
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression skb, e,e1;
	@@
	
	(
	 netif_rx(skb);
	|
	 netif_rx_ni(skb);
	)
	  ... when != skb = e
	(
	  skb = e1
	|
	* skb
	)
	// </smpl>
	
</pre>
<A HREF=alloc9/kmalloc9.cocci>alloc9/kmalloc9.cocci</A>  -  Eliminate memory leak
<pre>
	----------------------------
	
	
	__ip_vs_service_get and __ip_vs_svc_fwm_get increment a reference count, so
	that reference count should be decremented before leaving the function in an
	error case.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E;
	identifier f1;
	iterator I;
	@@
	
	x = __ip_vs_service_get(...);
	<... when != x
	     when != true (x == NULL || ...)
	     when != if (...) { <+...x...+> }
	     when != I (...) { <+...x...+> }
	(
	 x == NULL
	|
	 x == E
	|
	 x->f1
	)
	...>
	* return ...;
	// </smpl>
	
</pre>
<A HREF=alloc_cast/alloc_cast.cocci>alloc_cast/alloc_cast.cocci</A>  -  Drop memory allocation cast
<pre>
	Ursula Braun <ursula.braun@de.ibm.com>,Frank Blaschka <blaschka@linux.vnet.ibm.com>,linux390@de.ibm.com,Martin Schwidefsky <schwidefsky@de.ibm.com>,Heiko Carstens <heiko.carstens@de.ibm.com>,linux-s390@vger.kernel.org,linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 2/5] drivers/s390/net: Drop memory allocation cast
	
	
	----------------------------
	
	
	Drop cast on the result of kmalloc and similar functions.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	@@
	
	- (T *)
	  (\(kmalloc\|kzalloc\|kcalloc\|kmem_cache_alloc\|kmem_cache_zalloc\|
	   kmem_cache_alloc_node\|kmalloc_node\|kzalloc_node\)(...))
	// </smpl>
	
</pre>
<A HREF=alloc_domain/easykmret.cocci>alloc_domain/easykmret.cocci</A>  -  add missing free_domain_mem
<pre>
	Add missing free_domain_mem on failure path after alloc_domain.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@km exists@
	local idexpression e;
	expression e1,e2,e3;
	type T,T1;
	identifier f;
	@@
	
	* e = alloc_domain(...)
	... when any
	    when != e = e1
	    when != e1 = (T)e
	    when != e1(...,(T)e,...)
	    when != &e->f
	if(...) { ... when != e2(...,(T1)e,...)
	                 when != e3 = e
	                 when forall
	(
	             return <+...e...+>;
	|
	*             return ...;
	) }
	// </smpl>
	
</pre>
<A HREF=alloc_etherdev/alloc.cocci>alloc_etherdev/alloc.cocci</A>  -  adjust error handling
<pre>
	----------------------------
	
	
	The just preceding error case does a lot of error handling, so it seems
	like this one should as well.
	
	The semantic match that found the problem is:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E,E1,E2;
	@@
	
	E = alloc_etherdev(...)
	... when != E = E1
	if (...) { ... free_netdev(E); ... return ...; }
	... when != E = E2
	(
	  if (...)
	   {
	   ... when != free_netdev(E);
	   return dev; }
	|
	* if (...)
	   {
	   ... when != free_netdev(E);
	   return ...; }
	|
	register_netdev(E)
	)
	
	// </smpl>
	
</pre>
<A HREF=alloc_tty/alloc_tty.cocci>alloc_tty/alloc_tty.cocci</A>  -  add missing put_tty_driver
<pre>
	----------------------------
	
	
	alloc_tty_driver is called at the beginning of the function containing the
	lines of code shown in the patch.  Thus, put_tty_driver is needed before
	returning in the error handling code.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@nr exists@
	local idexpression x;
	expression E,f;
	position p1,p2,p3;
	identifier l;
	statement S;
	@@
	
	x = alloc_tty_driver@p1(...)
	...
	if (x == NULL) S
	... when != E = x
	    when != put_tty_driver(x)
	    when != goto l;
	(
	return \(0\|x\);
	|
	return@p3 ...;
	)
	
	@script:python@
	p1 << nr.p1;
	p3 << nr.p3;
	@@
	
	print \"%s: call on line %s not freed or saved before return on line %s\" % (p1[0].file,p1[0].line,p3[0].line)
	// </smpl>
	
</pre>
<A HREF=allocs/a2.cocci>allocs/a2.cocci</A>  -  add missing fput
<pre>
	----------------------------
	
	
	fget increments a reference count, so fput is needed to decrement it.  I
	have added a goto to the end of the function where there was already such a
	call.
	
	The semantic patch that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S;
	position p1,p2;
	identifier f;
	expression E;
	expression *ptr != NULL;
	@@
	
	 x@p1 = fget(...);
	 ... when != x
	 if (x == NULL) S
	 <... when != x
	      when != if (...) { <+...x...+> }
	  x->f = E
	 ...>
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	 return@p2 ...;
	)
	
	@ script:python @
	p1 << r.p1;
	p2 << r.p2;
	@@
	print \"%s: call: %s return: %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=arraysize/array.cocci>arraysize/array.cocci</A>  -  use ARRAY_SIZE
<pre>
	----------------------------
	
	
	ARRAY_SIZE is more concise to use when the size of an array is divided by
	the size of its type or the size of its first element.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@i@
	@@
	
	#include <linux/kernel.h>
	
	@depends on i using \"paren.iso\"@
	type T;
	T[] E;
	@@
	
	- (sizeof(E)/sizeof(E[...]))
	+ ARRAY_SIZE(E)
	
	@depends on i using \"paren.iso\"@
	type T;
	T[] E;
	@@
	
	- (sizeof(E)/sizeof(T))
	+ ARRAY_SIZE(E)
	// </smpl>
	
</pre>
<A HREF=arref/arref.cocci>arref/arref.cocci</A>  -  adjust array index
<pre>
	Convert array index from the loop bound to the loop index.
	
	A simplified version of the semantic patch that fixes this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e1,e2,ar;
	@@
	
	for(e1 = 0; e1 < e2; e1++) { <...
	  ar[
	- e2
	+ e1
	  ]
	  ...> }
	// </smpl>
	
</pre>
<A HREF=asprintf/asprintf.cocci>asprintf/asprintf.cocci</A>  -  Use kasprintf
<pre>
	----------------------------
	
	
	kasprintf combines kmalloc and sprintf, and takes care of the size
	calculation itself.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression a,flag;
	expression list args;
	statement S;
	@@
	
	  a =
	-  \(kmalloc\|kzalloc\)(...,flag)
	+  kasprintf(flag,args)
	  <... when != a
	  if (a == NULL || ...) S
	  ...>
	- sprintf(a,args);
	// </smpl>
	
</pre>
<A HREF=atm/atm.cocci>atm/atm.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=auth/auth.cocci>auth/auth.cocci</A>  -  Adjust error handling code involving auth_domain_put
<pre>
	----------------------------
	
	
	Once clp is assigned, it never becomes NULL, so we can make a label for it
	in the error handling code.  Because the call to path_lookup follows the
	call to auth_domain_find, its error handling code should jump to this new
	label.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S;
	position p1,p2,p3;
	@@
	
	(
	if ((x = auth_domain_find@p1(...)) == NULL || ...) S
	|
	x = auth_domain_find@p1(...)
	... when != x
	if (x == NULL || ...) S
	)
	<...
	if@p3 (...) { ... when != auth_domain_put(x)
	                  when != if (x) { ... auth_domain_put(x); ...}
	    return@p2 ...;
	}
	...>
	(
	return x;
	|
	return 0;
	|
	x = E
	|
	E = x
	|
	auth_domain_put(x)
	)
	
	@exists@
	position r.p1,r.p2,r.p3;
	expression x;
	int ret != 0;
	statement S;
	@@
	
	* x = auth_domain_find@p1(...)
	  <...
	* if@p3 (...)
	  S
	  ...>
	* return@p2 \(NULL\|ret\);
	// </smpl>
	
</pre>
<A HREF=badand/badand.cocci>badand/badand.cocci</A>  -  Convert && to ||
<pre>
	----------------------------
	
	
	The pattern !E && !E->fld is nonsensical.  The patch below updates this
	according to the assumption that && should be ||.  But perhaps another
	solution was intended.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@disable and_comm@
	expression E;
	identifier fld;
	@@
	
	- !E && !E->fld
	+ !E || !E->fld
	// </smpl>
	
</pre>
<A HREF=badftest/badftest.cocci>badftest/badftest.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=badkm/badkm.cocci>badkm/badkm.cocci</A>  -  initialize return variable with error code
<pre>
	Typically, the return value desired for the failure of a memory allocation
	is -ENOMEM.  In this case, the return value is undesirably 0.
	
	The semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@@
	identifier ret,f;
	expression E,E1,x;
	@@
	
	(
	ret = f(...);
	if (ret != 0) { ... when forall
	  return ...; }
	|
	ret = 0
	)
	... when != ret = E
	    when any
	x = \(kmalloc\|kzalloc\|kcalloc\)(...);
	*if(x == NULL) {
	 ... when != ret = E1
	* return ret;
	}
	//</smpl>
	
</pre>
<A HREF=badkm2/badkm2.cocci>badkm2/badkm2.cocci</A>  -  ensure a consistent return value in error case
<pre>
	Typically, the return value desired for the failure of a function with an
	integer return value is a negative integer.  In these cases, the return
	value is sometimes a negative integer and sometimes 0, due to a subsequent
	initialization of the return variable within the loop.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@r exists@
	identifier ret;
	position p;
	constant C;
	expression e1,e3,e4;
	statement S;
	@@
	
	ret = -C
	... when != ret = e3
	    when any
	if@p (...) S
	... when any
	if (\(ret != 0\|ret < 0\|ret > 0\) || ...) { ... return ...; }
	... when != ret = e3
	    when any
	*if@p (...)
	{
	  ... when != ret = e4
	  return ret;
	}
	//</smpl>
	
</pre>
<A HREF=badktest/badktest.cocci>badktest/badktest.cocci</A>  -  Correct NULL test
<pre>
	----------------------------
	
	
	Test the just-allocated value for NULL rather than some other value.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,y;
	statement S;
	@@
	
	x = \(kmalloc\|kcalloc\|kzalloc\)(...);
	(
	if ((x) == NULL) S
	|
	if (
	-   y
	+   x
	       == NULL)
	 S
	)
	// </smpl>
	
</pre>
<A HREF=badmsg/badmsg.cocci>badmsg/badmsg.cocci</A>  -  Return -ENOMEM on memory allocation failure
<pre>
	----------------------------
	
	
	In this code, 0 is returned on memory allocation failure, even though other
	failures return -ENOMEM or other similar values.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression ret;
	expression x,e1,e2,e3;
	@@
	
	ret = 0
	... when != ret = e1
	*x = \(kmalloc\|kcalloc\|kzalloc\)(...)
	... when != ret = e2
	if (x == NULL) { ... when != ret = e3
	  return ret;
	}
	// </smpl>
	
</pre>
<A HREF=badmsg3/badmsg3.cocci>badmsg3/badmsg3.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=badty/badty.cocci>badty/badty.cocci</A>  -  Correct the size argument to kzalloc
<pre>
	----------------------------
	
	
	obj has type struct snmp_object **, not struct snmp_object *.  But indeed
	it is not even clear why kmalloc is needed.  The memory is freed by the end
	of the function, so the local variable of pointer type should be sufficient.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@disable sizeof_type_expr@
	type T;
	T **x;
	@@
	
	  x =
	  <+...sizeof(
	- T
	+ *x
	  )...+>
	// </smpl>
	
</pre>
<A HREF=bitcall/bitcall.cocci>bitcall/bitcall.cocci</A>  -  convert & to &&
<pre>
	----------------------------
	
	
	The use of & to obtain a conjunction that evaluates both of its arguments
	seems unnecessarily tricky.
	
	The semantic match that found this code is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@ expression E1, E2; @@
	*  !E1 & !E2
	// </smpl>
	
</pre>
<A HREF=bits/notand.cocci>bits/notand.cocci</A>  -  Correct use of ! and &
<pre>
	----------------------------
	
	
	In commit e6bafba5b4765a5a252f1b8d31cbf6d2459da337, a bug was fixed that
	involved converting !x & y to !(x & y).  The code below shows the same
	pattern, and thus should perhaps be fixed in the same way.
	
	This is not tested and clearly changes the semantics, so it is only
	something to consider.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@ expression E1,E2; @@
	(
	  !E1 & !E2
	|
	- !E1 & E2
	+ !(E1 & E2)
	)
	// </smpl>
	
</pre>
<A HREF=bits2/notand.cocci>bits2/notand.cocci</A>  -  Correct use of ! and &
<pre>
	----------------------------
	
	
	Correct priority problem in the use of ! and &.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@ expression E; constant C; @@
	- !E & C
	+ !(E & C)
	// </smpl>
	
</pre>
<A HREF=block_nil/retsall.cocci>block_nil/retsall.cocci</A>  -  use BLOCK_NIL
<pre>
	----------------------------
	
	
	Use BLOCK_NIL consistently rather than sometimes 0xffff and sometimes
	BLOCK_NIL.
	
	The semantic patch that finds this issue is below
	(http://www.emn.fr/x-info/coccinelle/).  On the other hand, the changes
	were made by hand, in part because drivers/mtd/inftlcore.c contains dead
	code that causes spatch to ignore a relevant function.  Specifically, the
	function INFTL_findwriteunit contains a do-while loop, but always takes a
	return that leaves the loop on the first iteration.
	
	// <smpl>
	@r exists@
	identifier f,C;
	@@
	
	f(...) { ... return C; }
	
	@s@
	identifier r.C;
	expression E;
	@@
	
	#define C E
	
	@@
	identifier r.f,r.C,I;
	expression s.E;
	@@
	
	f(...) {
	 <...
	(
	  I
	|
	- E
	+ C
	)
	 ...>
	}
	
	// </smpl>
	
</pre>
<A HREF=bo/bo.cocci>bo/bo.cocci</A>  -  trivial: use BUG_ON
<pre>
	Use BUG_ON(x) rather than if(x) BUG();
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@ identifier x; @@
	-if (x) BUG();
	+BUG_ON(x);
	
	@@ identifier x; @@
	-if (!x) BUG();
	+BUG_ON(!x);
	// </smpl>
	
</pre>
<A HREF=bond/short_timeout.cocci>bond/short_timeout.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=bootmem/bootmem.cocci>bootmem/bootmem.cocci</A>  -  Eliminate NULL test and memset after alloc_bootmem
<pre>
	akinobu.mita@gmail.com, kyle@mcmartin.ca, matthew@wil.cx, grundler@parisc-linux.org, linux-parisc@vger.kernel.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH 6/14] arch/parisc: Eliminate NULL test and memset after alloc_bootmem
	
	------------------------------------------------------
	
	
	As noted by Akinobu Mita in patch b1fceac2b9e04d278316b2faddf276015fc06e3b,
	alloc_bootmem and related functions never return NULL and always return a
	zeroed region of memory.  Thus a NULL test or memset after calls to these
	functions is unnecessary.
	
	 arch/parisc/mm/init.c |    1 -
	 1 file changed, 1 deletion(-)
	
	This was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	statement S;
	@@
	
	E = \(alloc_bootmem\|alloc_bootmem_low\|alloc_bootmem_pages\|alloc_bootmem_low_pages\)(...)
	... when != E
	(
	- BUG_ON (E == NULL);
	|
	- if (E == NULL) S
	)
	
	@@
	expression E,E1;
	@@
	
	E = \(alloc_bootmem\|alloc_bootmem_low\|alloc_bootmem_pages\|alloc_bootmem_low_pages\)(...)
	... when != E
	- memset(E,0,E1);
	// </smpl>
	
</pre>
<A HREF=bootmem2/bootmem.cocci>bootmem2/bootmem.cocci</A>  -  Eliminate NULL test and memset after alloc_bootmem
<pre>
	hskinnemoen@atmel.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH 2/5] arch/avr32: Eliminate NULL test and memset after alloc_bootmem
	
	------------------------------------------------------
	
	
	As noted by Akinobu Mita in patch b1fceac2b9e04d278316b2faddf276015fc06e3b,
	alloc_bootmem and related functions never return NULL and always return a
	zeroed region of memory.  Thus a NULL test or memset after calls to these
	functions is unnecessary.
	
	This was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	statement S;
	@@
	
	E = \(alloc_bootmem\|alloc_bootmem_low\|alloc_bootmem_pages\|alloc_bootmem_low_pages\|alloc_bootmem_node\|alloc_bootmem_low_pages_node\|alloc_bootmem_pages_node\)(...)
	... when != E
	(
	- BUG_ON (E == NULL);
	|
	- if (E == NULL) S
	)
	
	@@
	expression E,E1;
	@@
	
	E = \(alloc_bootmem\|alloc_bootmem_low\|alloc_bootmem_pages\|alloc_bootmem_low_pages\|alloc_bootmem_node\|alloc_bootmem_low_pages_node\|alloc_bootmem_pages_node\)(...)
	... when != E
	- memset(E,0,E1);
	// </smpl>
	
</pre>
<A HREF=bss/sp1094.cocci>bss/sp1094.cocci</A>  -  Add missing call to cfg80211_put_bss
<pre>
	A call to cfg80211_get_bss hould be accompanied by a call to
	cfg80211_put_bss in error-handling code.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct cfg80211_bss * x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = cfg80211_get_bss@p1(...)
	...  when != x = rr
	     when != cfg80211_put_bss(x,...)
	     when != if (...) { ... cfg80211_put_bss(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != cfg80211_put_bss(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"cfg80211_get_bss\",p1)
	cocci.print_secs(\"return\",p2)
	
	// </smpl>
	
</pre>
<A HREF=btrfs/btrfs.cocci>btrfs/btrfs.cocci</A>  -  Add missing btrfs_free_path
<pre>
	Btrfs_alloc_path should be matched with btrfs_free_path in error-handling code.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct btrfs_path * x;
	expression ra,rb;
	position p1,p2;
	@@
	
	x = btrfs_alloc_path@p1(...)
	...  when != btrfs_free_path(x,...)
	     when != if (...) { ... btrfs_free_path(x,...) ...}
	     when != x = ra
	if(...) { ... when != x = rb
	     when forall
	     when != btrfs_free_path(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"alloc\",p1)
	cocci.print_secs(\"return\",p2)
	// </smpl>
	
</pre>
<A HREF=bugon/newbugon.cocci>bugon/newbugon.cocci</A>  -  Use BUG_ON
<pre>
	----------------------------
	
	
	if (...) BUG(); should be replaced with BUG_ON(...) when the test has no
	side-effects to allow a definition of BUG_ON that drops the code completely.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@ disable unlikely @ expression E,f; @@
	
	(
	  if (<... f(...) ...>) { BUG(); }
	|
	- if (unlikely(E)) { BUG(); }
	+ BUG_ON(E);
	)
	
	@@ expression E,f; @@
	
	(
	  if (<... f(...) ...>) { BUG(); }
	|
	- if (E) { BUG(); }
	+ BUG_ON(E);
	)
	// </smpl>
	
</pre>
<A HREF=cache/cache.cocci>cache/cache.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=call_kern1/call_kern1.cocci>call_kern1/call_kern1.cocci</A>  -  Use GFP_ATOMIC when a lock is held
<pre>
	----------------------------
	
	
	The function adpt_i2o_post_wait is called from several places, in some of
	which, such as adpt_abort, a lock may be held.
	
	The functions adpt_i2o_reparse_lct and adpt_i2o_lct_get are called from
	several places, including adpt_rescan where a lock may be held.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@gfp exists@
	identifier fn;
	position p;
	@@
	
	fn(...) {
	 ... when != spin_unlock_irqrestore
	     when any
	 GFP_KERNEL@p
	 ... when any
	}
	
	@locked@
	identifier gfp.fn;
	@@
	
	spin_lock_irqsave(...)
	...  when != spin_unlock_irqrestore
	fn(...)
	
	@depends on locked@
	position gfp.p;
	@@
	
	- GFP_KERNEL@p
	+ GFP_ATOMIC
	// </smpl>
	
</pre>
<A HREF=call_kern3/call_kern3.cocci>call_kern3/call_kern3.cocci</A>  -  Use GFP_ATOMIC when a lock is held
<pre>
	----------------------------
	
	
	The containing function is called from several places.  At one of them, in
	the function untag_chunk, the spin lock &entry->lock is held.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@gfp exists@
	identifier fn;
	position p;
	@@
	
	fn(...) {
	... when != spin_unlock
	    when any
	  GFP_KERNEL@p
	 ... when any
	}
	
	@locked@
	identifier gfp.fn;
	@@
	
	spin_lock(...)
	... when != spin_unlock
	fn(...)
	
	@depends on locked@
	position gfp.p;
	@@
	
	- GFP_KERNEL@p
	+ GFP_ATOMIC
	// </smpl>
	
</pre>
<A HREF=capi/capi.cocci>capi/capi.cocci</A>  -  Adjust error handling code involving capi_ctr_put
<pre>
	----------------------------
	
	
	After calling capi_ctr_get, error handling code should call
	capi_ctr_put.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S;
	position p1,p2,p3;
	@@
	
	(
	if ((x = capi_ctr_get@p1(...)) == NULL || ...) S
	|
	x = capi_ctr_get@p1(...)
	... when != x
	if (x == NULL || ...) S
	)
	<...
	if@p3 (...) { ... when != capi_ctr_put(x)
	                  when != if (x) { ... capi_ctr_put(x); ...}
	    return@p2 ...;
	}
	...>
	(
	return x;
	|
	return 0;
	|
	x = E
	|
	E = x
	|
	capi_ctr_put(x)
	)
	
	@exists@
	position r.p1,r.p2,r.p3;
	expression x;
	int ret != 0;
	statement S;
	@@
	
	* x = capi_ctr_get@p1(...)
	  <...
	* if@p3 (...)
	  S
	  ...>
	* return@p2 \(NULL\|ret\);
	// </smpl>
	
</pre>
<A HREF=clkput/clkput.cocci>clkput/clkput.cocci</A>  -  add missing clk_put
<pre>
	Reorder the labels at the end of the function to correspond to the order in
	which the resources are allocated.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression e1,e2;
	statement S;
	@@
	
	e1 = clk_get@p1(...);
	... when != e1 = e2
	    when != clk_put(e1)
	    when any
	if (...) { ... when != clk_put(e1)
	               when != if (...) { ... clk_put(e1) ... }
	* return@p3 ...;
	 } else S
	// </smpl>
	
</pre>
<A HREF=consts/consts.cocci>consts/consts.cocci</A>  -  use the constant InterlaceMode
<pre>
	----------------------------
	
	
	Use the constant InterlaceMode rather than the magic number 0x0080.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	type T;
	T E;
	identifier fld;
	identifier c;
	@@
	
	E->fld & c
	
	@s@
	constant C;
	identifier r.c;
	@@
	
	#define c C
	
	@@
	r.T E;
	identifier r.fld;
	identifier r.c;
	constant s.C;
	@@
	
	 E->fld &
	- C
	+ c
	// </smpl>
	
</pre>
<A HREF=countptr/countptr.cocci>countptr/countptr.cocci</A>  -  remove exceptional & on function name
<pre>
	----------------------------
	
	
	In this file, function names are otherwise used as pointers without &.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier f;
	@@
	
	f(...) { ... }
	
	@@
	identifier r.f;
	@@
	
	- &f
	+ f
	// </smpl>
	
</pre>
<A HREF=cpu/cpu.cocci>cpu/cpu.cocci</A>  -  Adjust error handling code involving cpufreq_cpu_put
<pre>
	----------------------------
	
	
	After calling cpufreq_cpu_get, error handling code should call
	cpufreq_cpu_put.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S;
	position p1,p2,p3;
	@@
	
	(
	if ((x = cpufreq_cpu_get@p1(...)) == NULL || ...) S
	|
	x = cpufreq_cpu_get@p1(...)
	... when != x
	if (x == NULL || ...) S
	)
	<...
	if@p3 (...) { ... when != cpufreq_cpu_put(x)
	                  when != if (x) { ... cpufreq_cpu_put(x); ...}
	    return@p2 ...;
	}
	...>
	(
	return x;
	|
	return 0;
	|
	x = E
	|
	E = x
	|
	cpufreq_cpu_put(x)
	)
	
	@exists@
	position r.p1,r.p2,r.p3;
	expression x;
	int ret != 0;
	statement S;
	@@
	
	* x = cpufreq_cpu_get@p1(...)
	  <...
	* if@p3 (...)
	  S
	  ...>
	* return@p2 \(NULL\|ret\);
	// </smpl>
	
</pre>
<A HREF=cpu_mask/cpu_mask.cocci>cpu_mask/cpu_mask.cocci</A>  -  Use set_cpus_allowed_ptr
<pre>
	----------------------------
	
	
	Use set_cpus_allowed_ptr rather than set_cpus_allowed.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E1,E2;
	@@
	
	- set_cpus_allowed(E1, cpumask_of_cpu(E2))
	+ set_cpus_allowed_ptr(E1, cpumask_of(E2))
	
	@@
	expression E;
	identifier I;
	@@
	
	- set_cpus_allowed(E, I)
	+ set_cpus_allowed_ptr(E, &I)
	// </smpl>
	
</pre>
<A HREF=cpufreq/patch.cocci>cpufreq/patch.cocci</A>  -  Add calls to cpufreq_cpu_put
<pre>
	drivers/cpufreq/cpufreq.c
	
	
	Send to:
	davej@codemonkey.org.uk, cpufreq@lists.linux.org.uk, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/cpufreq: Add calls to cpufreq_cpu_put
	
	------------------------------------------------------
	
	
	A call to cpufreq_cpu_get should be matched by a call to cpufreq_cpu_put.
	
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	identifier E;
	expression E1, E2;
	int ret;
	statement S;
	@@
	
	  T E;
	  ... when any
	(
	  E = cpufreq_cpu_get(...);
	  if (E == NULL) S
	|
	  if ((E = cpufreq_cpu_get(...)) == NULL) S
	)
	  ... when != E2 = E
	      when strict
	(
	  cpufreq_cpu_put(E);
	|
	  E1 = E;
	|
	+ cpufreq_cpu_put(E);
	  return;
	|
	+ cpufreq_cpu_put(E);
	  return ret;
	)
	// </smpl>
	
</pre>
<A HREF=cris/mutex2.cocci>cris/mutex2.cocci</A>  -  Use mutex_unlock rather than spin_unlock
<pre>
	----------------------------
	
	
	It looks at least odd to apply spin_unlock to a mutex.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@def@
	declarer DEFINE_MUTEX;
	identifier m;
	@@
	
	DEFINE_MUTEX(m);
	
	@@
	identifier def.m;
	@@
	
	(
	- spin_lock(&m)
	+ mutex_lock(&m)
	|
	- spin_unlock(&m)
	+ mutex_unlock(&m)
	)
	// </smpl>
	
</pre>
<A HREF=crypto/crypto.cocci>crypto/crypto.cocci</A>  -  add NULL test around call to crypto_free_hash
<pre>
	crypto_free_hash calls the function crypto_hash_tfm and then
	crypto_free_tfm on the result.  crypto_free_tfm calls crypto_destroy_tfm,
	which tests this result for NULL and then dereferences it.  crypto_hash_tfm
	returns &tfm->base where tfm is its argument.  base is actually the first
	and only field of a crypto_hash-typed structure, so perhaps one can rely on
	it to return NULL for a NULL value of tfm.  But most calls to
	crypto_hash_tfm where the argument might be NULL don't rely on this
	property and test for NULL explicitly.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@safe@
	position p;
	expression x;
	@@
	
	if (x) { <+... crypto_free_hash@p(x) ...+> }
	
	@@
	expression x;
	position p!=safe.p;
	@@
	
	*x = NULL
	...
	*crypto_free_hash@p(x)
	// </smpl>
	
</pre>
<A HREF=cstptr/cstptr.cocci>cstptr/cstptr.cocci</A>  -  Move call to PTR_ERR after reassignment
<pre>
	PTR_ERR should be called before its argument is cleared.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1;
	constant c;
	@@
	
	*e = c
	... when != e = e1
	    when != &e
	    when != true IS_ERR(e)
	*PTR_ERR(e)
	// </smpl>
	
	Reported-by: Josh Triplett <josh@joshtriplett.org>
</pre>
<A HREF=ctu/ctu.cocci>ctu/ctu.cocci</A>  -  initialize all fields
<pre>
	The c32 structure is allocated on the stack and its idx field is not
	initialized before copying it to user level.  This patch takes the value
	from the result of the ioctl, as done for the other fields.
	
</pre>
<A HREF=da/da.cocci>da/da.cocci</A>  -  correct double assignment
<pre>
	The double assignment is meant to be a bit-or to combine two values.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression i;
	@@
	
	*i = ...;
	 i = ...;
	// </smpl>
	
</pre>
<A HREF=dall/dall.cocci>dall/dall.cocci</A>  -  use devm_ functions consistently
<pre>
	Use devm_kzalloc for all calls to kzalloc and not just the first.  Use devm
	functions for other allocations as well.
	
	Move the call to platform_get_resource(pdev, IORESOURCE_MEM, 0) closer to
	where its result is passed to devm_request_and_ioremap to make the lack of
	need for a NULL test more evident.
	
	The semantic match that finds the inconsistency is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	*devm_kzalloc(...)
	...
	*kzalloc(...)
	// </smpl>
	
</pre>
<A HREF=dangling/dangling.cocci>dangling/dangling.cocci</A>  -  Remove potential for use after free
<pre>
	In each function, the value apcm is stored in the private_data field of
	runtime.  At the same time the function ct_atc_pcm_free_substream is stored
	in the private_free field of the same structure.  ct_atc_pcm_free_substream
	dereferences and ultimately frees the value in the private_data field.  But
	each function can exit in an error case with apcm having been freed, in
	which case a subsequent call to the private_free function would perform a
	dereference after free.  On the other hand, if the private_free field is
	not initialized, it is NULL, and not invoked (see snd_pcm_detach_substream
	in sound/core/pcm.c).  To avoid the introduction of a dangling pointer, the
	initializations of the private_data and private_free fields are moved to
	the end of the function, past any possible free of apcm.  This is safe
	because the previous calls to snd_pcm_hw_constraint_integer and
	snd_pcm_hw_constraint_minmax, which take runtime as an argument, do not
	refer to either of these fields.
	
	In each function, there is one error case where apcm needs to be freed, and
	a call to kfree is added.
	
	The sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1,e2,e3;
	identifier f,free1,free2;
	expression a;
	@@
	
	*e->f = a
	... when != e->f = e1
	    when any
	if (...) {
	  ... when != free1(...,e,...)
	      when != e->f = e2
	* kfree(a)
	  ... when != free2(...,e,...)
	      when != e->f = e3
	}
	// </smpl>
	
</pre>
<A HREF=depspin/sl.cocci>depspin/sl.cocci</A>  -  Use DEFINE_SPINLOCK
<pre>
	----------------------------
	
	
	SPIN_LOCK_UNLOCKED is deprecated.  The following makes the change suggested
	in Documentation/spinlocks.txt
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	declarer name DEFINE_SPINLOCK;
	identifier xxx_lock;
	@@
	
	- spinlock_t xxx_lock = SPIN_LOCK_UNLOCKED;
	+ DEFINE_SPINLOCK(xxx_lock);
	// </smpl>
	
</pre>
<A HREF=derefnull/isnull.cocci>derefnull/isnull.cocci</A>  -  remove null dereference and unnecessary test
<pre>
	----------------------------
	
	
	In the first part of the patch, if ov is NULL, the previous call to
	mutex_lock would have failed.
	
	In the second part of the patch, a non-NULL test is removed, since if the
	value is NULL, the line before would have failed.
	
	Near the end of this function there is an initialization of ov to NULL
	after a kfree, even though no further reference to this variable is
	possible.  Perhaps this is considered good style, and thus I have left it
	as is.
	
	The first problem was detected using the following semantic match
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E, E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	* if (E == NULL)
	{
	  ... when != if (E == NULL) S1 else S2
	      when != E = E1
	* E->f
	  ... when any
	  return ...;
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=devm2/devm2i.cocci>devm2/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses devm_kzalloc, devm_request_irq, etc. for data
	that is allocated in the probe function of a platform device and is only
	freed in the remove function.
	
	This patch changes the semantics in the case of exynos_hdmi.c, in that in
	the original code, there was no free of drm_hdmi_ctx in the remove function.
	
</pre>
<A HREF=devm2a/devm2i.cocci>devm2a/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2b/devm2i.cocci>devm2b/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	By using devm_ioremap, it also removes a potential memory leak, because
	there was no call to iounmap in the probe function.
	
	The call to platform_get_resource was moved just to make it closer to the
	place where its result it used.
	
</pre>
<A HREF=devm2i_0729/devm2i.cocci>devm2i_0729/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	A new label name is created in one case to better reflect the contents of
	the error-handling code.
	
</pre>
<A HREF=devm2i_0729/request_and_ioremap.cocci>devm2i_0729/request_and_ioremap.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	A new label name is created in one case to better reflect the contents of
	the error-handling code.
	
</pre>
<A HREF=devm2i_0730/devm2i.cocci>devm2i_0730/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2i_0730/request_and_ioremap.cocci>devm2i_0730/request_and_ioremap.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2i_0731/devm2i.cocci>devm2i_0731/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	The call to platform_get_resource(pdev, IORESOURCE_MEM, 0) is moved closer
	to the new call to devm_request_and_ioremap where its result is first
	used.  devm_request_and_ioremap takes case of the NULL test on the result
	of platform_get_resource(pdev, IORESOURCE_MEM, 0), so that is dropped.
	
</pre>
<A HREF=devm2i_0731/request_and_ioremap.cocci>devm2i_0731/request_and_ioremap.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	The call to platform_get_resource(pdev, IORESOURCE_MEM, 0) is moved closer
	to the new call to devm_request_and_ioremap where its result is first
	used.  devm_request_and_ioremap takes case of the NULL test on the result
	of platform_get_resource(pdev, IORESOURCE_MEM, 0), so that is dropped.
	
</pre>
<A HREF=devm2i_aug25/devm2i.cocci>devm2i_aug25/devm2i.cocci</A>  -  ibm_iic: use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2i_aug25/request_and_ioremap.cocci>devm2i_aug25/request_and_ioremap.cocci</A>  -  ibm_iic: use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm4/devm4.cocci>devm4/devm4.cocci</A>  -  drop iounmap for devm_ allocated data
<pre>
	Data allocated with devm_ioremap or devm_ioremap_nocache should not be
	freed using iounmap, because doing so causes a dangling pointer, and a
	subsequent double free.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression x;
	@@
	(
	 x = devm_ioremap(...)
	|
	 x = devm_ioremap_nocache(...)
	)
	
	@@
	expression r.x;
	@@
	* iounmap(x)
	// </smpl>
	
</pre>
<A HREF=devm6/devm6.cocci>devm6/devm6.cocci</A>  -  use devm_request_and_ioremap
<pre>
	Reimplement a call to devm_request_mem_region followed by a call to ioremap
	or ioremap_nocache by a call to devm_request_and_ioremap.
	
	The semantic patch that makes this transformation is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@nm@
	expression myname;
	identifier i;
	@@
	
	struct platform_driver i = { .driver = { .name = myname } };
	
	@@
	expression dev,res,size;
	expression nm.myname;
	@@
	
	-if (!devm_request_mem_region(dev, res->start, size,
	-                              \(res->name\|dev_name(dev)\|myname\))) {
	-   ...
	-   return ...;
	-}
	... when != res->start
	(
	-devm_ioremap(dev,res->start,size)
	+devm_request_and_ioremap(dev,res)
	|
	-devm_ioremap_nocache(dev,res->start,size)
	+devm_request_and_ioremap(dev,res)
	)
	... when any
	    when != res->start
	// </smpl>
	
</pre>
<A HREF=devname/devname.cocci>devname/devname.cocci</A>  -  eliminate NULL dereference
<pre>
	----------------------------
	
	
	dev_name always dereferences its argument, so it should not be called if
	the argument is NULL.  The function indeed later tests the argument for
	being NULL.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression dev,E;
	@@
	
	*dev_name(dev)
	... when != dev = E
	(
	*dev == NULL
	|
	*dev != NULL
	)
	// </smpl>
	
</pre>
<A HREF=diou/diou.cocci>diou/diou.cocci</A>  -  drop kfree of devm_kzalloc's data
<pre>
	Using kfree to free data allocated with devm_kzalloc causes double frees.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x;
	@@
	
	x = devm_kzalloc(...)
	...
	?-kfree(x);
	// </smpl>
	
</pre>
<A HREF=diou2/diou.cocci>diou2/diou.cocci</A>  -  drop devm_kfree of devm_kzalloc'd data
<pre>
	devm_kfree should not have to be explicitly used.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,d;
	@@
	
	x = devm_kzalloc(...)
	...
	?-devm_kfree(d,x);
	// </smpl>
	
</pre>
<A HREF=diou3/devm3.cocci>diou3/devm3.cocci</A>  -  some devm_ cleanups
<pre>
	devm free functions should not have to be explicitly used.
	
	The only thing left that is useful in the function mpc5121_nfc_free is the
	call to clk_disable, which is moved to the call sites.
	
	This function also incorrectly called iounmap on devm_ioremap allocated
	data.
	
	Use devm_request_and_ioremap in place of devm_request_mem_region and
	devm_ioremap.
	
	Use devm_clk_get.
	
	A semantic match that finds the first problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	(
	* devm_kfree(...);
	|
	* devm_free_irq(...);
	|
	* devm_iounmap(...);
	|
	* devm_release_region(...);
	|
	* devm_release_mem_region(...);
	)
	// </smpl>
	
</pre>
<A HREF=dma/set_dma_mode_1.cocci>dma/set_dma_mode_1.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=double_call/dc.cocci>double_call/dc.cocci</A>  -  Eliminate useless code
<pre>
	----------------------------
	
	
	The variable client is initialized twice to the same (side effect-free)
	expression.  Drop one initialization.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@forall@
	idexpression *x;
	identifier f!=ERR_PTR;
	@@
	
	x = f(...)
	... when != x
	(
	x = f(...,<+...x...+>,...)
	|
	* x = f(...)
	)
	// </smpl>
	
</pre>
<A HREF=double_lock/double_lock.cocci>double_lock/double_lock.cocci</A>  -  Eliminate a double lock
<pre>
	----------------------------
	
	
	The path around the loop ends with the lock held, so the call to mutex_lock
	is moved before the beginning of the loop.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@locked@
	expression E1;
	position p;
	@@
	
	read_lock(E1@p,...);
	
	@r exists@
	expression x <= locked.E1;
	expression locked.E1;
	expression E2;
	identifier lock;
	position locked.p,p1,p2;
	@@
	
	*lock@p1 (E1@p,...);
	... when != E1
	    when != \(x = E2\|&x\)
	*lock@p2 (E1,...);
	// </smpl>
	
</pre>
<A HREF=double_null/double_null.cocci>double_null/double_null.cocci</A>  -  Correct NULL test
<pre>
	----------------------------
	
	
	Test the value that was just allocated rather than the previously tested one.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression *x;
	expression e;
	identifier l;
	@@
	
	if (x == NULL || ...) {
	    ... when forall
	    return ...; }
	... when != goto l;
	    when != x = e
	    when != &x
	*x == NULL
	// </smpl>
	
</pre>
<A HREF=double_test/double_test.cocci>double_test/double_test.cocci</A>  -  introduce missing initialization
<pre>
	The result of one call to a function is tested, and then at the second call
	to the same function, the previous result, and not the current result, is
	tested again.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression ret;
	identifier f;
	statement S1,S2;
	@@
	
	*ret = f(...);
	if (\(ret != 0\|ret < 0\|ret == NULL\)) S1
	... when any
	*f(...);
	if (\(ret != 0\|ret < 0\|ret == NULL\)) S2
	// </smpl>
	
</pre>
<A HREF=doublefree/frees.cocci>doublefree/frees.cocci</A>  -  Eliminate double kfree
<pre>
	jbarnes@virtuousgeek.org, linux-pci@vger.kernel.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH 1/2] Eliminate double kfree
	
	------------------------------------------------------
	
	
	The destination of goto error also does a kfree(g_iommus), so it is not
	correct to do one here.
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r1@
	expression E;
	position p1,p2;
	@@
	
	kfree@p1(E);
	...
	kfree@p2(E);
	
	@subexps@
	expression E1;
	position r1.p1,p;
	@@
	
	kfree@p1(<+... E1@p ...+>);
	
	@recollect@
	position subexps.p;
	expression E1;
	@@
	
	E1@p
	
	@doublekfree@
	position r1.p1,r1.p2;
	expression recollect.E1,E2,E;
	position p;
	statement S;
	@@
	
	kfree@p1(E);
	<+... E1@p=E2 ...+> // the actual semantic match contains other assignments
	kfree@p2(E);
	
	@notdoublekfree@
	position r1.p1,r1.p2;
	position any doublekfree.p;
	expression E,E1,E2;
	@@
	
	* kfree@p1(E);
	... when != E1@p
	    when != E1@p = E2 // needed to match a variable decl
	* kfree@p2(E);
	// </smpl>
	
</pre>
<A HREF=doubleinit/doubleinit.cocci>doubleinit/doubleinit.cocci</A>  -  remove duplicate structure field initialization
<pre>
	----------------------------
	
	
	The definition of uml_netdev_ops has initializations of a local function
	and eth_mac_addr for its ndo_set_mac_address field.  This change uses only
	the local function.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier I, s, fld;
	position p0,p;
	expression E;
	@@
	
	struct I s =@p0 { ... .fld@p = E, ...};
	
	@s@
	identifier I, s, r.fld;
	position r.p0,p;
	expression E;
	@@
	
	struct I s =@p0 { ... .fld@p = E, ...};
	
	@script:python@
	p0 << r.p0;
	fld << r.fld;
	ps << s.p;
	pr << r.p;
	@@
	
	if int(ps[0].line)!=int(pr[0].line) or int(ps[0].column)!=int(pr[0].column):
	  cocci.print_main(fld,p0)
	// </smpl>
	
</pre>
<A HREF=doublermr/doublermr.cocci>doublermr/doublermr.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=doubletest/doubletest.cocci>doubletest/doubletest.cocci</A>  -  Remove double test
<pre>
	The current code tests the gpio_vid0 field twice.  Test the gpio_vid1
	fields in place of the second gpio_vid0 test.
	
	The sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@expression@
	expression E;
	@@
	
	(
	* E
	  || ... || E
	|
	* E
	  && ... && E
	)
	// </smpl>
	
</pre>
<A HREF=doubletest_high/doubletest_highconfidence.cocci>doubletest_high/doubletest_highconfidence.cocci</A>  -  adjust double test
<pre>
	Rewrite a duplicated test to test the correct value
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E;
	@@
	
	(
	* E
	  || ... || E
	|
	* E
	  && ... && E
	)
	// </smpl>
	
</pre>
<A HREF=drop_continue/cont.cocci>drop_continue/cont.cocci</A>  -  Drop unnecessary continue
<pre>
	Send to:
	tony.luck@intel.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/4] arch/ia64: Drop unnecessary continue
	
	
	------------------------------------------------------
	
	
	Continue is not needed at the bottom of a loop.
	
	The semantic patch implementing this change is as follows:
	
	@@
	statement S;
	@@
	
	for (...;...;...) {
	  ...
	  if (...)
	- {
	    S
	-   continue;
	- }
	}
	
</pre>
<A HREF=drvdata/drvdata.cocci>drvdata/drvdata.cocci</A>  -  use dev_set_drvdata
<pre>
	----------------------------
	
	
	Eliminate direct accesses to the driver_data field.
	cf 82ab13b26f15f49be45f15ccc96bfa0b81dfd015
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct device *dev;
	expression E;
	type T;
	@@
	
	- dev->driver_data = (T)E
	+ dev_set_drvdata(dev, E)
	
	@@
	struct device *dev;
	type T;
	@@
	
	- (T)dev->driver_data
	+ dev_get_drvdata(dev)
	// </smpl>
	
</pre>
<A HREF=dst/dst.cocci>dst/dst.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=enter/enter.cocci>enter/enter.cocci</A>  -  Convert func_enter to func_exit
<pre>
	Convert calls to func_enter on leaving a function to func_exit.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	- func_enter();
	+ func_exit();
	  return...;
	// </smpl>
	
</pre>
<A HREF=epd/epd.cocci>epd/epd.cocci</A>  -  use USB API functions rather than constants
<pre>
	----------------------------
	
	
	This set of patches introduces calls to the following set of functions:
	
	usb_endpoint_dir_in(epd)
	usb_endpoint_dir_out(epd)
	usb_endpoint_is_bulk_in(epd)
	usb_endpoint_is_bulk_out(epd)
	usb_endpoint_is_int_in(epd)
	usb_endpoint_is_int_out(epd)
	usb_endpoint_num(epd)
	usb_endpoint_type(epd)
	usb_endpoint_xfer_bulk(epd)
	usb_endpoint_xfer_control(epd)
	usb_endpoint_xfer_int(epd)
	usb_endpoint_xfer_isoc(epd)
	
	In some cases, introducing one of these functions is not possible, and it
	just replaces an explicit integer value by one of the following constants:
	
	USB_ENDPOINT_XFER_BULK
	USB_ENDPOINT_XFER_CONTROL
	USB_ENDPOINT_XFER_INT
	USB_ENDPOINT_XFER_ISOC
	
	An extract of the semantic patch that makes these changes is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r1@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_CONTROL\|0\))
	+ usb_endpoint_xfer_control(epd)
	
	@r5@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) ==
	-  \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_in(epd)
	
	@inc@
	@@
	
	#include <linux/usb.h>
	
	@depends on !inc && (r1||r5)@
	@@
	
	+ #include <linux/usb.h>
	  #include <linux/usb/...>
	// </smpl>
	
</pre>
<A HREF=epd/mini.cocci>epd/mini.cocci</A>  -  use USB API functions rather than constants
<pre>
	----------------------------
	
	
	This set of patches introduces calls to the following set of functions:
	
	usb_endpoint_dir_in(epd)
	usb_endpoint_dir_out(epd)
	usb_endpoint_is_bulk_in(epd)
	usb_endpoint_is_bulk_out(epd)
	usb_endpoint_is_int_in(epd)
	usb_endpoint_is_int_out(epd)
	usb_endpoint_num(epd)
	usb_endpoint_type(epd)
	usb_endpoint_xfer_bulk(epd)
	usb_endpoint_xfer_control(epd)
	usb_endpoint_xfer_int(epd)
	usb_endpoint_xfer_isoc(epd)
	
	In some cases, introducing one of these functions is not possible, and it
	just replaces an explicit integer value by one of the following constants:
	
	USB_ENDPOINT_XFER_BULK
	USB_ENDPOINT_XFER_CONTROL
	USB_ENDPOINT_XFER_INT
	USB_ENDPOINT_XFER_ISOC
	
	An extract of the semantic patch that makes these changes is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r1@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_CONTROL\|0\))
	+ usb_endpoint_xfer_control(epd)
	
	@r5@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) ==
	-  \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_in(epd)
	
	@inc@
	@@
	
	#include <linux/usb.h>
	
	@depends on !inc && (r1||r5)@
	@@
	
	+ #include <linux/usb.h>
	  #include <linux/usb/...>
	// </smpl>
	
</pre>
<A HREF=epdneg/epdneg.cocci>epdneg/epdneg.cocci</A>  -  Use negated usb_endpoint_xfer_control, etc
<pre>
	----------------------------
	
	
	This patch extends 42a6e66f1e40a930d093c33ba0bb9d8d8e4555ed by using
	usb_endpoint_xfer_control, usb_endpoint_xfer_isoc, usb_endpoint_xfer_bulk,
	and usb_endpoint_xfer_int in the negated case as well.
	
	This patch also rewrites some calls to usb_endpoint_dir_in as negated calls
	to !usb_endpoint_dir_out, and vice versa, to better correspond to the
	intent of the original code.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_type(epd) != \(USB_ENDPOINT_XFER_CONTROL\|0\))
	+ !usb_endpoint_xfer_control(epd)
	
	@@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_type(epd) != \(USB_ENDPOINT_XFER_ISOC\|1\))
	+ !usb_endpoint_xfer_isoc(epd)
	
	@@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_type(epd) != \(USB_ENDPOINT_XFER_BULK\|2\))
	+ !usb_endpoint_xfer_bulk(epd)
	
	@@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_type(epd) != \(USB_ENDPOINT_XFER_INT\|3\))
	+ !usb_endpoint_xfer_int(epd)
	// </smpl>
	
</pre>
<A HREF=even_more_pci/get_slot.cocci>even_more_pci/get_slot.cocci</A>  -  Add missing pci_dev_get
<pre>
	drivers/char/agp/amd64-agp.c
	
	Send to:
	airlied@linux.ie, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/2] drivers/char/agp: Add missing pci_dev_get
	
	------------------------------------------------------
	
	
	pci_get_slot does a pci_dev_get, so pci_dev_put needs to be called in an
	error case.
	
	In the first three cases, it might also be possible to move the call to
	pci_get_slot downwards below the error handling code.
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	local idexpression *n;
	statement S1,S2;
	expression E,E1;
	expression *ptr != NULL;
	type T,T1;
	@@
	
	(
	if (!(n = pci_get_slot(...))) S1
	|
	n = pci_get_slot(...)
	)
	<... when != pci_dev_put(n)
	    when != if (...) { <+... pci_dev_put(n) ...+> }
	    when != true !n  || ...
	    when != n = (T)E
	    when != E = n
	if (!n || ...) S2
	...>
	(
	  return \(0\|<+...n...+>\|ptr\);
	|
	+ pci_dev_put(n);
	return ...;
	|
	pci_dev_put(n);
	|
	n = (T1)E1
	|
	E1 = n
	)
	// </smpl>
	
</pre>
<A HREF=extra_put/extra_put.cocci>extra_put/extra_put.cocci</A>  -  Drop unneeded of_node_put
<pre>
	Send to:
	benh@kernel.crashing.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] arch/powerpc/platforms/powermac: Drop unneeded of_node_put
	
	
	------------------------------------------------------
	
	
	After using for_each_node_by_name, there is no need for of_node_put unless
	there was a break in the loop body, as for_each_node_by_name does a
	of_node_put on each of the elements it returns.
	
	This was detected and fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	iterator for_each_node_by_name;
	expression d;
	@@
	
	  for_each_node_by_name(d,...) {
	    ... when != break;
	  }
	  ... when != d
	?- of_node_put(d);
	// </smpl>
	
</pre>
<A HREF=fbrelease/metapatch.cocci>fbrelease/metapatch.cocci</A>  -  eliminate double free
<pre>
	adaplas@gmail.com, linux-fbdev-devel@lists.sourceforge.net, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH] drivers/video/pnx4008: eliminate double free
	
	------------------------------------------------------
	
	
	The function framebuffer_release just calls kfree, so calling kfree
	subsequently on the same argument represents a double free.  The
	comments with the definition of framebuffer_release
	in drivers/video/fbsysfs.c suggest that a more elaborate definition of this
	function is planned, such that the splitting up of framebuffer_release and
	kfree as done in the second instance might someday make sense, but it does
	not make sense now. 
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	@@
	
	* kfree(E);
	...
	* framebuffer_release(E);
	
	@@
	expression E;
	@@
	
	* framebuffer_release(E);
	...
	* kfree(E);
	// </smpl>
	
</pre>
<A HREF=fbrelease/patch.cocci>fbrelease/patch.cocci</A>  -  eliminate double free
<pre>
	adaplas@gmail.com, linux-fbdev-devel@lists.sourceforge.net, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH] drivers/video/pnx4008: eliminate double free
	
	------------------------------------------------------
	
	
	The function framebuffer_release just calls kfree, so calling kfree
	subsequently on the same argument represents a double free.  The
	comments with the definition of framebuffer_release
	in drivers/video/fbsysfs.c suggest that a more elaborate definition of this
	function is planned, such that the splitting up of framebuffer_release and
	kfree as done in the second instance might someday make sense, but it does
	not make sense now. 
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	@@
	
	* kfree(E);
	...
	* framebuffer_release(E);
	
	@@
	expression E;
	@@
	
	* framebuffer_release(E);
	...
	* kfree(E);
	// </smpl>
	
</pre>
<A HREF=fen/fen.cocci>fen/fen.cocci</A>  -  Drop unnecessary of_node_put
<pre>
	----------------------------
	
	
	for_each_node_by_name only exits when its first argument is NULL, and a
	subsequent call to of_node_put on that argument is unnecessary.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	iterator name for_each_node_by_name;
	expression np,E;
	identifier l;
	@@
	
	for_each_node_by_name(np,...) {
	  ... when != break;
	      when != goto l;
	}
	... when != np = E
	- of_node_put(np);
	// </smpl>
	
</pre>
<A HREF=fields/field.cocci>fields/field.cocci</A>  -  Use FIELD_SIZEOF
<pre>
	----------------------------
	
	
	Robert P.J. Day proposed to use the macro FIELD_SIZEOF in replace of code
	that matches its definition.
	
	The modification was made using the following semantic patch
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@haskernel@
	@@
	
	#include <linux/kernel.h>
	
	@depends on haskernel@
	type t;
	identifier f;
	@@
	
	- (sizeof(((t*)0)->f))
	+ FIELD_SIZEOF(t, f)
	
	@depends on haskernel@
	type t;
	identifier f;
	@@
	
	- sizeof(((t*)0)->f)
	+ FIELD_SIZEOF(t, f)
	// </smpl>
	
</pre>
<A HREF=frfr/frfr.cocci>frfr/frfr.cocci</A>  -  Eliminate double free
<pre>
	----------------------------
	
	
	The few lines below the kfree of hdr_buf may go to the label err_free which
	will also free hdr_buf.  The most straightforward solution seems to be to
	just move the kfree of hdr_buf after these gotos.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier E;
	expression E1;
	iterator I;
	statement S;
	@@
	
	*kfree(E);
	... when != E = E1
	    when != I(E,...) S
	    when != &E
	*kfree(E);
	// </smpl>
	
</pre>
<A HREF=fuse/fuse.cocci>fuse/fuse.cocci</A>  -  Add missing fuse_request_alloc
<pre>
	----------------------------
	
	
	The error handling code for the second call to fuse_request_alloc should
	include freeing the result of the first one.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S;
	position p1,p2,p3;
	@@
	
	(
	if ((x = fuse_request_alloc@p1(...)) == NULL || ...) S
	|
	x = fuse_request_alloc@p1(...)
	... when != x
	if (x == NULL || ...) S
	)
	<...
	if@p3 (...) { ... when != fuse_request_free(x)
	    return@p2 ...;
	}
	...>
	(
	return x;
	|
	return 0;
	|
	x = E
	|
	E = x
	|
	fuse_request_free(x)
	)
	
	@exists@
	position r.p1,r.p2,r.p3;
	expression x;
	int ret != 0;
	statement S;
	@@
	
	* x = fuse_request_alloc@p1(...)
	  <...
	* if@p3 (...)
	  S
	  ...>
	* return@p2 \(NULL\|ret\);
	
	// </smpl>
	
</pre>
<A HREF=gdth/gdth.cocci>gdth/gdth.cocci</A>  -  Add missing call to gdth_ioctl_free
<pre>
	----------------------------
	
	
	Add missing call to gdth_ioctl_free before aborting.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression buf,ha,len,addr,E;
	@@
	
	buf = gdth_ioctl_alloc(ha, len, FALSE, &addr)
	... when != false buf != NULL
	    when != true buf == NULL
	    when != \(E = buf\|buf = E\)
	    when != gdth_ioctl_free(ha, len, buf, addr)
	*return ...;
	// </smpl>
	
</pre>
<A HREF=gfs2/category2a_gfs2_inode_lookup.cocci>gfs2/category2a_gfs2_inode_lookup.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function gfs2_inode_lookup returns an
	ERR pointer, but never returns a NULL pointer. So a NULL test that
	necessarily comes after an IS_ERR test should be deleted, and a NULL
	test that may come after a call to this function should be
	strengthened by an IS_ERR test.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = gfs2_inode_lookup(...)
	... when != x = E
	* if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=gmc/gmc.cocci>gmc/gmc.cocci</A>  -  Avoid call to genlmsg_cancel
<pre>
	genlmsg_cancel subtracts some constants from its second argument before
	calling nlmsg_cancel.  nlmsg_cancel then calls nlmsg_trim on the same
	arguments.  nlmsg_trim tests for NULL before doing any computation, but a
	NULL second argument to genlmsg_cancel is no longer NULL due to the initial
	subtraction.  Nothing else happens in this execution, so the call to
	genlmsg_cancel is simply unnecessary in this case.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression data;
	@@
	
	if (data == NULL) { ...
	* genlmsg_cancel(..., data);
	  ...
	  return ...;
	}
	// </smpl>
	
</pre>
<A HREF=handle/handle.cocci>handle/handle.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=hrtimer/hrtimer.cocci>hrtimer/hrtimer.cocci</A>  -  use function hrtimer_is_queued
<pre>
	----------------------------
	
	
	Use the hrtimer_is_queued function rather than an explicit bit-and for
	testing timer->state, as done elsewhere.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@header@
	@@
	
	#include <linux/hrtimer.h>
	
	@depends on header@
	struct hrtimer *timer;
	@@
	
	- (timer->state & HRTIMER_STATE_ENQUEUED)
	+ hrtimer_is_queued(timer)
	// </smpl>
	
</pre>
<A HREF=i2c_msg/i2c_msg.cocci>i2c_msg/i2c_msg.cocci</A>  -  use macros for i2c_msg initialization
<pre>
	Introduce use of I2c_MSG_READ/WRITE/OP, for readability.
	
	In the second i2c_msg structure, a length expressed as an explicit constant
	is also re-expressed as the size of the buffer, reg.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression a,b,c;
	identifier x;
	@@
	
	struct i2c_msg x =
	- {.addr = a, .buf = b, .len = c, .flags = I2C_M_RD}
	+ I2C_MSG_READ(a,b,c)
	 ;
	
	@@
	expression a,b,c;
	identifier x;
	@@
	
	struct i2c_msg x =
	- {.addr = a, .buf = b, .len = c, .flags = 0}
	+ I2C_MSG_WRITE(a,b,c)
	 ;
	
	@@
	expression a,b,c,d;
	identifier x;
	@@
	
	struct i2c_msg x = 
	- {.addr = a, .buf = b, .len = c, .flags = d}
	+ I2C_MSG_OP(a,b,c,d)
	 ;
	// </smpl>
	
</pre>
<A HREF=i915/sp1517.cocci>i915/sp1517.cocci</A>  -  Add missing error handling code
<pre>
	The cleanup code at the end of the function should also be carried out when
	the function only partly completes its work.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct page ** x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = drm_malloc_ab@p1(...)
	...  when != x = rr
	     when != drm_free_large(x,...)
	     when != if (...) { ... drm_free_large(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != drm_free_large(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"drm_malloc_ab\",p1)
	cocci.print_secs(\"return\",p2)
	
	// </smpl>
	
</pre>
<A HREF=ie2/ie2.cocci>ie2/ie2.cocci</A>  -  Convert IS_ERR result to PTR_ERR
<pre>
	This code elsewhere returns a negative constant to an indicate an error,
	while IS_ERR returns the result of a >= operation.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x;
	@@
	
	 if (...) { ...
	- return IS_ERR(x);
	+ return PTR_ERR(x);
	}
	// </smpl>
	
</pre>
<A HREF=if-semicolon/if-semicolon.cocci>if-semicolon/if-semicolon.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=ifcol/ifcol.cocci>ifcol/ifcol.cocci</A>  -  Adjust confusing if indentation
<pre>
	----------------------------
	
	
	Outdent the code following the if.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r disable braces4@
	position p1,p2;
	statement S1,S2;
	@@
	
	(
	if (...) { ... }
	|
	if (...) S1@p1 S2@p2
	)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	if (p1[0].column == p2[0].column):
	  cocci.print_main(\"branch\",p1)
	  cocci.print_secs(\"after\",p2)
	// </smpl>
	
</pre>
<A HREF=iff/iff.cocci>iff/iff.cocci</A>  -  fix error return code
<pre>
	Convert a possibly 0 error return code to a negative one, as returned
	elsewhere in the function.
	
	The return variable, error, is previously initialized to -EINVAL, but a
	comment suggests that that value is intended for an earlier condition.
	Here the code is changed to just return the value returned by uprobe_mmap.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression ret;
	constant C;
	expression e1,e2;
	identifier l;
	@@
	
	* ret = -C;
	  ...
	* if (...)
	 {
	  ... when any
	* if (ret)
	    { ...
	*     return ret;
	    }
	  ... when any
	      when forall
	      when != return ...;
	      when != goto l;
	 }
	... when any
	    when != ret = e1
	* if (...)
	  { ... when != ret = e2
	*   return ret;
	  }
	// </smpl>
	
</pre>
<A HREF=ifseqerr/ifseqerr.cocci>ifseqerr/ifseqerr.cocci</A>  -  Remove unnecessary error check
<pre>
	This code does not call deinit_card(card); in an error case, as done in
	other error-handling code in the same function.  But actually, the called
	function init_sram can only return 0, so there is no need for the error
	check at all.
	
	init_sram is also given a void return type, and its single return statement
	at the end of the function is dropped.
	
	A simplified version of the sematic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	@r@
	statement S1,S2,S3;
	constant C1,C2,C3;
	@@
	
	*if (...)
	 {... S1 return -C1;}
	...
	*if (...)
	 {... when != S1
	    return -C2;}
	...
	*if (...)
	 {... S1 return -C3;}
	// </smpl>
	
</pre>
<A HREF=incon/incon3.cocci>incon/incon3.cocci</A>  -  eliminate possible double free
<pre>
	The function __iio_add_event_config_attrs is only called once, by the
	function iio_device_register_eventset.  If the call fails,
	iio_device_register_eventset calls __iio_remove_event_config_attrs.  There
	is thus no need for __iio_add_event_config_attrs to also call
	__iio_remove_event_config_attrs on failure.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier f,free,a;
	parameter list[n] ps;
	type T;
	expression e;
	@@
	
	f(ps,T a,...) {
	  ... when any
	      when != a = e
	  if(...) { ... free(a); ... return ...; }
	  ... when any
	}
	
	@@
	identifier r.f,r.free;
	expression x,a;
	expression list[r.n] xs;
	@@
	
	* x = f(xs,a,...);
	  if (...) { ... free(a); ... return ...; }
	// </smpl>
	
</pre>
<A HREF=inconsistent/inconsistent1.cocci>inconsistent/inconsistent1.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=infiniband/category2a_ib_create_send_mad.cocci>infiniband/category2a_ib_create_send_mad.cocci</A>  -  Use a NULL test rather than an IS_ERR test
<pre>
	general@lists.openfabrics.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/infiniband/core: Use a NULL test rather than an IS_ERR test
	
	----------------------------
	
	
	In case of error, the function ucma_alloc_multicast returns a NULL
	pointer, but never returns an ERR pointer. So after a call to this
	function, an IS_ERR test should be replaced by a NULL test.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match bad_is_err_test@
	expression x, E;
	@@
	
	x = ucma_alloc_multicast(...)
	... when != x = E
	IS_ERR(x)
	// </smpl>
	
</pre>
<A HREF=infiniband/category2a_ucma_alloc_multicast.cocci>infiniband/category2a_ucma_alloc_multicast.cocci</A>  -  Use a NULL test rather than an IS_ERR test
<pre>
	general@lists.openfabrics.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/infiniband/core: Use a NULL test rather than an IS_ERR test
	
	----------------------------
	
	
	In case of error, the function ucma_alloc_multicast returns a NULL
	pointer, but never returns an ERR pointer. So after a call to this
	function, an IS_ERR test should be replaced by a NULL test.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match bad_is_err_test@
	expression x, E;
	@@
	
	x = ucma_alloc_multicast(...)
	... when != x = E
	IS_ERR(x)
	// </smpl>
	
</pre>
<A HREF=input/sp2486.cocci>input/sp2486.cocci</A>  -  Correct call to input_free_device
<pre>
	This error handling code can be reached before ts_dev->input is
	initialized, so it is safer to always use the original name, input_dev.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct input_dev * x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = input_allocate_device@p1(...)
	...  when != x = rr
	     when != input_free_device(x,...)
	     when != if (...) { ... input_free_device(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != input_free_device(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"input_allocate_device\",p1)
	cocci.print_secs(\"input_free_device\",p2)
	// </smpl>
	
</pre>
<A HREF=input/sp2495.cocci>input/sp2495.cocci</A>  -  Correct call to input_free_device
<pre>
	This error handling code can be reached before ts_dev->input is
	initialized, so it is safer to always use the original name, input_dev.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct input_dev * x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = input_allocate_device@p1(...)
	...  when != x = rr
	     when != input_free_device(x,...)
	     when != if (...) { ... input_free_device(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != input_free_device(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"input_allocate_device\",p1)
	cocci.print_secs(\"input_free_device\",p2)
	// </smpl>
	
</pre>
<A HREF=input/sp2506.cocci>input/sp2506.cocci</A>  -  Correct call to input_free_device
<pre>
	This error handling code can be reached before ts_dev->input is
	initialized, so it is safer to always use the original name, input_dev.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct input_dev * x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = input_allocate_device@p1(...)
	...  when != x = rr
	     when != input_free_device(x,...)
	     when != if (...) { ... input_free_device(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != input_free_device(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"input_allocate_device\",p1)
	cocci.print_secs(\"input_free_device\",p2)
	// </smpl>
	
</pre>
<A HREF=iom/devm2i.cocci>iom/devm2i.cocci</A>  -  add missing iounmap
<pre>
	Add missing iounmap in error handling code, in a case where the function
	already preforms iounmap on some other execution path.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e;
	statement S,S1;
	int ret;
	@@
	e = \(ioremap\|ioremap_nocache\)(...)
	... when != iounmap(e)
	if (<+...e...+>) S
	... when any
	    when != iounmap(e)
	*if (...)
	   { ... when != iounmap(e)
	     return ...; }
	... when any
	iounmap(e);
	// </smpl>
	
</pre>
<A HREF=iom/iom.cocci>iom/iom.cocci</A>  -  add missing iounmap
<pre>
	Add missing iounmap in error handling code, in a case where the function
	already preforms iounmap on some other execution path.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e;
	statement S,S1;
	int ret;
	@@
	e = \(ioremap\|ioremap_nocache\)(...)
	... when != iounmap(e)
	if (<+...e...+>) S
	... when any
	    when != iounmap(e)
	*if (...)
	   { ... when != iounmap(e)
	     return ...; }
	... when any
	iounmap(e);
	// </smpl>
	
</pre>
<A HREF=iounmap/ioremap_check.cocci>iounmap/ioremap_check.cocci</A>  -  Added a missing iounmap
<pre>
	----------------------------
	
	
	An extra error handling label is needed for the case where the ioremap has
	succeeded.
	
	The problem was detected using the following semantic match
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2;
	constant C;
	int ret;
	@@
	
	  T E;
	  ...
	* E = ioremap(...);
	  if (E == NULL) S
	  ... when != iounmap(E)
	      when != if (E != NULL) { ... iounmap(E); ...}
	      when != x1 = (T1)E
	  if (...) {
	    ... when != iounmap(E)
	        when != if (E != NULL) { ... iounmap(E); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return C;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=is_static/is_static.cocci>is_static/is_static.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=iserr/patch1.cocci>iserr/patch1.cocci</A>  -  simplify error handling
<pre>
	----------------------------
	
	
	nf_conntrack_alloc cannot return NULL, so there is no need to check for
	NULL before using the value.  I have also removed the initialization of ct
	to NULL in nf_conntrack_alloc, since the value is never used, and since
	perhaps it might lead one to think that return ct at the end might return
	NULL.
	
	The semantic patch that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match exists@
	expression x, E;
	position p1,p2;
	statement S1, S2;
	@@
	
	x@p1 = nf_conntrack_alloc(...)
	... when != x = E
	(
	  if (x@p2 == NULL || ...) S1 else S2
	|
	  if (x@p2 == NULL && ...) S1 else S2
	)
	
	@other_match exists@
	expression match.x, E1, E2;
	position p1!=match.p1,match.p2;
	@@
	
	x@p1 = E1
	... when != x = E2
	x@p2
	
	@ script:python depends on !other_match@
	p1 << match.p1;
	p2 << match.p2;
	@@
	
	print \"%s: call to nf_conntrack_alloc %s bad test %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=iserr/patch2.cocci>iserr/patch2.cocci</A>  -  simplify error handling
<pre>
	----------------------------
	
	
	nf_conntrack_alloc cannot return NULL, so there is no need to check for
	NULL before using the value.  I have also removed the initialization of ct
	to NULL in nf_conntrack_alloc, since the value is never used, and since
	perhaps it might lead one to think that return ct at the end might return
	NULL.
	
	The semantic patch that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match exists@
	expression x, E;
	position p1,p2;
	statement S1, S2;
	@@
	
	x@p1 = nf_conntrack_alloc(...)
	... when != x = E
	(
	  if (x@p2 == NULL || ...) S1 else S2
	|
	  if (x@p2 == NULL && ...) S1 else S2
	)
	
	@other_match exists@
	expression match.x, E1, E2;
	position p1!=match.p1,match.p2;
	@@
	
	x@p1 = E1
	... when != x = E2
	x@p2
	
	@ script:python depends on !other_match@
	p1 << match.p1;
	p2 << match.p2;
	@@
	
	print \"%s: call to nf_conntrack_alloc %s bad test %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=iserr/patch3.cocci>iserr/patch3.cocci</A>  -  simplify error handling
<pre>
	----------------------------
	
	
	nf_conntrack_alloc cannot return NULL, so there is no need to check for
	NULL before using the value.  I have also removed the initialization of ct
	to NULL in nf_conntrack_alloc, since the value is never used, and since
	perhaps it might lead one to think that return ct at the end might return
	NULL.
	
	The semantic patch that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match exists@
	expression x, E;
	position p1,p2;
	statement S1, S2;
	@@
	
	x@p1 = nf_conntrack_alloc(...)
	... when != x = E
	(
	  if (x@p2 == NULL || ...) S1 else S2
	|
	  if (x@p2 == NULL && ...) S1 else S2
	)
	
	@other_match exists@
	expression match.x, E1, E2;
	position p1!=match.p1,match.p2;
	@@
	
	x@p1 = E1
	... when != x = E2
	x@p2
	
	@ script:python depends on !other_match@
	p1 << match.p1;
	p2 << match.p2;
	@@
	
	print \"%s: call to nf_conntrack_alloc %s bad test %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=iserr/patch45.cocci>iserr/patch45.cocci</A>  -  simplify error handling
<pre>
	----------------------------
	
	
	nf_conntrack_alloc cannot return NULL, so there is no need to check for
	NULL before using the value.  I have also removed the initialization of ct
	to NULL in nf_conntrack_alloc, since the value is never used, and since
	perhaps it might lead one to think that return ct at the end might return
	NULL.
	
	The semantic patch that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match exists@
	expression x, E;
	position p1,p2;
	statement S1, S2;
	@@
	
	x@p1 = nf_conntrack_alloc(...)
	... when != x = E
	(
	  if (x@p2 == NULL || ...) S1 else S2
	|
	  if (x@p2 == NULL && ...) S1 else S2
	)
	
	@other_match exists@
	expression match.x, E1, E2;
	position p1!=match.p1,match.p2;
	@@
	
	x@p1 = E1
	... when != x = E2
	x@p2
	
	@ script:python depends on !other_match@
	p1 << match.p1;
	p2 << match.p2;
	@@
	
	print \"%s: call to nf_conntrack_alloc %s bad test %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=iserr/send_ct.cocci>iserr/send_ct.cocci</A>  -  simplify error handling
<pre>
	----------------------------
	
	
	nf_conntrack_alloc cannot return NULL, so there is no need to check for
	NULL before using the value.  I have also removed the initialization of ct
	to NULL in nf_conntrack_alloc, since the value is never used, and since
	perhaps it might lead one to think that return ct at the end might return
	NULL.
	
	The semantic patch that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match exists@
	expression x, E;
	position p1,p2;
	statement S1, S2;
	@@
	
	x@p1 = nf_conntrack_alloc(...)
	... when != x = E
	(
	  if (x@p2 == NULL || ...) S1 else S2
	|
	  if (x@p2 == NULL && ...) S1 else S2
	)
	
	@other_match exists@
	expression match.x, E1, E2;
	position p1!=match.p1,match.p2;
	@@
	
	x@p1 = E1
	... when != x = E2
	x@p2
	
	@ script:python depends on !other_match@
	p1 << match.p1;
	p2 << match.p2;
	@@
	
	print \"%s: call to nf_conntrack_alloc %s bad test %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=iserr_cata/category2a.cocci>iserr_cata/category2a.cocci</A>  -  correct error-handling code
<pre>
	----------------------------
	
	
	c2port_device_register returns an ERR_PTR value in an error case instead of
	NULL.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@match exists@
	expression x, E;
	statement S1, S2;
	@@
	
	x = eventfd_fget(...)
	... when != x = E
	(
	*  if (x == NULL || ...) S1 else S2
	|
	*  if (x == NULL && ...) S1 else S2
	)
	// </smpl>
	
</pre>
<A HREF=iserr_ref/iserr_mini.cocci>iserr_ref/iserr_mini.cocci</A>  -  correct an error check
<pre>
	----------------------------
	
	
	rtc is clearly does not satisfy IS_ERR at the point where it is tested, so
	I have changed the test to consider the just initialized rtc->rtc_dev.
	
	The semantic match that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match exists@
	expression x, E;
	identifier fld;
	position p1,p2;
	@@
	
	(
	x = E;
	|
	x = E
	|
	x@p1->fld
	... when != x = E
	IS_ERR(x@p2)
	... when any
	)
	
	@other_match exists@
	expression match.x, E1, E2;
	position match.p1,match.p2;
	@@
	
	x = E1
	... when != x = E2
	    when != x@p1
	x@p2
	
	@ script:python depends on !other_match@
	p1 << match.p1;
	p2 << match.p2;
	@@
	
	print \"* file %s dereference %s test %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=iserr_ref/iserr_ref.cocci>iserr_ref/iserr_ref.cocci</A>  -  correct an error check
<pre>
	----------------------------
	
	
	rtc is clearly does not satisfy IS_ERR at the point where it is tested, so
	I have changed the test to consider the just initialized rtc->rtc_dev.
	
	The semantic match that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match exists@
	expression x, E;
	identifier fld;
	position p1,p2;
	@@
	
	(
	x = E;
	|
	x = E
	|
	x@p1->fld
	... when != x = E
	IS_ERR(x@p2)
	... when any
	)
	
	@other_match exists@
	expression match.x, E1, E2;
	position match.p1,match.p2;
	@@
	
	x = E1
	... when != x = E2
	    when != x@p1
	x@p2
	
	@ script:python depends on !other_match@
	p1 << match.p1;
	p2 << match.p2;
	@@
	
	print \"* file %s dereference %s test %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=iserreq/ise2.cocci>iserreq/ise2.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=isnull_oct/isnull.cocci>isnull_oct/isnull.cocci</A>  -  eliminate a null pointer dereference
<pre>
	In the original code, probe_out could be reached when res was null and then
	when the irq had not yet been requested.  In those cases, the call to
	free_irq is not needed, so move probe_out down and introduce a new label
	for the case where calling free_irq is useful.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression E, E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	if (E == NULL)
	{
	  ... when != if (E == NULL || ...) S1 else S2
	      when != E = E1
	*E->f
	  ... when any
	  return ...;
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=isnullo/isnull.cocci>isnullo/isnull.cocci</A>  -  keep pointer to resource so it can be freed
<pre>
	Add a new variable for storing resources accessed subsequent to the one
	accessed using request_mem_region, so the one accessed using
	request_mem_region can be released if needed.
	
	The resource variable names are also changed to be more descriptive.
	
	This code is also missing some calls to iounmap.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression E, E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	if (E == NULL)
	{
	  ... when != if (E == NULL || ...) S1 else S2
	      when != E = E1
	*E->f
	  ... when any
	  return ...;
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=itnull/itnull.cocci>itnull/itnull.cocci</A>  -  Drop unnecessary null test
<pre>
	----------------------------
	
	
	list_for_each_entry binds its first argument to a non-null value, and thus
	any null test on the value of that argument is superfluous.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	iterator I;
	expression x,E,E1,E2;
	statement S,S1,S2;
	@@
	
	I(x,...) { <...
	- if (x != NULL || ...)
	  S
	  ...> }
	// </smpl>
	
</pre>
<A HREF=iwcontainer/extra_null.cocci>iwcontainer/extra_null.cocci</A>  -  Drop unnecessary NULL test
<pre>
	----------------------------
	
	
	The result of container_of should not be NULL.  In particular, in this case
	the argument to the enclosing function has passed though INIT_DELAYED_WORK,
	which dereferences it, implying that its container cannot be NULL.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression x,e;
	@@
	
	x = container_of(...)
	... when != x = e
	* x == NULL
	// </smpl>
	
</pre>
<A HREF=jiffies/jiffies.cocci>jiffies/jiffies.cocci</A>  -  Use time_before, time_before_eq, etc
<pre>
	Send to:
	acme@ghostprotocols.net, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject:
	[PATCH 19/38] drivers/net/appletalk: Use time_before, time_before_eq, etc.
	
	
	------------------------------------------------------
	
	
	The functions time_before, time_before_eq, time_after, and time_after_eq
	are more robust for comparing jiffies against other values.
	
	A simplified version of the semantic patch making this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@ change_compare_np @
	expression E;
	@@
	
	(
	- jiffies <= E
	+ time_before_eq(jiffies,E)
	|
	- jiffies >= E
	+ time_after_eq(jiffies,E)
	|
	- jiffies < E
	+ time_before(jiffies,E)
	|
	- jiffies > E
	+ time_after(jiffies,E)
	)
	
	@ include depends on change_compare_np @
	@@
	
	#include <linux/jiffies.h>
	
	@ no_include depends on !include && change_compare_np @
	@@
	
	  #include <linux/...>
	+ #include <linux/jiffies.h>
	// </smpl>
	
</pre>
<A HREF=k-zc-alloc/kzalloc.cocci>k-zc-alloc/kzalloc.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=kasp/kasp.cocci>kasp/kasp.cocci</A>  -  Eliminate kstrdup memory leak
<pre>
	The string clone is only used as a temporary copy of the argument val
	within the while loop, and so it should be freed before leaving the
	function.  The call to strsep, however, modifies clone, so a pointer to the
	front of the string is kept in saved_clone, to make it possible to free it.
	
	The sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E;
	identifier l;
	statement S;
	@@
	
	*x= \(kasprintf\|kstrdup\)(...);
	...
	if (x == NULL) S
	... when != kfree(x)
	    when != E = x
	if (...) {
	  <... when != kfree(x)
	* goto l;
	  ...>
	* return ...;
	}
	// </smpl>
	
</pre>
<A HREF=kasprintf2/aspmem.cocci>kasprintf2/aspmem.cocci</A>  -  Use kstrdup
<pre>
	Rewrite the initialization of a dev field.  In the original code, in each
	case there was a kmalloc followed by a memcpy, as illustrated by the
	semantic patch below.  In the case that the provided string was the empty
	string, the allocated memory was then overwritten with a constant string,
	causing a memory leak.  Finally, there was no provision for returning
	-ENOMEM in case of failure of the memory allocation.  Indeed, the return
	value in an error case was err, a variable that was never initialized to
	anything other than 0.
	
	The following patch rewrites the above code to first select a string based
	on various conditions, and then to copy it into a newly allocated memory
	region, using kstrdup.  This decreases subtantially the code size
	and removes the memory leak.  The instruction for getting the length of the
	string and the associated variable declaration are also deleted.
	
	The patch also drops err, changes the return value to retval, which in each
	file was already initialized elsewhere to an error code, and initializes
	retval to -ENOMEM when kstrdup fails.
	
	The semantic patch that motivated this transformation is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression a,flag,len;
	expression arg,e1,e2;
	statement S;
	@@
	
	  len = strlen(arg)
	  ... when != len = e1
	      when != arg = e2
	  a =
	-  \(kmalloc\|kzalloc\)(len+1,flag)
	+  kstrdup(arg,flag)
	  <... when != a
	  if (a == NULL || ...) S
	  ...>
	- memcpy(a,arg,len+1);
	// </smpl>
	
</pre>
<A HREF=kc/kc.cocci>kc/kc.cocci</A>  -  Use kzalloc for allocating only one thing
<pre>
	----------------------------
	
	
	Use kzalloc rather than kcalloc(1,...)
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	- kcalloc(1,
	+ kzalloc(
	          ...)
	// </smpl>
	
</pre>
<A HREF=kfree3/kmalloc.cocci>kfree3/kmalloc.cocci</A>  -  introduce missing kfree
<pre>
	----------------------------
	
	
	Error handling code following a kzalloc should free the allocated data.
	
	The semantic match that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S;
	expression E;
	identifier f,f1,l;
	position p1,p2;
	expression *ptr != NULL;
	@@
	
	x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...);
	...
	if (x == NULL) S
	<... when != x
	     when != if (...) { <+...x...+> }
	(
	x->f1 = E
	|
	 (x->f1 == NULL || ...)
	|
	 f(...,x->f1,...)
	)
	...>
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	 return@p2 ...;
	)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	print \"* file: %s kmalloc %s return %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=kfree3/kmalloc8a.cocci>kfree3/kmalloc8a.cocci</A>  -  introduce missing kfree
<pre>
	----------------------------
	
	
	Error handling code following a kzalloc should free the allocated data.
	
	The semantic match that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S;
	expression E;
	identifier f,f1,l;
	position p1,p2;
	expression *ptr != NULL;
	@@
	
	x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...);
	...
	if (x == NULL) S
	<... when != x
	     when != if (...) { <+...x...+> }
	(
	x->f1 = E
	|
	 (x->f1 == NULL || ...)
	|
	 f(...,x->f1,...)
	)
	...>
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	 return@p2 ...;
	)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	print \"* file: %s kmalloc %s return %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=kfree_after/kfree_after.cocci>kfree_after/kfree_after.cocci</A>  -  adjust error handling code
<pre>
	Use the error handling code at the end of the function, rather than
	returning directly.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier x;
	@@
	
	kfree(x)
	
	@@
	identifier r.x;
	expression E1!=0,E2,E3,E4;
	statement S;
	@@
	
	(
	if (<+...x...+>) S
	|
	if (...) { ... when != kfree(x)
	               when != if (...) { ... kfree(x); ... }
	               when != x = E3
	* return E1;
	}
	... when != x = E2
	if (...) { ... when != x = E4
	 kfree(x); ... return ...; }
	)
	// </smpl>
	
</pre>
<A HREF=kfree_after2/kfree_after.cocci>kfree_after2/kfree_after.cocci</A>  -  remove unneeded kfree
<pre>
	The label outnodev is only used when kzalloc has not yet taken place or has
	failed, so there is no need for the call for kfree under this label.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	identifier x;
	expression E1!=0,E2,E3,E4;
	statement S;
	iterator I;
	@@
	
	(
	if (...) { ... when != kfree(x)
	               when != x = E3
	               when != E3 = x
	*  return ...;
	 }
	... when != x = E2
	    when != I(...,x,...) S
	if (...) { ... when != x = E4
	 kfree(x); ... return ...; }
	)
	// </smpl>
	
</pre>
<A HREF=kfree_skb/skbfree.cocci>kfree_skb/skbfree.cocci</A>  -  Convert kfree/kfree_skb to dev_kfree_skb_irq
<pre>
	Send to:
	marcel@holtmann.org, maxk@qualcomm.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/bluetooth: Convert kfree/kfree_skb to dev_kfree_skb_irq
	revision of send_skb
	
	------------------------------------------------------
	
	
	When values of type struct sk_buff * are freed from within an interrupt
	handler, dev_kfree_skb_irq should be used rather than kfree or kfree_skb.
	
	In most of the cases below, the function containing the free ends up as a
	URB completion callback.  Such callbacks are called from an interrupt
	handler.  In drivers/bluetooth/btsdio.c, the enclosing function is
	ultimately referenced from the second argument of sdio_claim_irq, which is
	also used as an interrupt handler.
	
	All of these cases except the last were fixed using the following semantic
	patch (http://www.emn.fr/x-info/coccinelle/).
	
	// <smpl>
	@rule1@
	identifier f;
	@@
	
	f(...) {
	<+...
	   kfree_skb(...)
	...+>
	}
	
	@ call @
	identifier rule1.f;
	@@
	
	(
	usb_fill_bulk_urb(...,f,...)
	|
	usb_fill_control_urb(...,f,...)
	|
	usb_fill_int_urb(...,f,...)
	)
	
	@ toplevel @
	identifier rule1.f;
	struct urb u;
	@@
	
	u.complete = f;
	
	@ depends on call || toplevel @
	identifier rule1.f;
	expression E;
	@@
	
	f(...) {
	<...
	-  kfree_skb(E)
	+  dev_kfree_skb_irq(E)
	...>
	}
	// </smpl>
	
</pre>
<A HREF=kfrees/kfree.cocci>kfrees/kfree.cocci</A>  -  introduce missing kfree
<pre>
	----------------------------
	
	
	The semantic match that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	@r exists@
	expression E,E1;
	statement S;
	position p1,p2,p3;
	@@
	
	E =@p1 \(kmalloc\|kcalloc\|kzalloc\)(...)
	... when != E = E1
	if (E == NULL || ...) S
	... when != E = E1
	if@p2 (...) {
	 ... when != kfree(E)
	 }
	... when != E = E1
	kfree@p3(E);
	
	@forall@
	position r.p2;
	expression r.E;
	int E1 != 0;
	@@
	
	* if@p2 (...) {
	 ... when != kfree(E)
	     when strict
	return E1; }
	
	
</pre>
<A HREF=kmalloc9/kmalloc9.cocci>kmalloc9/kmalloc9.cocci</A>  -  add missing kfree
<pre>
	At this point, ehv_pic has been allocated but not stored anywhere, so it
	should be freed before leaving the function.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression x;
	statement S,S1;
	expression E;
	identifier fl;
	expression *ptr != NULL;
	@@
	
	x = \(kmalloc\|kzalloc\|kcalloc\)(...);
	...
	if (x == NULL) S
	<... when != x
	     when != if (...) { <+...kfree(x)...+> }
	     when any
	     when != true x == NULL
	x->fl
	...>
	(
	if (x == NULL) S1
	|
	if (...) { ... when != x
	               when forall
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	* return ...;
	)
	}
	)
	// </smpl>
	
</pre>
<A HREF=kmc1/kmc1.cocci>kmc1/kmc1.cocci</A>  -  free kmem_cache_zalloc'd data using kmem_cache_free
<pre>
	Memory allocated using kmem_cache_zalloc should be freed using
	kmem_cache_free, not kfree.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e,e1,e2;
	@@
	
	x = kmem_cache_zalloc(e1,e2)
	... when != x = e
	?-kfree(x)
	+kmem_cache_free(e1,x)
	// </smpl>
	
</pre>
<A HREF=kmc1a/kmc1.cocci>kmc1a/kmc1.cocci</A>  -  eliminate NULL pointer dereference
<pre>
	In this code, blkvsc_req is allocated in the cache blkdev->request_pool,
	but freed in the first case to the cache blkvsc_req->dev->request_pool.
	blkvsc_req->dev is subsequently initialized to blkdev, making these the
	same at the second call to kmem_cache_free.  But at the point of the first
	call, blkvsc_req->dev is NULL.  The second call is changed too, for
	uniformity.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e,e1,e2,e3;
	@@
	
	x = \(kmem_cache_alloc\|kmem_cache_zalloc\)(e1,e2)
	... when != x = e
	(
	kmem_cache_free(e1,x);
	|
	?-kmem_cache_free(e3,x);
	+kmem_cache_free(e1,x);
	)
	// </smpl>
	
</pre>
<A HREF=kmtest/kmtest.cocci>kmtest/kmtest.cocci</A>  -  Add kmalloc NULL tests
<pre>
	----------------------------
	
	
	Check that the result of kmalloc/kzalloc is not NULL before dereferencing it.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *x;
	identifier f;
	constant char *C;
	@@
	
	x = \(kmalloc\|kcalloc\|kzalloc\)(...);
	... when != x == NULL
	    when != x != NULL
	    when != (x || ...)
	(
	kfree(x)
	|
	f(...,C,...,x,...)
	|
	*f(...,x,...)
	|
	*x->f
	)
	// </smpl>
	
</pre>
<A HREF=kstr/kstr.cocci>kstr/kstr.cocci</A>  -  use kstrtoul, etc
<pre>
	Use kstrtoul, etc instead of the now deprecated strict_strtoul, etc.
	
	A semantic patch rule for the kstrtoul case is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression a,b;
	{int,long} *c;
	@@
	
	-strict_strtoul
	+kstrtoul
	 (a,b,c)
	// </smpl>
	
</pre>
<A HREF=kstrdup/kstrdup.cocci>kstrdup/kstrdup.cocci</A>  -  Use kstrdup
<pre>
	----------------------------
	
	
	Use kstrdup when the goal of an allocation is copy a string into the
	allocated region.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression from,to;
	expression flag,E1,E2;
	statement S;
	@@
	
	-  to = kmalloc(strlen(from) + 1,flag);
	+  to = kstrdup(from, flag);
	   ... when != \(from = E1 \| to = E1 \)
	   if (to==NULL || ...) S
	   ... when != \(from = E2 \| to = E2 \)
	-  strcpy(to, from);
	// </smpl>
	
</pre>
<A HREF=lcd/category2b_back_device_reg.cocci>lcd/category2b_back_device_reg.cocci</A>  -  Bad error test before a dereference
<pre>
	----------------------------
	
	
	The error test that follows the call to backlight_device_register
	seems not to concern the right variable.
	
	A simplified version of the semantic match that finds this problem is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	// <smpl>
	@def0@
	expression x;
	position p0;
	@@
	x@p0 = backlight_device_register(...)
	
	@protected@
	expression def0.x,E;
	position def0.p0;
	position p;
	statement S;
	@@
	x@p0
	... when != x = E
	if (!IS_ERR(x) && ...) {<... x@p ...>} else S
	
	@unprotected@
	expression def0.x;
	identifier fld;
	position def0.p0;
	position p != protected.p;
	@@
	x@p0
	... when != x = E
	* x@p->fld
	// </smpl>
	
</pre>
<A HREF=lenull/lenull.cocci>lenull/lenull.cocci</A>  -  Drop NULL test on list_entry result
<pre>
	----------------------------
	
	
	list_entry, which is an alias for container_of, cannot return NULL, as
	there is no way to add a NULL value to a doubly linked list.
	
	A simplified version of the semantic match that findds this problem is as
	follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S1,S2;
	position p,p1;
	@@
	
	*x = list_entry@p(...)
	... when != x = E
	*if@p1 (x == NULL) S1 else S2
	// </smpl>
	
</pre>
<A HREF=leq/leq.cocci>leq/leq.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=lfee/lfee.cocci>lfee/lfee.cocci</A>  -  remove invalid reference to list iterator variable
<pre>
	If list_for_each_entry, etc complete a traversal of the list, the iterator
	variable ends up pointing to an address at an offset from the list head,
	and not a meaningful structure.  Thus this value should not be used after
	the end of the iterator.  Replace c->dev by dev, which is the value that
	c->dev has been compared to.
	
	This problem was found using Coccinelle (http://coccinelle.lip6.fr/).
	
</pre>
<A HREF=list_entry/rcu2.cocci>list_entry/rcu2.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=list_entry_update/list_entry_update.cocci>list_entry_update/list_entry_update.cocci</A>  -  Eliminate update of list_for_each_entry loop cursor
<pre>
	----------------------------
	
	
	list_for_each_entry uses its first argument to move from one element to the
	next, so modifying it can break the iteration.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	iterator name list_for_each_entry;
	expression x,E;
	position p1,p2;
	@@
	
	list_for_each_entry@p1(x,...) { <... x =@p2 E ...> }
	
	@@
	expression x,E;
	position r.p1,r.p2;
	statement S;
	@@
	
	*x =@p2 E
	...
	list_for_each_entry@p1(x,...) S
	// </smpl>
	
</pre>
<A HREF=listfree/listfree.cocci>listfree/listfree.cocci</A>  -  Avoid leaving freed data in a list
<pre>
	b may be added to a list, but is not removed before being freed in the case
	of an error.  This is done in the corresponding deallocation function, so
	the code here has been changed to follow that.
	
	The sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E,E1,E2;
	identifier l;
	@@
	
	*list_add(&E->l,E1);
	... when != E1
	    when != list_del(&E->l)
	    when != list_del_init(&E->l)
	    when != E = E2
	*kfree(E);// </smpl>
	
</pre>
<A HREF=local/local.cocci>local/local.cocci</A>  -  Add local_irq_restore in error handling code
<pre>
	----------------------------
	
	
	The gotos to the labels fail_free_irq and fail_unregister only occur
	between local_irq_save and local_irq_restore, so it would seem that this
	code should also call local_irq_restore.
	
	The semantic match that detects this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@rl@
	expression l;
	position p;
	expression E,E1,E2;
	@@
	
	local_irq_save(l);
	<... when != local_irq_restore(l)
	     when != spin_unlock_irqrestore(E,l)
	if (...) { ... when != local_irq_restore(l)
	               when != spin_unlock_irqrestore(E1,l)
	*    return@p ...;
	}
	...>
	(
	spin_unlock_irqrestore(E2,l);
	|
	local_irq_restore(l);
	)
	</smpl>
	
</pre>
<A HREF=lock/o_lock_inconsistent.cocci>lock/o_lock_inconsistent.cocci</A>  -  Unlock the lock that was locked
<pre>
	----------------------------
	
	
	The lock taken was in the ct_ev_lock field, not the hbalock field.
	
	A simplified version of the semantic patch that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression E1;
	identifier f;
	@@
	
	f (...) { <+...
	* spin_lock_irqsave (E1,...);
	... when != E1
	* return ...;
	...+> }
	// </smpl>
	
</pre>
<A HREF=lock_flags/flags.cocci>lock_flags/flags.cocci</A>  -  convert nested spin_lock_irqsave to spin_lock
<pre>
	----------------------------
	
	
	If spin_lock_irqsave is called twice in a row with the same second
	argument, the interrupt state at the point of the second call overwrites
	the value saved by the first call.  Indeed, the second call does not need
	to save the interrupt state, so it is changed to a simple spin_lock.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression lock1,lock2;
	expression flags;
	@@
	
	*spin_lock_irqsave(lock1,flags)
	... when != flags
	*spin_lock_irqsave(lock2,flags)
	// </smpl>
	
</pre>
<A HREF=lock_flags/flags1.cocci>lock_flags/flags1.cocci</A>  -  convert nested spin_lock_irqsave to spin_lock
<pre>
	----------------------------
	
	
	If spin_lock_irqsave is called twice in a row with the same second
	argument, the interrupt state at the point of the second call overwrites
	the value saved by the first call.  Indeed, the second call does not need
	to save the interrupt state, so it is changed to a simple spin_lock.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression lock1,lock2;
	expression flags;
	@@
	
	*spin_lock_irqsave(lock1,flags)
	... when != flags
	*spin_lock_irqsave(lock2,flags)
	// </smpl>
	
</pre>
<A HREF=map_destroy/map_destroy.cocci>map_destroy/map_destroy.cocci</A>  -  avoid calling map_destroy on NULL
<pre>
	map_destroy dereferences its argument.  The call is furthermore only
	reachable when this argument is NULL.  Thus the call is dropped.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *x;
	@@
	
	*if (x == NULL)
	{ ...
	* map_destroy(x);
	  ...
	  return ...;
	}
	// </smpl>
	
</pre>
<A HREF=markbusy/usb_mark_last_busy.cocci>markbusy/usb_mark_last_busy.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=mdiobus_unregister/mdiobus_unregister.cocci>mdiobus_unregister/mdiobus_unregister.cocci</A>  -  Call mdiobus_unregister before mdiobus_free
<pre>
	Based on commit b27393aecf66199f5ddad37c302d3e0cfadbe6c0
	
	Calling mdiobus_free without calling mdiobus_unregister causes
	BUG_ON(). This patch fixes the issue.
	
	The semantic patch that found this issue(http://coccinelle.lip6.fr/):
	// <smpl>
	@@
	expression E;
	@@
	  ... when != mdiobus_unregister(E);
	
	+ mdiobus_unregister(E);
	  mdiobus_free(E);
	// </smpl>
	
</pre>
<A HREF=mem2/mem2.cocci>mem2/mem2.cocci</A>  -  drop redundant memset
<pre>
	----------------------------
	
	
	The region set by the call to memset is immediately overwritten by the
	subsequent call to memcpy.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e1,e2,e3,e4;
	@@
	
	- memset(e1,e2,e3);
	  memcpy(e1,e4,e3);
	// </smpl>
	
</pre>
<A HREF=memdup/memdup.cocci>memdup/memdup.cocci</A>  -  Use kmemdup
<pre>
	----------------------------
	
	
	Use kmemdup when some other buffer is immediately copied into the
	allocated region.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression from,to,size,flag;
	statement S;
	@@
	
	-  to = \(kmalloc\|kzalloc\)(size,flag);
	+  to = kmemdup(from,size,flag);
	   if (to==NULL || ...) S
	-  memcpy(to, from, size);
	// </smpl>
	
</pre>
<A HREF=memdup_user/memdup_user.cocci>memdup_user/memdup_user.cocci</A>  -  Use memdup_user
<pre>
	----------------------------
	
	
	Use memdup_user when user data is immediately copied into the
	allocated region.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression from,to,size,flag;
	position p;
	identifier l1,l2;
	@@
	
	-  to = \(kmalloc@p\|kzalloc@p\)(size,flag);
	+  to = memdup_user(from,size);
	   if (
	-      to==NULL
	+      IS_ERR(to)
	                 || ...) {
	   <+... when != goto l1;
	-  -ENOMEM
	+  PTR_ERR(to)
	   ...+>
	   }
	-  if (copy_from_user(to, from, size) != 0) {
	-    <+... when != goto l2;
	-    -EFAULT
	-    ...+>
	-  }
	// </smpl>
	
</pre>
<A HREF=memuser/memuser.cocci>memuser/memuser.cocci</A>  -  add missing kfree
<pre>
	The label fail frees dev->buf, but kbuf hasn't yet been stored there at
	this point.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression x;
	statement S;
	expression E;
	expression *ptr != NULL;
	@@
	
	x = memdup_user(...);
	...
	if (IS_ERR(x)) S
	... when != x
	    when != x = E
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	*return ...;
	)
	// </smpl>
	
</pre>
<A HREF=mesh/mesh.cocci>mesh/mesh.cocci</A>  -  correct the argument to __mesh_table_free
<pre>
	----------------------------
	
	
	In the function mesh_table_grow, it is the new table not the argument table
	that should be freed if the function fails (cf commit
	bd9b448f4c0a514559bdae4ca18ca3e8cd999c6d)
	
	The semantic match that detects this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E,f;
	position p1,p2,p3;
	identifier l;
	statement S;
	@@
	
	x = mesh_table_alloc@p1(...)
	...
	if (x == NULL) S
	... when != E = x
	    when != mesh_table_free(x)
	goto@p2 l;
	... when != E = x
	    when != f(...,x,...)
	    when any
	(
	return \(0\|x\);
	|
	return@p3 ...;
	)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	p3 << r.p3;
	@@
	
	print \"%s: call on line %s not freed or saved before return on line %s via line %s\" % (p1[0].file,p1[0].line,p3[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=mini_lock/mini_lock.cocci>mini_lock/mini_lock.cocci</A>  -  Add missing spin_unlock
<pre>
	----------------------------
	
	
	Add a spin_unlock missing on the error path.  The spin lock is used in a
	balanced way elsewhere in the file.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E1;
	@@
	
	* spin_lock(E1,...);
	  <+... when != E1
	  if (...) {
	    ... when != E1
	*   return ...;
	  }
	  ...+>
	* spin_unlock(E1,...);
	// </smpl>
	
</pre>
<A HREF=mini_null/mini_null_ref.cocci>mini_null/mini_null_ref.cocci</A>  -  Move a dereference below a NULL test
<pre>
	----------------------------
	
	
	In each case, if the NULL test is necessary, then the dereference should be
	moved below the NULL test.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	expression E;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E
	      when != i
	  if (E == NULL) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=mini_null3/mini_null_ref3.cocci>mini_null3/mini_null_ref3.cocci</A>  -  Move a dereference below a NULL test
<pre>
	----------------------------
	
	
	If the NULL test is necessary, then the dereference should be moved below
	the NULL test.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/).
	
	// <smpl>
	@disable is_null@
	identifier f;
	expression E;
	identifier fld;
	statement S;
	@@
	
	+ if (E == NULL) S
	  f(...,E->fld,...);
	- if (E == NULL) S
	
	@@
	identifier f;
	expression E;
	identifier fld;
	statement S;
	@@
	
	+ if (!E) S
	  f(...,E->fld,...);
	- if (!E) S
	// </smpl>
	
</pre>
<A HREF=mini_null_check/mini_null_check.cocci>mini_null_check/mini_null_check.cocci</A>  -  Drop an unneeded a NULL test
<pre>
	----------------------------
	
	
	In each case, the NULL test is not necessary because the function is static
	and at the only places where it is called, the us argument has already been
	dereferenced.
	
	The semantic patch that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	expression E,E1;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E=E1
	      when != i
	  if (E == NULL||...) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=mini_null_check/second_mini_null_check.cocci>mini_null_check/second_mini_null_check.cocci</A>  -  Drop an unneeded a NULL test
<pre>
	----------------------------
	
	
	In each case, the NULL test is not necessary because the function is static
	and at the only places where it is called, the us argument has already been
	dereferenced.
	
	The semantic patch that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	expression E,E1;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E=E1
	      when != i
	  if (E == NULL||...) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=mini_null_ref_aug10/mini_null_ref.cocci>mini_null_ref_aug10/mini_null_ref.cocci</A>  -  Remove potential NULL dereference
<pre>
	If the NULL test is necessary, the initialization involving a dereference of
	the tested value should be moved after the NULL test.
	
	The sematic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	expression E;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E
	      when != i
	  if (E == NULL) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=mini_null_ref_aug14/mini_null_ref.cocci>mini_null_ref_aug14/mini_null_ref.cocci</A>  -  Remove potential NULL dereferences
<pre>
	If the NULL test is necessary, the initialization involving a dereference of
	the tested value should be moved after the NULL test.
	
	The sematic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	expression E;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E
	      when != i
	  if (E == NULL) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=misc_undo/send_m1.cocci>misc_undo/send_m1.cocci</A>  -  Add missing snd_card_free
<pre>
	----------------------------
	
	
	The function snd_mixart_create creates a link between mgr and card that
	allows snd_mixart_free to free card as well.  But if snd_mixart_create
	fails, then the link has not been created and card has to be freed explicitly.
	
	
	The semantic match that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S,S1;
	position p1,p2,p3;
	expression E,E1;
	type T,T1;
	expression *ptr != NULL;
	@@
	
	(
	 if ((x@p1 = snd_card_new(...)) == NULL) S
	|
	 x@p1 = snd_card_new(...);
	)
	 ... when != snd_card_free(...,(T)x,...)
	     when != if (...) { <+... snd_card_free(...,(T)x,...) ...+> }
	     when != true x == NULL || ...
	     when != x = E
	     when != E = (T)x
	     when any
	(
	 if (x == NULL || ...) S1
	|
	 if@p2 (...) {
	  ... when != snd_card_free(...,(T1)x,...)
	      when != if (...) { <+... snd_card_free(...,(T1)x,...) ...+> }
	      when != x = E1
	      when != E1 = (T1)x
	(
	  return \(0\|<+...x...+>\|ptr\);
	|
	  return@p3 ...;
	)
	}
	)
	
	@ script:python @
	p1 << r.p1;
	p3 << r.p3;
	@@
	
	print \"* file: %s snd_card_new: %s return: %s\" % (p1[0].file,p1[0].line,p3[0].line)
	
	// </smpl>
	
</pre>
<A HREF=misc_undo/send_m2.cocci>misc_undo/send_m2.cocci</A>  -  Add missing snd_card_free
<pre>
	----------------------------
	
	
	The function snd_mixart_create creates a link between mgr and card that
	allows snd_mixart_free to free card as well.  But if snd_mixart_create
	fails, then the link has not been created and card has to be freed explicitly.
	
	
	The semantic match that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S,S1;
	position p1,p2,p3;
	expression E,E1;
	type T,T1;
	expression *ptr != NULL;
	@@
	
	(
	 if ((x@p1 = snd_card_new(...)) == NULL) S
	|
	 x@p1 = snd_card_new(...);
	)
	 ... when != snd_card_free(...,(T)x,...)
	     when != if (...) { <+... snd_card_free(...,(T)x,...) ...+> }
	     when != true x == NULL || ...
	     when != x = E
	     when != E = (T)x
	     when any
	(
	 if (x == NULL || ...) S1
	|
	 if@p2 (...) {
	  ... when != snd_card_free(...,(T1)x,...)
	      when != if (...) { <+... snd_card_free(...,(T1)x,...) ...+> }
	      when != x = E1
	      when != E1 = (T1)x
	(
	  return \(0\|<+...x...+>\|ptr\);
	|
	  return@p3 ...;
	)
	}
	)
	
	@ script:python @
	p1 << r.p1;
	p3 << r.p3;
	@@
	
	print \"* file: %s snd_card_new: %s return: %s\" % (p1[0].file,p1[0].line,p3[0].line)
	
	// </smpl>
	
</pre>
<A HREF=missing_put/missing_put.cocci>missing_put/missing_put.cocci</A>  -  Add missing of_node_put
<pre>
	Send to:
	benh@kernel.crashing.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/3] arch/powerpc: Add missing of_node_put
	
	------------------------------------------------------
	
	
	There should be an of_node_put when breaking out of a loop that iterates
	using for_each_node_by_type.
	
	This was detected and fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	identifier d;
	type T;
	expression e;
	iterator for_each_node_by_type;
	@@
	
	T *d;
	...
	for_each_node_by_type(d,...)
	  {... when != of_node_put(d)
	       when != e = d
	(
	   return d;
	|
	+  of_node_put(d);
	?  return ...;
	)
	...}
	// </smpl>
	
</pre>
<A HREF=moduleparam/rule5.cocci>moduleparam/rule5.cocci</A>  -  Drop redundant includes of moduleparam.h
<pre>
	Send to:
	dan@dennedy.org, stefanr@s5r6.in-berlin.de, linux1394-devel@lists.sourceforge.net, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 2/4] drivers/ieee1394: Drop redundant includes of moduleparam.h
	
	
	------------------------------------------------------
	
	
	Drop #include <linux/moduleparam.h> in files that also include #include
	<linux/module.h>.  module.h includes moduleparam.h already.
	
	The semantic patch implementing this change is as follows:
	
	@ includesmodule @
	@@
	
	#include <linux/module.h>
	
	@ depends on includesmodule @
	@@
	
	- #include <linux/moduleparam.h>
	
</pre>
<A HREF=more_of_noput/patch.cocci>more_of_noput/patch.cocci</A>  -  Add missing of_node_put
<pre>
	arch/powerpc/platforms/82xx/mpc8272_ads.c
	arch/powerpc/platforms/82xx/pq2fads.c
	
	Send to:
	vbordug@ru.mvista.com, marcelo@kvack.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 3/3] arch/powerpc/platforms/82xx: Add missing of_node_put
	
	------------------------------------------------------
	
	
	Of_get_parent and of_find_compatible_node do a of_node_get, and thus a
	corresponding of_code_put is needed in both the error case and the normal
	return case.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2,x3;
	int ret;
	@@
	
	  T E;
	  ...
	* E = \(of_get_parent\|of_find_compatible_node\)(...);
	  if (E == NULL) S
	  ... when != of_node_put(...,(T1)E,...)
	      when != if (E != NULL) { ... of_node_put(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	  if (...) {
	    ... when != of_node_put(...,(T2)E,...)
	        when != if (E != NULL) { ... of_node_put(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=more_pci/get_slot.cocci>more_pci/get_slot.cocci</A>  -  Add missing pci_dev_get
<pre>
	drivers/macintosh/via-pmu.c
	
	Send to:
	benh@kernel.crashing.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/macintosh: Add missing pci_dev_get
	
	------------------------------------------------------
	
	
	pci_get_bus_and_slot does a pci_dev_get, so pci_dev_put needs to be called
	in an error case.
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@exists@
	type T1,T2;
	identifier E;
	statement S,S1;
	expression x1,x2,x3;
	expression test;
	int ret != 0;
	@@
	
	  struct pci_dev *E;
	  ...
	(
	  E = \(pci_get_slot\|pci_get_device\|pci_get_bus_and_slot\)(...);
	  if (E == NULL) S
	|
	  if ((E = \(pci_get_slot\|pci_get_device\|pci_get_bus_and_slot\)(...)) == NULL) S
	)
	  ... when != pci_dev_put(...,(T1)E,...)
	      when != if (E != NULL) { ... pci_dev_put(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	(
	  if (E == NULL) S1
	|
	  if (test)
	+   {
	(
	+   pci_dev_put(E);
	    return;
	|
	+   pci_dev_put(E);
	    return ret;
	)
	+   }
	|
	  if (test) {
	    ... when != pci_dev_put(...,(T2)E,...)
	        when != if (E != NULL) { ... pci_dev_put(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	+   pci_dev_put(E);
	    return;
	|
	+   pci_dev_put(E);
	    return ret;
	)
	  }
	)
	// </smpl>
	
</pre>
<A HREF=more_pci/more_pci.cocci>more_pci/more_pci.cocci</A>  -  Add missing pci_dev_get
<pre>
	drivers/macintosh/via-pmu.c
	
	Send to:
	benh@kernel.crashing.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/macintosh: Add missing pci_dev_get
	
	------------------------------------------------------
	
	
	pci_get_bus_and_slot does a pci_dev_get, so pci_dev_put needs to be called
	in an error case.
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@exists@
	type T1,T2;
	identifier E;
	statement S,S1;
	expression x1,x2,x3;
	expression test;
	int ret != 0;
	@@
	
	  struct pci_dev *E;
	  ...
	(
	  E = \(pci_get_slot\|pci_get_device\|pci_get_bus_and_slot\)(...);
	  if (E == NULL) S
	|
	  if ((E = \(pci_get_slot\|pci_get_device\|pci_get_bus_and_slot\)(...)) == NULL) S
	)
	  ... when != pci_dev_put(...,(T1)E,...)
	      when != if (E != NULL) { ... pci_dev_put(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	(
	  if (E == NULL) S1
	|
	  if (test)
	+   {
	(
	+   pci_dev_put(E);
	    return;
	|
	+   pci_dev_put(E);
	    return ret;
	)
	+   }
	|
	  if (test) {
	    ... when != pci_dev_put(...,(T2)E,...)
	        when != if (E != NULL) { ... pci_dev_put(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	+   pci_dev_put(E);
	    return;
	|
	+   pci_dev_put(E);
	    return ret;
	)
	  }
	)
	// </smpl>
	
</pre>
<A HREF=mutex/mut.cocci>mutex/mut.cocci</A>  -  Release mutex in error handling code
<pre>
	----------------------------
	
	
	The mutex is released on a successful return, so it would seem that it
	should be released on an error return as well.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression l;
	@@
	
	mutex_lock(l);
	... when != mutex_unlock(l)
	    when any
	    when strict
	(
	if (...) { ... when != mutex_unlock(l)
	+   mutex_unlock(l);
	    return ...;
	}
	|
	mutex_unlock(l);
	)
	// </smpl>
	
</pre>
<A HREF=mutex2/mutex2.cocci>mutex2/mutex2.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=noderef/noderef.cocci>noderef/noderef.cocci</A>  -  correct size computation
<pre>
	----------------------------
	
	
	The size argument to kcalloc should be the size of desired structure,
	not the pointer to it.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@expression@
	expression *x;
	@@
	
	x =
	 <+...
	-sizeof(x)
	+sizeof(*x)
	...+>// </smpl>
	
</pre>
<A HREF=noderef2/noderef2.cocci>noderef2/noderef2.cocci</A>  -  Correct size given to memset
<pre>
	----------------------------
	
	
	Memset should be given the size of the structure, not the size of the pointer.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	T *x;
	expression E;
	@@
	
	memset(x, E, sizeof(
	+ *
	 x))
	// </smpl>
	
</pre>
<A HREF=notnull/notnull.cocci>notnull/notnull.cocci</A>  -  Remove redundant test
<pre>
	----------------------------
	
	
	vpage is checked not to be NULL just after it is initialized at the
	beginning of each loop iteration.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E;
	position p1,p2;
	@@
	
	if (x@p1 == NULL || ...) { ... when forall
	   return ...; }
	... when != \(x=E\|x--\|x++\|--x\|++x\|x-=E\|x+=E\|x|=E\|x&=E\|&x\)
	(
	x@p2 == NULL
	|
	x@p2 != NULL
	)
	
	// another path to the test that is not through p1?
	@s exists@
	local idexpression r.x;
	position r.p1,r.p2;
	@@
	
	... when != x@p1
	(
	x@p2 == NULL
	|
	x@p2 != NULL
	)
	
	@fix depends on !s@
	position r.p1,r.p2;
	expression x,E;
	statement S1,S2;
	@@
	
	(
	- if ((x@p2 != NULL) || ...)
	  S1
	|
	- if ((x@p2 == NULL) && ...) S1
	|
	- BUG_ON(x@p2 == NULL);
	)
	// </smpl>
	
</pre>
<A HREF=notnull/notnull2.cocci>notnull/notnull2.cocci</A>  -  Remove redundant test
<pre>
	----------------------------
	
	
	vpage is checked not to be NULL just after it is initialized at the
	beginning of each loop iteration.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E;
	position p1,p2;
	@@
	
	if (x@p1 == NULL || ...) { ... when forall
	   return ...; }
	... when != \(x=E\|x--\|x++\|--x\|++x\|x-=E\|x+=E\|x|=E\|x&=E\|&x\)
	(
	x@p2 == NULL
	|
	x@p2 != NULL
	)
	
	// another path to the test that is not through p1?
	@s exists@
	local idexpression r.x;
	position r.p1,r.p2;
	@@
	
	... when != x@p1
	(
	x@p2 == NULL
	|
	x@p2 != NULL
	)
	
	@fix depends on !s@
	position r.p1,r.p2;
	expression x,E;
	statement S1,S2;
	@@
	
	(
	- if ((x@p2 != NULL) || ...)
	  S1
	|
	- if ((x@p2 == NULL) && ...) S1
	|
	- BUG_ON(x@p2 == NULL);
	)
	// </smpl>
	
</pre>
<A HREF=null_ref/null_ref.cocci>null_ref/null_ref.cocci</A>  -  Move dereference after NULL test
<pre>
	----------------------------
	
	
	If the NULL test on h is needed in snd_harmony_mixer_init, then the
	dereference should be after the NULL test.
	
	Actually, there is a sequence of calls: snd_harmony_create, then
	snd_harmony_pcm_init, and then snd_harmony_mixer_init.  snd_harmony_create
	initializes h, but may indeed leave it as NULL.  There was no NULL test at
	the beginning of snd_harmony_pcm_init, so I have added one.  The NULL test
	in snd_harmony_mixer_init is then not necessary, but in case the ordering
	of the calls changes, I have left it, and moved the dereference after it.
	
	A simplified version of the semantic match that detects this problem is as
	follows (http://coccinelle.lip6.fr/):
	
	// <smpl>
	@match exists@
	expression x, E;
	identifier fld;
	@@
	
	* x->fld
	  ... when != \(x = E\|&x\)
	* x == NULL
	// </smpl>
	
</pre>
<A HREF=null_ref2/mini_null_ref2.cocci>null_ref2/mini_null_ref2.cocci</A>  -  Adjust NULL test
<pre>
	----------------------------
	
	
	Since card must already be non-NULL, it seems that what was intended
	was to test the result of kmalloc.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E,E1;
	identifier f,fld,fld1;
	statement S1,S2;
	@@
	
	E->fld = f(...);
	... when != E = E1
	    when != E->fld1 = E1
	if (
	-   E
	+   E->fld
	           == NULL) S1 else S2
	// </smpl>
	
</pre>
<A HREF=oddpe/oddpe.cocci>oddpe/oddpe.cocci</A>  -  adjust inconsistent IS_ERR and PTR_ERR
<pre>
	Change the call to PTR_ERR to access the value just tested by IS_ERR.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1;
	@@
	
	(
	if (IS_ERR(e)) { ... PTR_ERR(e) ... }
	|
	if (IS_ERR(e=e1)) { ... PTR_ERR(e) ... }
	|
	*if (IS_ERR(e))
	 { ...
	*  PTR_ERR(e1)
	   ... }
	)
	// </smpl>
	
</pre>
<A HREF=of_noput/of_noput.cocci>of_noput/of_noput.cocci</A>  -  Add missing of_node_put
<pre>
	Send to:
	olof@lixom.net, paulus@samba.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] arch/powerpc: Add missing of_node_put
	
	
	------------------------------------------------------
	
	
	There should be an of_node_put when breaking out of a loop that iterates
	over calls to of_find_all_nodes, as this function does an of_node_get on
	the value it returns.
	
	This was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	identifier d;
	expression e;
	@@
	
	T *d;
	...
	for (d = NULL; (d = of_find_all_nodes(d)) != NULL; )
	 {... when != of_node_put(d)
	      when != e = d
	(
	   return d;
	|
	+  of_node_put(d);
	?  return ...;
	)
	...}
	// </smpl>
	
</pre>
<A HREF=offset/offset.cocci>offset/offset.cocci</A>  -  drivers/s390: Use offsetof
<pre>
	Send to:
	schwidefsky@de.ibm.com, heiko.carstens@de.ibm.com, viro@ftp.linux.org.uk, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject:
	[PATCH 2/3] drivers/s390: Use offsetof
	
	
	------------------------------------------------------
	
	In the patch cc154ac64aa8d3396b187f64cef01ce67f433324, Al Viro observed
	that the proper way to compute the distance between two structure fields is
	to use offsetof() or a cast to a pointer to character.  The same change can
	be applied to a few more files.
	
	The change was made using the following semantic patch
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r3 disable ptr_to_array@
	type T;
	T *s;
	type T1, T2;
	identifier fld1;
	@@
	
	(
	  (char *)&s->fld1 - (char *)s
	|
	  (uint8_t *)&s->fld1 - (uint8_t *)s
	|
	  (u8 *)&s->fld1 - (u8 *)s
	|
	- (T1)&s->fld1 - (T2)s
	+ offsetof(T,fld1)
	)
	
	@@
	type T;
	expression E;
	@@
	
	- (int)(offsetof(T,E))
	+ offsetof(T,E)
	// </smpl>
	
</pre>
<A HREF=ofiomap/of_iomap-iounmap.cocci>ofiomap/of_iomap-iounmap.cocci</A>  -  Add missing iounmap
<pre>
	drivers/pcmcia/m8xx_pcmcia.c
	
	Send to:
	linux-pcmcia@lists.infradead.org, vbordug@ru.mvista.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/pcmcia: Add missing iounmap
	
	------------------------------------------------------
	
	
	of_iomap calls ioremap, and so should be matched with an iounmap.  At the
	two error returns, the result of calling of_iomap is only stored in a local
	variable, so these error paths need to call iounmap.  Furthermore, this
	function ultimately stores the result of of_iomap in an array that is local
	to the file.  These values should be iounmapped at some point.  I have
	added a corresponding call to iounmap at the end of the function m8xx_remove.
	
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2,x3;
	int ret;
	@@
	
	  T E;
	  ...
	* E = of_iomap(...);
	  if (E == NULL) S
	  ... when != iounmap(...,(T1)E,...)
	      when != if (E != NULL) { ... iounmap(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	  if (...) {
	    ... when != iounmap(...,(T2)E,...)
	        when != if (E != NULL) { ... iounmap(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=ofnametype/ofname1.cocci>ofnametype/ofname1.cocci</A>  -  add missing of_node_put
<pre>
	----------------------------
	
	
	of_node_put is needed before discarding a value received from
	of_find_node_by_name, eg in error handling code.
	
	The semantic patch that makes the change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct device_node *n;
	struct device_node *n1;
	statement S;
	identifier f;
	expression E;
	constant C;
	@@
	
	n = of_find_node_by_name(...)
	...
	if (!n) S
	... when != of_node_put(n)
	    when != n1 = f(n,...)
	    when != E = n
	    when any
	    when strict
	(
	+ of_node_put(n);
	  return -C;
	|
	  of_node_put(n);
	|
	  n1 = f(n,...)
	|
	  E = n
	|
	  return ...;
	)
	// </smpl>
	
</pre>
<A HREF=ofnametype/oftype1.cocci>ofnametype/oftype1.cocci</A>  -  add missing of_node_put
<pre>
	----------------------------
	
	
	of_node_put is needed before discarding a value received from
	of_find_node_by_name, eg in error handling code.
	
	The semantic patch that makes the change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct device_node *n;
	struct device_node *n1;
	statement S;
	identifier f;
	expression E;
	constant C;
	@@
	
	n = of_find_node_by_name(...)
	...
	if (!n) S
	... when != of_node_put(n)
	    when != n1 = f(n,...)
	    when != E = n
	    when any
	    when strict
	(
	+ of_node_put(n);
	  return -C;
	|
	  of_node_put(n);
	|
	  n1 = f(n,...)
	|
	  E = n
	|
	  return ...;
	)
	// </smpl>
	
</pre>
<A HREF=ofnodeget/ofnodeget.cocci>ofnodeget/ofnodeget.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	Add a call to of_node_put in the error handling code following a call to
	of_find_compatible_node.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E,E1;
	statement S;
	@@
	
	*x = 
	(of_find_node_by_path
	|of_find_node_by_name
	|of_find_node_by_phandle
	|of_get_parent
	|of_get_next_parent
	|of_get_next_child
	|of_find_compatible_node
	|of_match_node
	)(...);
	...
	if (x == NULL) S
	<... when != x = E
	*if (...) {
	  ... when != of_node_put(x)
	      when != if (...) { ... of_node_put(x); ... }
	(
	  return <+...x...+>;
	|
	*  return ...;
	)
	}
	...>
	of_node_put(x);
	// </smpl>
	
</pre>
<A HREF=ofnodeget/ofnodeget1.cocci>ofnodeget/ofnodeget1.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	Add a call to of_node_put in the error handling code following a call to
	of_find_compatible_node.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E,E1;
	statement S;
	@@
	
	*x = 
	(of_find_node_by_path
	|of_find_node_by_name
	|of_find_node_by_phandle
	|of_get_parent
	|of_get_next_parent
	|of_get_next_child
	|of_find_compatible_node
	|of_match_node
	)(...);
	...
	if (x == NULL) S
	<... when != x = E
	*if (...) {
	  ... when != of_node_put(x)
	      when != if (...) { ... of_node_put(x); ... }
	(
	  return <+...x...+>;
	|
	*  return ...;
	)
	}
	...>
	of_node_put(x);
	// </smpl>
	
</pre>
<A HREF=ofnodeget/ofnodeget2.cocci>ofnodeget/ofnodeget2.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	Add a call to of_node_put in the error handling code following a call to
	of_find_compatible_node.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E,E1;
	statement S;
	@@
	
	*x = 
	(of_find_node_by_path
	|of_find_node_by_name
	|of_find_node_by_phandle
	|of_get_parent
	|of_get_next_parent
	|of_get_next_child
	|of_find_compatible_node
	|of_match_node
	)(...);
	...
	if (x == NULL) S
	<... when != x = E
	*if (...) {
	  ... when != of_node_put(x)
	      when != if (...) { ... of_node_put(x); ... }
	(
	  return <+...x...+>;
	|
	*  return ...;
	)
	}
	...>
	of_node_put(x);
	// </smpl>
	
</pre>
<A HREF=ofnodeget3/ofnodeget3.cocci>ofnodeget3/ofnodeget3.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	This function is implemented as though the function of_get_next_child does
	not increment the reference count of its result, but actually it does.
	Thus the patch adds of_node_put in error handling code and drops a call to
	of_node_get.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E1;
	position p1,p2;
	@@
	
	x@p1 = of_get_next_child(...);
	... when != x = E1
	of_node_get@p2(x)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"call\",p1)
	cocci.print_secs(\"get\",p2)
	// </smpl>
	
</pre>
<A HREF=ofnodeget4/ofnodeget4.cocci>ofnodeget4/ofnodeget4.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	In this case, a device_node structure is stored in another structure that
	is then freed without first decrementing the reference count of the
	device_node structure.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression x;
	identifier f;
	position p1,p2;
	@@
	
	x@p1->f = \(of_find_node_by_path\|of_find_node_by_name\|of_find_node_by_phandle\|of_get_parent\|of_get_next_parent\|of_get_next_child\|of_find_compatible_node\|of_match_node\|of_find_node_by_type\|of_find_node_with_property\|of_find_matching_node\|of_parse_phandle\|of_node_get\)(...);
	... when != of_node_put(x)
	kfree@p2(x)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	cocci.print_main(\"call\",p1)
	cocci.print_secs(\"free\",p2)
	// </smpl>
	
</pre>
<A HREF=ofredef/ofredef.cocci>ofredef/ofredef.cocci</A>  -  add missing of_node_put
<pre>
	np is initialized to the result of calling a function that calls
	of_node_get, so of_node_put should be called before the pointer is dropped.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1,e2;
	@@
	
	* e = \(of_find_node_by_type\|of_find_node_by_name\)(...)
	  ... when != of_node_put(e)
	      when != true e == NULL
	      when != e2 = e
	  e = e1
	// </smpl>
	
</pre>
<A HREF=osdi_isnull/osdi_isnull.cocci>osdi_isnull/osdi_isnull.cocci</A>  -  Eliminate a NULL pointer dereference
<pre>
	----------------------------
	
	
	In each case, the print involves dereferencing a value that is NULL or is
	near NULL.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression E,E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	if ((E == NULL && ...) || ...)
	{
	  ... when != if (...) S1 else S2
	      when != E = E1
	* E->f
	  ... when any
	  return ...;
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=osdi_isnull/osdi_isnull3.cocci>osdi_isnull/osdi_isnull3.cocci</A>  -  Eliminate a NULL pointer dereference
<pre>
	----------------------------
	
	
	In each case, the print involves dereferencing a value that is NULL or is
	near NULL.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression E,E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	if ((E == NULL && ...) || ...)
	{
	  ... when != if (...) S1 else S2
	      when != E = E1
	* E->f
	  ... when any
	  return ...;
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=osdi_kfree/osdi_kfree.cocci>osdi_kfree/osdi_kfree.cocci</A>  -  Eliminate use after free
<pre>
	----------------------------
	
	
	The error value is saved in a new local variable err before freeing the
	containing structure.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@free@
	expression E;
	position p;
	@@
	kfree@p(E)
	
	@@
	expression free.E, subE<=free.E, E1;
	position free.p;
	@@
	
	  kfree@p(E)
	  ...
	(
	  subE = E1
	|
	* E
	)
	// </smpl>
	
</pre>
<A HREF=parport/sp8188.cocci>parport/sp8188.cocci</A>  -  Put gotten port value
<pre>
	parport_find_number calls parport_get_port on its result, so there should
	be a corresponding call to parport_put_port before dropping the reference.
	Similar code is found in the function register_device in the same file.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression struct parport * x;
	expression ra,rr;
	statement S1,S2;
	@@
	
	x = parport_find_number(...)
	... when != x = rr
	    when any
	    when != parport_put_port(x,...)
	    when != if (...) { ... parport_put_port(x,...) ...}
	(
	if(<+...x...+>) S1 else S2
	|
	if(...) { ... when != x = ra
	     when forall
	     when != parport_put_port(x,...)
	*return...;
	}
	)
	// </smpl>
	
</pre>
<A HREF=parse_phandle/parse_phandle.cocci>parse_phandle/parse_phandle.cocci</A>  -  add missing of_node_put
<pre>
	of_parse_phandle increments the reference count of np, so this should be
	decremented before trying the next possibility.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1,e2;
	@@
	
	*e = of_parse_phandle(...)
	... when != of_node_put(e)
	    when != true e == NULL
	    when != e2 = e
	e = e1
	// </smpl>
	
</pre>
<A HREF=pci_add_put/pci_noputm.cocci>pci_add_put/pci_noputm.cocci</A>  -  Add missing pci_dev_put
<pre>
	Send to:
	gregkh@suse.de, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 3/5] drivers/pci/pci-sysfs.c: Add missing pci_dev_put
	
	------------------------------------------------------
	
	
	There should be a pci_dev_put when breaking out of a loop that iterates
	over calls to pci_get_device and similar functions.
	
	This was fixed using the following semantic patch.
	
	// <smpl>
	@@
	identifier d;
	type T;
	expression e;
	iterator for_each_pci_dev;
	@@
	
	T *d;
	...
	for_each_pci_dev(d)
	  {... when != pci_dev_put(d)
	       when != e = d
	(
	   return d;
	|
	+  pci_dev_put(d);
	?  return ...;
	)
	...}
	// </smpl>
	
</pre>
<A HREF=pci_drop_put/pci_get.cocci>pci_drop_put/pci_get.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=pciom/pciom3.cocci>pciom/pciom3.cocci</A>  -  exchange pci_iounmaps
<pre>
	The calls to pci_iounmap are in the wrong order, as compared to the
	associated calls to pci_iomap.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,x;
	statement S,S1;
	int ret;
	@@
	e = pci_iomap(x,...)
	... when != pci_iounmap(x,e)
	if (<+...e...+>) S
	... when any
	    when != pci_iounmap(x,e)
	*if (...)
	   { ... when != pci_iounmap(x,e)
	     return ...; }
	... when any
	pci_iounmap(x,e);
	// </smpl>
	
</pre>
<A HREF=pd/pd.cocci>pd/pd.cocci</A>  -  Invert calls to platform_device_put and platform_device_del
<pre>
	Platform_device_del should be called before platform_device_put, as
	platform_device_put can delete the structure.
	
	Additionally, improve the error handling code for the call to ioremap, so
	that it calls platform_device_put.
	
	The semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e1,e2;
	@@
	
	*platform_device_put(e1);
	... when != e1 = e2
	*platform_device_del(e1);
	// </smpl>
	
</pre>
<A HREF=platret/platret.cocci>platret/platret.cocci</A>  -  failure test for null rather than negative integer
<pre>
	dev_get_platdata returns a pointer, so the failure value would be NULL
	rather than a negative integer.
	
	The semantic match that finds this problem is: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e;
	statement S1,S2;
	@@
	
	*x = dev_get_platdata(...)
	... when != x = e
	*if (x < 0) S1 else S2
	// </smpl>
	
</pre>
<A HREF=pointless_err/pointless_err.cocci>pointless_err/pointless_err.cocci</A>  -  Use ERR_CAST
<pre>
	----------------------------
	
	
	Use ERR_CAST(x) rather than ERR_PTR(PTR_ERR(x)).  The former makes more
	clear what is the purpose of the operation, which otherwise looks like a
	no-op.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	T x;
	identifier f;
	@@
	
	T f (...) { <+...
	- ERR_PTR(PTR_ERR(x))
	+ x
	 ...+> }
	
	@@
	expression x;
	@@
	
	- ERR_PTR(PTR_ERR(x))
	+ ERR_CAST(x)
	// </smpl>
	
</pre>
<A HREF=prepare2/prepare2.cocci>prepare2/prepare2.cocci</A>  -  mv64xxx: use clk_prepare_enable and clk_disable_unprepare
<pre>
	Clk_prepare_enable and clk_disable_unprepare combine clk_prepare and
	clk_enable, and clk_disable and clk_unprepare.  They make the code more
	concise, and ensure that clk_unprepare is called when clk_enable fails.
	
	A simplified version of the semantic patch that introduces calls to these
	functions is as follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e;
	@@
	
	- clk_prepare(e);
	- clk_enable(e);
	+ clk_prepare_enable(e);
	
	@@
	expression e;
	@@
	
	- clk_disable(e);
	- clk_unprepare(e);
	+ clk_disable_unprepare(e);
	// </smpl>
	
</pre>
<A HREF=ptr/ptr.cocci>ptr/ptr.cocci</A>  -  Correct error handling code
<pre>
	----------------------------
	
	
	If it is reasonable to apply PTR_ERR to the result of calling clk_get, then
	that result should first be tested with IS_ERR, not with !.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E,E1;
	@@
	
	if (
	-   E == NULL
	+   IS_ERR(E)
	   ) { <+... when != E = E1
	        PTR_ERR(E)
	       ...+> }
	// </smpl>
	
</pre>
<A HREF=put_after/put_after.cocci>put_after/put_after.cocci</A>  -  add missing of_node_put
<pre>
	dma_channel_np has been accessed at this point, so decrease its reference
	count before leaving the function.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	identifier x;
	expression E1!=0,E2,E3,E4;
	statement S;
	iterator I;
	@@
	
	(
	if (...) { ... when != of_node_put(x)
	               when != x = E3
	               when != E3 = x
	*  return ...;
	 }
	... when != x = E2
	    when != I(...,x,...) S
	if (...) { ... when != x = E4
	 of_node_put(x); ... return ...; }
	)
	// </smpl>
	
</pre>
<A HREF=put_deref/patch.cocci>put_deref/patch.cocci</A>  -  move of_node_put
<pre>
	----------------------------
	
	
	It seems better to dereference master before decrementing the reference
	count rather than afterwards.
	
	The problem was found using the following semantic match:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	expression n,E;
	identifier fld;
	iterator I;
	statement S;
	@@
	
	* of_node_put(n)
	... when != n = E
	    when != I(n,...) S
	* n->fld
	// </smpl>
	
</pre>
<A HREF=putty/putty.cocci>putty/putty.cocci</A>  -  avoid calling put_tty_driver on NULL
<pre>
	put_tty_driver calls tty_driver_kref_put on its argument, and then
	tty_driver_kref_put calls kref_put on the address of a field of this
	argument.  kref_put checks for NULL, but in this case the field is likely
	to have some offset and so the result of taking its address will not be
	NULL.  Labels are added to be able to skip over the call to put_tty_driver
	when the argument will be NULL.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *x;
	@@
	
	*if (x == NULL)
	{ ...
	* put_tty_driver(x);
	  ...
	  return ...;
	}
	// </smpl>
	
</pre>
<A HREF=rcu/rcu.cocci>rcu/rcu.cocci</A>  -  call rcu_read_unlock in default case
<pre>
	----------------------------
	
	
	Adjust the default case so that it benefits from the call to rcu_read_unlock.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@rcu@
	position p1;
	@@
	
	rcu_read_lock@p1();
	...
	rcu_read_unlock();
	
	@@
	position rcu.p1;
	@@
	
	*rcu_read_lock@p1();
	... when != rcu_read_unlock();
	// </smpl>
	
</pre>
<A HREF=reiserfs/category2a_open_xa_dir.cocci>reiserfs/category2a_open_xa_dir.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function open_xa_dir returns an ERR pointer,
	but never returns a NULL pointer. So a NULL test that comes after an
	IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = open_xa_dir(...)
	... when != x = E
	(
	*  if (x == NULL && ...) S1 else S2
	|
	*  if (x == NULL || ...) S1 else S2
	)
	// </smpl>
	
</pre>
<A HREF=remap_bar/remap_bar.cocci>remap_bar/remap_bar.cocci</A>  -  reorder error handling code to include iounmap
<pre>
	The out_msi_disable label should be before cleanup_nomem to additionally
	benefit from the call to iounmap.  Subsequent gotos are adjusted to go to
	out_msi_disable instead of cleanup_nomem, which now follows it.  This is
	safe because pci_disable_msi does nothing if pci_enable_msi was not called.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression e1,e2;
	statement S;
	@@
	
	e1 = pci_ioremap_bar(...);
	... when != e1 = e2
	    when != iounmap(e1)
	    when any
	(
	 if (<+...e1...+>) S
	|
	 if(...) { ... return 0; }
	|
	 if (...) { ... when != iounmap(e1)
	                when != if (...) { ... iounmap(e1) ... }
	* return ...;
	 } else S
	)
	// </smpl>
	
</pre>
<A HREF=remove/remove.cocci>remove/remove.cocci</A>  -  Drop return value from platform_driver remove functions
<pre>
	----------------------------
	
	
	The return value of the remove function of a driver structure, and thus of
	a platform_driver structure, is ultimately ignored, and is thus
	unnecessary.  This patch removes the return value for the remove function
	stored in a platform_driver structure.  For the files in this patch, the
	return values are always 0.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	struct platform_driver I;
	identifier a,f;
	position p;
	@@
	I.remove = \(f@p\|a(f@p)\);
	
	@void_called@
	identifier r.f;
	position p;
	@@
	f@p(...);
	
	@called@
	identifier r.f;
	position p1 != void_called.p;
	@@
	f@p1(...)
	
	@localfn@
	identifier r.f;
	@@
	static int f(...) { ... }
	
	@depends on !called && localfn@
	struct platform_driver I;
	identifier a,f;
	position r.p;
	@@
	
	I.
	- remove
	+ remove_new
	   = \(f@p\|a(f@p)\);
	
	@depends on !called && localfn@
	identifier r.f,i;
	constant C;
	expression E;
	@@
	
	- int
	+ void
	       f(...) {
	  <...
	(
	-  return \(C\|i\);
	+  return;
	|
	-  return E;
	+  E;
	+  return;
	)
	  ...>
	}
	// </smpl>
	
</pre>
<A HREF=reqrel2/reqrel2.cocci>reqrel2/reqrel2.cocci</A>  -  Use release_mem_region after request_mem_region
<pre>
	The memory allocated using request_mem_region should be released using
	release_mem_region, not release_region.
	
	The semantic patch that fixes part of this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E1,E2,E3;
	@@
	
	request_mem_region(E1,E2,E3)
	...
	?- release_region(E1,E2)
	+ release_mem_region(E1,E2)
	// </smpl>
	
</pre>
<A HREF=requests/diou.cocci>requests/diou.cocci</A>  -  use devm_kzalloc and devm_clk_get
<pre>
	Using devm_kzalloc and devm_clk_get simplifies the code and ensures that
	the use of devm_request_irq is safe.  When kzalloc and kfree were used, the
	interrupt could be triggered after the handler's data argument had been
	freed.
	
	The problem of a free after a devm_request_irq was found using the
	following semantic match (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression e1,e2,x,a,b,c,d;
	identifier free;
	position p1,p2;
	@@
	
	  devm_request_irq@p1(e1,e2,...,x)
	  ... when any
	      when != e2 = a
	      when != x = b
	  if (...) {
	    ... when != e2 = c
	        when != x = d
	    free@p2(...,x,...);
	    ...
	    return ...;
	  }
	// </smpl>
	
</pre>
<A HREF=requests/dirq.cocci>requests/dirq.cocci</A>  -  use devm_kzalloc and devm_clk_get
<pre>
	Using devm_kzalloc and devm_clk_get simplifies the code and ensures that
	the use of devm_request_irq is safe.  When kzalloc and kfree were used, the
	interrupt could be triggered after the handler's data argument had been
	freed.
	
	The problem of a free after a devm_request_irq was found using the
	following semantic match (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression e1,e2,x,a,b,c,d;
	identifier free;
	position p1,p2;
	@@
	
	  devm_request_irq@p1(e1,e2,...,x)
	  ... when any
	      when != e2 = a
	      when != x = b
	  if (...) {
	    ... when != e2 = c
	        when != x = d
	    free@p2(...,x,...);
	    ...
	    return ...;
	  }
	// </smpl>
	
</pre>
<A HREF=resource/reg.cocci>resource/reg.cocci</A>  -  Convert release_resource to release_region/release_mem_region
<pre>
	Request_region should be used with release_region, not release_resource.
	
	The result of request_mem_region is no longer stored.  Instead the field
	ioarea is used to store a pointer to the resource structure that contains
	the start address.  This is the information that is needed later in
	nuc900_i2c_remove to release the region.  The field ioarea is also printed
	in some debugging code.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,E;
	@@
	(
	*x = request_region(...)
	|
	*x = request_mem_region(...)
	)
	... when != release_region(x)
	    when != x = E
	* release_resource(x);
	// </smpl>
	
</pre>
<A HREF=resource/resource.cocci>resource/resource.cocci</A>  -  Convert release_resource to release_region/release_mem_region
<pre>
	Request_region should be used with release_region, not release_resource.
	
	The result of request_mem_region is no longer stored.  Instead the field
	ioarea is used to store a pointer to the resource structure that contains
	the start address.  This is the information that is needed later in
	nuc900_i2c_remove to release the region.  The field ioarea is also printed
	in some debugging code.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,E;
	@@
	(
	*x = request_region(...)
	|
	*x = request_mem_region(...)
	)
	... when != release_region(x)
	    when != x = E
	* release_resource(x);
	// </smpl>
	
</pre>
<A HREF=resource_fix1/resource_fix1.cocci>resource_fix1/resource_fix1.cocci</A>  -  Convert release_resource to release_mem_region
<pre>
	Request_mem_region should be used with release_mem_region, not
	release_resource.
	
	A semantic patch that partially fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@b@
	expression x,E;
	@@
	
	x = request_mem_region(x->start,...)
	... when != release_mem_region(x->start,...)
	    when != x = E
	(
	- release_resource(x);
	- kfree(x);
	+  release_mem_region(x->start,resource_size(x));
	|
	?- release_resource(x);
	+  release_mem_region(x->start,resource_size(x));
	)
	// </smpl>
	
</pre>
<A HREF=resource_size/resource_size.cocci>resource_size/resource_size.cocci</A>  -  Use resource_size
<pre>
	----------------------------
	
	
	Use the function resource_size, which reduces the chance of introducing
	off-by-one errors in calculating the resource size.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct resource *res;
	@@
	
	- (res->end - res->start) + 1
	+ resource_size(res)
	// </smpl>
	
</pre>
<A HREF=ret3/ret3.cocci>ret3/ret3.cocci</A>  -  fix error return code
<pre>
	Convert a nonnegative error return code to a negative one, as returned
	elsewhere in the function.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	identifier ret;
	expression e1,e2;
	@@
	
	if (ret < 0)
	 { ... return ret; }
	 ... when != ret = e1
	     when forall
	*if(...)
	 {
	  ... when != ret = e2
	* return ret;
	 }
	// </smpl>
	
</pre>
<A HREF=ret4/ret4.cocci>ret4/ret4.cocci</A>  -  fix error return code
<pre>
	Initialize return variable before exiting on an error path.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	(
	if@p1 (\(ret < 0\|ret != 0\))
	 { ... return ret; }
	|
	ret@p1 = 0
	)
	... when != ret = e1
	    when != &ret
	*if(...)
	{
	  ... when != ret = e2
	      when forall
	 return ret;
	}
	
	// </smpl>
	
</pre>
<A HREF=retalloc/retalloc.cocci>retalloc/retalloc.cocci</A>  -  fix error return code
<pre>
	Convert a 0 error return code to a negative one, as returned elsewhere in the
	function.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	identifier ret;
	expression e,e1,e2,e3,e4,x;
	@@
	
	(
	if (\(ret != 0\|ret < 0\) || ...) { ... return ...; }
	|
	ret = 0
	)
	... when != ret = e1
	*x = \(kmalloc\|kzalloc\|kcalloc\|devm_kzalloc\|ioremap\|ioremap_nocache\|devm_ioremap\|devm_ioremap_nocache\)(...);
	... when != x = e2
	    when != ret = e3
	*if (x == NULL || ...)
	{
	  ... when != ret = e4
	*  return ret;
	}
	// </smpl>
	
</pre>
<A HREF=rirqp/rirqp.cocci>rirqp/rirqp.cocci</A>  -  ensure arguments to request_irq and free_irq are compatible
<pre>
	Convert calls to free_irq so that the second argument is the same as the
	last argument of the corresponding call to request_irq.  Without this
	property, free_irq does nothing.
	
</pre>
<A HREF=round/round.cocci>round/round.cocci</A>  -  Use DIV_ROUND_UP
<pre>
	----------------------------
	
	
	The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
	(d)) but is perhaps more readable.
	
	An extract of the semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@haskernel@
	@@
	
	#include <linux/kernel.h>
	
	@depends on haskernel@
	expression n,d;
	@@
	
	(
	- (n + d - 1) / d
	+ DIV_ROUND_UP(n,d)
	|
	- (n + (d - 1)) / d
	+ DIV_ROUND_UP(n,d)
	)
	
	@depends on haskernel@
	expression n,d;
	@@
	
	- DIV_ROUND_UP((n),d)
	+ DIV_ROUND_UP(n,d)
	
	@depends on haskernel@
	expression n,d;
	@@
	
	- DIV_ROUND_UP(n,(d))
	+ DIV_ROUND_UP(n,d)
	// </smpl>
	
</pre>
<A HREF=round2/round.cocci>round2/round.cocci</A>  -  Use DIV_ROUND_UP
<pre>
	----------------------------
	
	
	The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
	(d)) but is perhaps more readable.
	
	An extract of the semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@haskernel@
	@@
	
	#include <linux/kernel.h>
	
	@depends on haskernel@
	expression n,d;
	@@
	
	(
	- (n + d - 1) / d
	+ DIV_ROUND_UP(n,d)
	|
	- (n + (d - 1)) / d
	+ DIV_ROUND_UP(n,d)
	)
	
	@depends on haskernel@
	expression n,d;
	@@
	
	- DIV_ROUND_UP((n),d)
	+ DIV_ROUND_UP(n,d)
	
	@depends on haskernel@
	expression n,d;
	@@
	
	- DIV_ROUND_UP(n,(d))
	+ DIV_ROUND_UP(n,d)
	// </smpl>
	
</pre>
<A HREF=round_closest/round_closest.cocci>round_closest/round_closest.cocci</A>  -  Use DIV_ROUND_CLOSEST
<pre>
	----------------------------
	
	
	The kernel.h macro DIV_ROUND_CLOSEST performs the computation (x + d/2)/d
	but is perhaps more readable.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@haskernel@
	@@
	
	#include <linux/kernel.h>
	
	@depends on haskernel@
	expression x,__divisor;
	@@
	
	- (((x) + ((__divisor) / 2)) / (__divisor))
	+ DIV_ROUND_CLOSEST(x,__divisor)
	// </smpl>
	
</pre>
<A HREF=rr/rr.cocci>rr/rr.cocci</A>  -  Correct use of request_region/request_mem_region
<pre>
	----------------------------
	
	
	request_region should be used with release_region, not request_mem_region.
	
	Geert Uytterhoeven pointed out that in the case of drivers/video/gbefb.c,
	the problem is actually the other way around; request_mem_region should be
	used instead of request_region.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r1@
	expression start;
	@@
	
	request_region(start,...)
	
	@b1@
	expression r1.start;
	@@
	
	request_mem_region(start,...)
	
	@depends on !b1@
	expression r1.start;
	expression E;
	@@
	
	- release_mem_region
	+ release_region
	  (start,E)
	// </smpl>
	
</pre>
<A HREF=rr/rr1.cocci>rr/rr1.cocci</A>  -  Correct use of request_region/request_mem_region
<pre>
	----------------------------
	
	
	request_region should be used with release_region, not request_mem_region.
	
	Geert Uytterhoeven pointed out that in the case of drivers/video/gbefb.c,
	the problem is actually the other way around; request_mem_region should be
	used instead of request_region.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r1@
	expression start;
	@@
	
	request_region(start,...)
	
	@b1@
	expression r1.start;
	@@
	
	request_mem_region(start,...)
	
	@depends on !b1@
	expression r1.start;
	expression E;
	@@
	
	- release_mem_region
	+ release_region
	  (start,E)
	// </smpl>
	
</pre>
<A HREF=rxrpc/category2a_rxrpc_get_transport.cocci>rxrpc/category2a_rxrpc_get_transport.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function rxrpc_get_transport returns an ERR
	pointer, but never returns a NULL pointer. So after a call to this
	function, a NULL test should be replaced by an IS_ERR test.
	
	A simplified version of the semantic patch that makes this change is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@correct_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x =  rxrpc_get_transport(...)
	<... when != x = E
	if (
	(
	- x@p2 != NULL
	+ ! IS_ERR ( x )
	|
	- x@p2 == NULL
	+ IS_ERR( x )
	)
	 )
	S1
	else S2
	...>
	? x = E;
	// </smpl>
	
</pre>
<A HREF=s390/category2a_dasd_kmalloc_request.cocci>s390/category2a_dasd_kmalloc_request.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, functions dasd_kmalloc_request and idal_buffer_alloc
	return an ERR pointer, but never return the NULL pointer. So after a
	call to one of these functions, a NULL test should be replaced by an
	IS_ERR test.
	
	A simplified version of the semantic patch that makes this change is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@correct_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x = 
	(
	  dasd_kmalloc_request(...)
	|
	  idal_buffer_alloc(...)
	)
	<... when != x = E
	if (
	(
	- x@p2 != NULL
	+ ! IS_ERR ( x )
	|
	- x@p2 == NULL
	+ IS_ERR( x )
	)
	 )
	S1
	else S2
	...>
	? x = E;
	// </smpl>
	
</pre>
<A HREF=s390/category2a_idal_buffer_alloc.cocci>s390/category2a_idal_buffer_alloc.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, functions dasd_kmalloc_request and idal_buffer_alloc
	return an ERR pointer, but never return the NULL pointer. So after a
	call to one of these functions, a NULL test should be replaced by an
	IS_ERR test.
	
	A simplified version of the semantic patch that makes this change is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@correct_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x = 
	(
	  dasd_kmalloc_request(...)
	|
	  idal_buffer_alloc(...)
	)
	<... when != x = E
	if (
	(
	- x@p2 != NULL
	+ ! IS_ERR ( x )
	|
	- x@p2 == NULL
	+ IS_ERR( x )
	)
	 )
	S1
	else S2
	...>
	? x = E;
	// </smpl>
	
</pre>
<A HREF=s390/s390.cocci>s390/s390.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, functions dasd_kmalloc_request and idal_buffer_alloc
	return an ERR pointer, but never return the NULL pointer. So after a
	call to one of these functions, a NULL test should be replaced by an
	IS_ERR test.
	
	A simplified version of the semantic patch that makes this change is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@correct_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x = 
	(
	  dasd_kmalloc_request(...)
	|
	  idal_buffer_alloc(...)
	)
	<... when != x = E
	if (
	(
	- x@p2 != NULL
	+ ! IS_ERR ( x )
	|
	- x@p2 == NULL
	+ IS_ERR( x )
	)
	 )
	S1
	else S2
	...>
	? x = E;
	// </smpl>
	
</pre>
<A HREF=samba_free/samba.cocci>samba_free/samba.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=semicolon/semicolon.cocci>semicolon/semicolon.cocci</A>  -  removes unnecessary semicolon
<pre>
	removes unnecessary semicolon
	
	Found by Coccinelle: http://coccinelle.lip6.fr/
	
</pre>
<A HREF=serial_core/serial_core.cocci>serial_core/serial_core.cocci</A>  -  Use UPIO_MEM rather than SERIAL_IO_MEM
<pre>
	----------------------------
	
	
	As in the commit 9b4a1617772d6d5ab5eeda0cd95302fae119e359, use UPIO_MEM
	rather than SERIAL_IO_MEM.  Both have the same value.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@has_sc@
	@@
	
	#include <linux/serial_core.h>
	
	@depends on has_sc@
	@@
	
	- SERIAL_IO_MEM
	+ UPIO_MEM
	// </smpl>
	
</pre>
<A HREF=signed/signed.cocci>signed/signed.cocci</A>  -  use unsigned for loop index
<pre>
	----------------------------
	
	
	A few more cases in the spirit of the patch \"Trivial: Replacement of always
	>0 ints with unsigned ints\" submitted by Ricardo Martins <ricardo@scarybox.net>
	
	The transformation was made using the following semantic patch
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@ // find anything that might decrement the variable
	identifier i;
	expression E;
	position p;
	@@
	
	  int i@p;
	  ...
	(
	  &i
	|
	  i--
	|
	  --i
	|
	  i-=E
	|
	  i+=E
	)
	
	@x disable decl_init@
	identifier r.i;
	expression E;
	position p1 != r.p;
	@@
	
	(
	  volatile int i = 0;
	|
	  volatile int i;
	|
	+ unsigned
	  int i@p1 = 0;
	|
	+ unsigned
	  int i@p1;
	)
	  <... when != i = E      
	(
	  i = 0
	|
	  i = 1
	)
	  ...>
	// </smpl>
	
</pre>
<A HREF=simple_kzalloc/simple_kzalloc1.cocci>simple_kzalloc/simple_kzalloc1.cocci</A>  -  Use kzalloc
<pre>
	----------------------------
	
	
	Use kzalloc rather than the combination of kmalloc and memset.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,size,flags;
	statement S;
	@@
	
	-x = kmalloc(size,flags);
	+x = kzalloc(size,flags);
	 if (x == NULL) S
	-memset(x, 0, size);
	// </smpl>
	
</pre>
<A HREF=sin_family/sin_family.cocci>sin_family/sin_family.cocci</A>  -  Use AF_INET for sin_family field
<pre>
	----------------------------
	
	
	Elsewhere the sin_family field holds a value with a name of the form
	AF_..., so it seems reasonable to do so here as well.  Also the values of
	PF_INET and AF_INET are the same.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	struct sockaddr_in sip;
	@@
	
	(
	sip.sin_family ==
	- PF_INET
	+ AF_INET
	|
	sip.sin_family !=
	- PF_INET
	+ AF_INET
	|
	sip.sin_family =
	- PF_INET
	+ AF_INET
	)
	// </smpl>
	
</pre>
<A HREF=sizeof/sizeof_sizeof.cocci>sizeof/sizeof_sizeof.cocci</A>  -  Eliminate double sizeof
<pre>
	florian.fainelli@telecomint.eu, jgarzik@pobox.com, netdev@vger.kernel.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH] drivers/net/r6040.c: Eliminate double sizeof
	
	------------------------------------------------------
	
	
	Taking sizeof the result of sizeof is quite strange and does not seem to be
	what is wanted here.
	
	This was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	@@
	
	- sizeof (
	  sizeof (E)
	- )
	// </smpl>
	
</pre>
<A HREF=sla/sla.cocci>sla/sla.cocci</A>  -  Use GFP_ATOMIC when a lock is held
<pre>
	----------------------------
	
	
	A spin lock is taken near the beginning of the enclosing function.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	spin_lock(...)
	... when != spin_unlock(...)
	-GFP_KERNEL
	+GFP_ATOMIC
	// </smpl>
	
</pre>
<A HREF=slot/slot.cocci>slot/slot.cocci</A>  -  Add missing pci_dev_put
<pre>
	Pci_get_slot calls pci_dev_get, so pci_dev_put is needed before leaving the
	function.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	local idexpression x;
	expression e;
	@@
	
	*x = pci_get_slot(...)
	... when != true x == NULL
	    when != pci_dev_put(x)
	    when != e = x
	    when != if (x != NULL) {<+... pci_dev_put(x); ...+>}
	*return ...;
	// </smpl>
	
</pre>
<A HREF=soc_sound/category2a_ssc_request.cocci>soc_sound/category2a_ssc_request.cocci</A>  -  Useless NULL test
<pre>
	----------------------------
	
	
	The test (ssc != NULL) can only be reached if the call to the function
	ssc_request, the result of which ssc is assigned, succeeds. Moreover,
	two statements assign NULL to ssc just before a return, which is useless
	since it is a local variable. So, we suggest to delete the test and
	the two assignments.
	
	A simplified version of the semantic match that finds this problem is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@bad_null_test@
	expression x,E;
	@@
	x = ssc_request(...)
	... when != x = E
	* x != NULL
	// </smpl>
	
</pre>
<A HREF=sockfd/patch.cocci>sockfd/patch.cocci</A>  -  Use sockfd_put
<pre>
	net/bluetooth/bnep/sock.c
	net/bluetooth/cmtp/sock.c
	net/bluetooth/hidp/sock.c
	
	Send to:
	marcel@holtmann.org, maxk@qualcomm.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] /net/bluetooth: Use sockfd_put
	
	------------------------------------------------------
	
	
	The function sockfd_lookup uses fget on the value that is stored in the
	file field of the returned structure, so fput should ultimately be applied
	to this value.  This can be done directly, but it seems better to use the
	sockfd specific macro sockfd_put, which does the same thing.
	
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression s;
	@@
	
	   s = sockfd_lookup(...)
	   ...
	+  sockfd_put(s);
	?- fput(s->file);
	// </smpl>
	
</pre>
<A HREF=stest/stest.cocci>stest/stest.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=strsize/strsizeof.cocci>strsize/strsizeof.cocci</A>  -  convert strncmp to strcmp
<pre>
	----------------------------
	
	
	As an identical match is wanted in this case, strcmp can be used instead.
	
	The semantic match that lead to detecting this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression foo;
	constant char *abc;
	@@
	
	*strncmp(foo, abc, sizeof(abc))
	// </smpl>
	
</pre>
<A HREF=strtoul/simple.cocci>strtoul/simple.cocci</A>  -  change simple_strtol to simple_strtoul
<pre>
	----------------------------
	
	
	Since bridge is unsigned, it would seem better to use simple_strtoul that
	simple_strtol.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r2@
	long e;
	position p;
	@@
	
	e = simple_strtol@p(...)
	
	@@
	position p != r2.p;
	type T;
	T e;
	@@
	
	e = 
	- simple_strtol@p
	+ simple_strtoul
	  (...)
	// </smpl>
	
</pre>
<A HREF=sz/sz.cocci>sz/sz.cocci</A>  -  Correct code taking the size of a pointer
<pre>
	----------------------------
	
	
	sizeof(share_id) is just the size of the pointer.  On the other hand,
	block->share_id is an array, so its size seems more appropriate.
	
	A simplified version of the semantic patch that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *x;
	expression f;
	type T;
	@@
	
	*f(...,(T)x,...)
	// </smpl>
	
</pre>
<A HREF=sz3/sz3.cocci>sz3/sz3.cocci</A>  -  take size of pointed value, not pointer
<pre>
	Sizeof a pointer-typed expression returns the size of the pointer, not that
	of the pointed data.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *e;
	type T;
	identifier f;
	@@
	
	f(...,(T)e,...,
	-sizeof(e)
	+sizeof(*e)
	,...)
	// </smpl>
	
</pre>
<A HREF=tipc/tipc.cocci>tipc/tipc.cocci</A>  -  Use tipc_port_unlock
<pre>
	net/tipc/port.c
	
	Send to:
	per.liden@ericsson.com, jon.maloy@ericsson.com, allan.stephens@windriver.com, tipc-discussion@lists.sourceforge.net, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] /net/tipc/port.c: Use tipc_port_unlock
	
	------------------------------------------------------
	
	
	The file net/tipc/port.c takes a lock using the function tipc_port_lock and
	then releases the lock sometimes using tipc_port_unlock and sometimes using
	spin_unlock_bh(p_ptr->publ.lock).  tipc_port_unlock simply does the
	spin_unlock_bh, but it seems cleaner to use it everywhere.
	
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct port *p_ptr;
	@@
	
	   p_ptr = tipc_port_lock(...)
	   ...
	(
	   p_ptr = tipc_port_lock(...);
	|
	?- spin_unlock_bh(p_ptr->publ.lock);
	+  tipc_port_unlock(p_ptr);
	)
	// </smpl>
	
</pre>
<A HREF=tty_port/sp10730.cocci>tty_port/sp10730.cocci</A>  -  Put correct tty value
<pre>
	The tty value that should be put is the one that was just gotten by
	tty_port_tty_get, not the one that is the argument to the enclosing
	function.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression struct tty_struct *x;
	expression ra,rr;
	statement S1,S2;
	@@
	
	x = tty_port_tty_get(...)
	... when != x = rr
	    when any
	    when != tty_kref_put(x,...)
	    when != if (...) { ... tty_kref_put(x,...) ...}
	(
	if(<+...x...+>) S1 else S2
	|
	if(...) { ... when != x = ra
	     when forall
	     when != tty_kref_put(x,...)
	*return...;
	}
	)
	// </smpl>
	
</pre>
<A HREF=typedef/handle.cocci>typedef/handle.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=typedef/hv/device_object/DEVICE_OBJECT.cocci>typedef/hv/device_object/DEVICE_OBJECT.cocci</A>  -  Staging: hv: Transform PDEVICE_OBJECT and DEVICE_OBJECT typedefs into their corresponding structs
<pre>
	
	Remove typedef DEVICE_OBJECT and use a struct named hv_device instead.
	
	Remove typedef PDEVICE_OBJECT which aliases a pointer and use the
	struct pointer (struct hv_device *).
	
	Here is the semantic patch to perform this transformation:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@rm_PDEVICE_OBJECT@
	@@
	-typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
	
	@rm_DEVICE_OBJECT@
	@@
	-typedef struct _DEVICE_OBJECT
	+struct hv_device
	{...}
	-DEVICE_OBJECT
	;
	
	@fixtypedef_PDEVICE_OBJECT@
	typedef PDEVICE_OBJECT;
	@@
	-PDEVICE_OBJECT
	+struct hv_device*
	
	@fixtypedef_DEVICE_OBJECT@
	typedef DEVICE_OBJECT;
	@@
	-DEVICE_OBJECT
	+struct hv_device
	
	@fixstruct__DEVICE_OBJECT@
	@@
	struct
	-_DEVICE_OBJECT
	+hv_device
	//</smpl>
</pre>
<A HREF=typedef/hv/driver_object/DRIVER_OBJECT.cocci>typedef/hv/driver_object/DRIVER_OBJECT.cocci</A>  -  Staging: hv: Remove typedef DRIVER_OBJECT and PDRIVER_OBJECT
<pre>
	
	typedef DRIVER_OBJECT and PDRIVER_OBJECT are removed and their usages
	are replace by the use of struct hv_driver and struct hv_driver *
	respectively.
	
	Here is the semantic patch generated to perform this transformation:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@rm_DRIVER_OBJECT@
	@@
	-typedef struct _DRIVER_OBJECT
	+struct hv_driver
	{...}
	-DRIVER_OBJECT
	;
	
	@rm_PDRIVER_OBJECT@
	@@
	-typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;
	+struct hv_driver;
	
	@fixtypedef_DRIVER_OBJECT@
	typedef DRIVER_OBJECT;
	@@
	-DRIVER_OBJECT
	+struct hv_driver
	
	@fixstruct__DRIVER_OBJECT@
	@@
	struct
	-_DRIVER_OBJECT
	+hv_driver
	
	@fixtypedef_PDRIVER_OBJECT@
	typedef PDRIVER_OBJECT;
	@@
	-PDRIVER_OBJECT
	+struct hv_driver*
	//</smpl>
</pre>
<A HREF=typedef/hv/netvsc/NETVSC_PACKET.cocci>typedef/hv/netvsc/NETVSC_PACKET.cocci</A>  -  Staging: hv: Remove typedef NETVSC_PACKET and PNETVSC_PACKET
<pre>
	
	typedef NETVSC_PACKET and PNETVSC_PACKET are removed and their usages
	are replace by the use of struct hv_netvsc_packet and
	struct hv_netvsc_packet * respectively.
	
	Here is the semantic patch generated to perform this transformation:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@rm_NETVSC_PACKET@
	@@
	-typedef struct _NETVSC_PACKET
	+struct hv_netvsc_packet
	{...}
	-NETVSC_PACKET
	;
	
	@rm_PNETVSC_PACKET@
	@@
	-typedef struct _NETVSC_PACKET *PNETVSC_PACKET;
	+struct hv_netvsc_packet;
	
	@fixtypedef_NETVSC_PACKET@
	typedef NETVSC_PACKET;
	@@
	-NETVSC_PACKET
	+struct hv_netvsc_packet
	
	@fixstruct__NETVSC_PACKET@
	@@
	struct
	-_NETVSC_PACKET
	+hv_netvsc_packet
	
	@fixtypedef_PNETVSC_PACKET@
	typedef PNETVSC_PACKET;
	@@
	-PNETVSC_PACKET
	+struct hv_netvsc_packet*
	//</smpl>
</pre>
<A HREF=typedef/hv/storvsc/STORVSC_REQUEST.cocci>typedef/hv/storvsc/STORVSC_REQUEST.cocci</A>  -  Staging: hv: Remove typedef STORVSC_REQUEST and PSTORVSC_REQUEST
<pre>
	
	typedef STORVSC_REQUEST and PSTORVSC_REQUEST are removed and their
	usages are replace by the use of struct hv_storvsc_request and
	struct hv_storvsc_request * respectively.
	
	Here is the semantic patch generated to perform this transformation:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@rm_STORVSC_REQUEST@
	@@
	-typedef struct _STORVSC_REQUEST
	+struct hv_storvsc_request
	{...}
	-STORVSC_REQUEST
	;
	
	@rm_PSTORVSC_REQUEST@
	@@
	-typedef struct _STORVSC_REQUEST *PSTORVSC_REQUEST;
	+struct hv_storvsc_request;
	
	@fixtypedef_STORVSC_REQUEST@
	typedef STORVSC_REQUEST;
	@@
	-STORVSC_REQUEST
	+struct hv_storvsc_request
	
	@fixstruct__STORVSC_REQUEST@
	@@
	struct
	-_STORVSC_REQUEST
	+hv_storvsc_request
	
	@fixtypedef_PSTORVSC_REQUEST@
	typedef PSTORVSC_REQUEST;
	@@
	-PSTORVSC_REQUEST
	+struct hv_storvsc_request*
	//</smpl>
</pre>
<A HREF=ubi/category2b_add_volume.cocci>ubi/category2b_add_volume.cocci</A>  -  Bad IS_ERR test
<pre>
	----------------------------
	
	
	In case of error, the function add_volume returns an ERR pointer. The
	result of IS_ERR, which is supposed to be used in a test as it is, is
	here checked to be less than zero, which seems odd. We suggest to
	replace this test by a simple IS_ERR test.
	
	A simplified version of the semantic match that finds this problem is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@def0@
	expression x;
	position p0;
	@@
	x@p0 = add_volume(...)
	
	@protected@
	expression def0.x,E;
	position def0.p0;
	position p;
	statement S;
	@@
	x@p0
	... when != x = E
	if (!IS_ERR(x) && ...) {<... x@p ...>} else S
	
	@unprotected@
	expression def0.x,E;
	identifier fld;
	position def0.p0;
	position p != protected.p;
	@@
	x@p0
	... when != x = E
	* x@p->fld
	// </smpl>
	
</pre>
<A HREF=ubifs/category2a_kthread_create.cocci>ubifs/category2a_kthread_create.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function kthread_create returns an ERR pointer,
	but never returns a NULL pointer. So a NULL test that comes before an
	IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = kthread_create(...)
	... when != x = E
	* if (x == NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=ulfe/ulfe.cocci>ulfe/ulfe.cocci</A>  -  use list_for_each_entry
<pre>
	Use list_for_each_entry and perform some other induced simplifications.
	
	The semantic match that finds the opportunity for this reorganization is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	struct list_head *pos;
	struct list_head *head;
	statement S;
	@@
	
	*for (pos = (head)->next; pos != (head); pos = pos->next)
	S
	// </smpl>
	
</pre>
<A HREF=unsf/unsf.cocci>unsf/unsf.cocci</A>  -  Fix return value from an unsigned function
<pre>
	The function has an unsigned return type, but returns a negative constant
	to indicate an error condition.  Another error condition in the same
	function is indicated by returning 0, and indeed the only call to the
	function checks for 0 to detect errors, so the return of a negative value
	it converted to a return of 0.
	
	A sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	identifier f;
	constant C;
	@@
	
	 unsigned f(...)
	 { <+...
	*  return -C;
	 ...+> }
	// </smpl>
	
</pre>
<A HREF=unsf/unsf_ret0.cocci>unsf/unsf_ret0.cocci</A>  -  Fix return value from an unsigned function
<pre>
	The function has an unsigned return type, but returns a negative constant
	to indicate an error condition.  Another error condition in the same
	function is indicated by returning 0, and indeed the only call to the
	function checks for 0 to detect errors, so the return of a negative value
	it converted to a return of 0.
	
	A sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	identifier f;
	constant C;
	@@
	
	 unsigned f(...)
	 { <+...
	*  return -C;
	 ...+> }
	// </smpl>
	
</pre>
<A HREF=unused/unused.cocci>unused/unused.cocci</A>  -  remove unused variable
<pre>
	----------------------------
	
	
	The variable update_rx is initialized but never used otherwise.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	identifier i;
	constant C;
	@@
	
	(
	extern T i;
	|
	- T i;
	  <+... when != i
	- i = C;
	  ...+>
	)
	// </smpl>
	
</pre>
<A HREF=unused_err/unused_err.cocci>unused_err/unused_err.cocci</A>  -  Use available error codes
<pre>
	----------------------------
	
	
	Error codes are stored in err, but the return value is always 0.  Return
	err instead.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	local idexpression x;
	constant C;
	@@
	
	if (...) { ...
	  x = -C
	  ... when != x
	(
	  return <+...x...+>;
	|
	  return NULL;
	|
	  return;
	|
	* return ...;
	)
	}
	// </smpl>
	
</pre>
<A HREF=urb2/urb2.cocci>urb2/urb2.cocci</A>  -  Delete unnecessary call to usb_kill_urb
<pre>
	Since in each case nothing has been done with the recently allocated urb,
	it is not necessary to kill it before freeing it.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression urb;
	statement S;
	position p1,p2;
	@@
	
	urb = usb_alloc_urb@p1(...);
	... when != urb
	if (urb == NULL) S
	... when != urb
	usb_kill_urb@p2(urb);
	
	@other exists@
	position r.p1,r.p2;
	@@
	
	... when != usb_alloc_urb@p1(...)
	usb_kill_urb@p2(...);
	
	@depends on !other exists@
	expression urb;
	position r.p1,r.p2;
	@@
	
	urb = usb_alloc_urb@p1(...);
	...
	(
	-usb_kill_urb@p2(urb);
	+usb_free_urb(urb);
	... when != urb
	|
	-usb_kill_urb@p2(urb);
	)
	// </smpl>
	
</pre>
<A HREF=urb8/urb8.cocci>urb8/urb8.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=usb/category2a_back_device_reg.cocci>usb/category2a_back_device_reg.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function backlight_device_register returns an
	ERR pointer, but never returns a NULL pointer. So a NULL test that may
	come after a call to this function should be strengthened by an IS_ERR
	test.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = backlight_device_register(...)
	... when != x = E
	* if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=usb/category2a_isp1760_reg.cocci>usb/category2a_isp1760_reg.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function backlight_device_register returns an
	ERR pointer, but never returns a NULL pointer. So a NULL test that may
	come after a call to this function should be strengthened by an IS_ERR
	test.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = backlight_device_register(...)
	... when != x = E
	* if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=usbdata/usb_get_intfdata.cocci>usbdata/usb_get_intfdata.cocci</A>  -  Use usb_set/get_intfdata
<pre>
	----------------------------
	
	
	Use the USB functions usb_get_intfdata and usb_set_intfdata instead of
	dev_get_drvdata and dev_set_drvdata, respectively.
	
	The semantic patch that makes this change for the usb_get_intfdata case is
	as follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@header@
	@@
	
	#include <linux/usb.h>
	
	@same depends on header@
	position p;
	@@
	
	usb_get_intfdata@p(...) { ... }
	
	@depends on header@
	position _p!=same.p;
	identifier _f;
	struct usb_interface*intf;
	@@
	
	_f@_p(...) { <+...
	- dev_get_drvdata(&intf->dev)
	+ usb_get_intfdata(intf)
	...+> }
	// </smpl>
	
</pre>
<A HREF=usbdata/usb_set_intfdata.cocci>usbdata/usb_set_intfdata.cocci</A>  -  Use usb_set/get_intfdata
<pre>
	----------------------------
	
	
	Use the USB functions usb_get_intfdata and usb_set_intfdata instead of
	dev_get_drvdata and dev_set_drvdata, respectively.
	
	The semantic patch that makes this change for the usb_get_intfdata case is
	as follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@header@
	@@
	
	#include <linux/usb.h>
	
	@same depends on header@
	position p;
	@@
	
	usb_get_intfdata@p(...) { ... }
	
	@depends on header@
	position _p!=same.p;
	identifier _f;
	struct usb_interface*intf;
	@@
	
	_f@_p(...) { <+...
	- dev_get_drvdata(&intf->dev)
	+ usb_get_intfdata(intf)
	...+> }
	// </smpl>
	
</pre>
<A HREF=usbdir/end.cocci>usbdir/end.cocci</A>  -  Use usb_endpoint_dir_out
<pre>
	----------------------------
	
	
	Use the usb_endpoint_dir_out API function.  Note that the use of
	USB_TYPE_MASK in the original code is incorrect; it results in a test that
	is always false.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	struct usb_endpoint_descriptor *endpoint;
	expression E;
	@@
	
	- (endpoint->bEndpointAddress & E) == USB_DIR_OUT
	+ usb_endpoint_dir_out(endpoint)
	// </smpl>
	
</pre>
<A HREF=use_freed_specific/bad_kfree.cocci>use_freed_specific/bad_kfree.cocci</A>  -  Eliminate use after free
<pre>
	----------------------------
	
	
	__sa1111_remove always frees its argument, so the subsequent reference to
	sachip->saved_state represents a use after free.  __sa1111_remove does not
	appear to use the saved_state field, so the patch simply frees it first.
	
	A simplified version of the semantic patch that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E,E2;
	@@
	
	__sa1111_remove(E)
	...
	(
	  E = E2
	|
	* E
	)
	// </smpl>
	
</pre>
<A HREF=usefreed/bad_kfree.cocci>usefreed/bad_kfree.cocci</A>  -  Correct use after free
<pre>
	----------------------------
	
	
	Move the kfree after a reference to the freed structure.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e;
	identifier f;
	iterator I;
	statement S;
	@@
	
	*kfree(x);
	... when != &x
	    when != x = e
	    when != I(x,...) S
	*x->f
	// </smpl>
	
</pre>
<A HREF=usefreed/usefreed.cocci>usefreed/usefreed.cocci</A>  -  Correct use after free
<pre>
	----------------------------
	
	
	Move the kfree after a reference to the freed structure.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e;
	identifier f;
	iterator I;
	statement S;
	@@
	
	*kfree(x);
	... when != &x
	    when != x = e
	    when != I(x,...) S
	*x->f
	// </smpl>
	
</pre>
<A HREF=uselesskfree/uselesskfree.cocci>uselesskfree/uselesskfree.cocci</A>  -  Remove useless kfree
<pre>
	Remove useless kfree() and clean up code related to the removal.
	
	The semantic patch that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	position p1,p2;
	expression x;
	@@
	
	if (x@p1 == NULL) { ... kfree@p2(x); ... return ...; }
	
	@unchanged exists@
	position r.p1,r.p2;
	expression e <= r.x,x,e1;
	iterator I;
	statement S;
	@@
	
	if (x@p1 == NULL) { ... when != I(x,...) S
	                        when != e = e1
	                        when != e += e1
	                        when != e -= e1
	                        when != ++e
	                        when != --e
	                        when != e++
	                        when != e--
	                        when != &e
	   kfree@p2(x); ... return ...; }
	
	@ok depends on unchanged exists@
	position any r.p1;
	position r.p2;
	expression x;
	@@
	
	... when != true x@p1 == NULL
	kfree@p2(x);
	
	@depends on !ok && unchanged@
	position r.p2;
	expression x;
	@@
	
	*kfree@p2(x);
	// </smpl>
	
</pre>
<A HREF=video/patch.cocci>video/patch.cocci</A>  -  Use video_device_release rather than kfree
<pre>
	drivers/media/radio/radio-maestro.c
	
	
	Send to:
	v4l-dvb-maintainer@linuxtv.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/2] drivers/media/radio: Use video_device_release rather than kfree
	
	------------------------------------------------------
	
	
	The file drivers/media/video/videodev.c defines both video_device_alloc and
	video_device_release.  These are essentially just kzmalloc and kfree,
	respectively, but it seems better to use video_device_release, as done in
	the other media files, rather than kfree, in case the implementation some
	day changes.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2,x3;
	int ret;
	@@
	
	  T E;
	  ...
	* E = video_device_alloc(...);
	  if (E == NULL) S
	  ... when != video_device_release(...,(T1)E,...)
	      when != if (E != NULL) { ... video_device_release(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	  if (...) {
	    ... when != video_device_release(...,(T2)E,...)
	        when != if (E != NULL) { ... video_device_release(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=videobuf_dvb_get_frontend_return_null/videobuf_dvb_get_frontend_return_null.cocci>videobuf_dvb_get_frontend_return_null/videobuf_dvb_get_frontend_return_null.cocci</A>  -  Test if videobuf_dvb_get_frontend return NULL
<pre>
	Based on commit: e66131cee501ee720b7b58a4b87073b8fbaaaba6
	
	Not testing videobuf_dvb_get_frontend output may cause OOPS if it return
	NULL. This patch fixes this issue.
	
	The semantic patch that found this issue is(http://coccinelle.lip6.fr/):
	// <smpl>
	@@
	identifier i,a,b;
	statement S, S2;
	@@
	i = videobuf_dvb_get_frontend(...);
	... when != if (!i) S
	* if (i->a.b)
	S2
	// </smpl>
	
</pre>
<A HREF=warn/warn.cocci>warn/warn.cocci</A>  -  use WARN
<pre>
	Use WARN rather than printk followed by WARN_ON(1), for conciseness.
	
	A simplified version of the semantic patch that makes this transformation
	is as follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression list es;
	@@
	
	-printk(
	+WARN(1,
	  es);
	-WARN_ON(1);
	// </smpl>
	
</pre>
<A HREF=warn2/warn2.cocci>warn2/warn2.cocci</A>  -  drop if around WARN_ON
<pre>
	Just use WARN_ON rather than an if containing only WARN_ON(1).
	
	A simplified version of the semantic patch that makes this transformation
	is as follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e;
	@@
	- if (e) WARN_ON(1);
	+ WARN_ON(e);
	// </smpl>
	
</pre>
<A HREF=write2/write2.cocci>write2/write2.cocci</A>  -  delete double assignment
<pre>
	Delete successive assignments to the same location.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression i;
	@@
	
	*i = ...;
	 i = ...;
	// </smpl>
	
</pre>
<A HREF=wrongtest/wrongtest.cocci>wrongtest/wrongtest.cocci</A>  -  test the just-initialized value
<pre>
	Test the just-initialized value rather than some other one.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier x,y,f!={PTR_ERR,ERR_PTR,ERR_CAST};
	statement S;
	@@
	
	x = f(...);
	(
	if (\(x == NULL\|IS_ERR(x)\)) S
	|
	*if (\(y == NULL\|IS_ERR(y)\))
	 { ... when != x
	   return ...; }
	)
	// </smpl>
	
</pre>
<A HREF=x25/patch.cocci>x25/patch.cocci</A>  -  Add missing x25_neigh_put
<pre>
	net/x25/x25_forward.c
	
	
	Send to:
	eis@baty.hanse.de, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] net/x25: Add missing x25_neigh_put
	
	------------------------------------------------------
	
	
	The function x25_get_neigh increments a reference count.  At the point of
	the second goto out, the result of calling x25_get_neigh is only stored in
	a local variable, and thus no one outside the function will be able to
	decrease the reference count.  Thus, x25_neigh_put should be called before
	the return in this case.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2,x3;
	int ret;
	@@
	
	  T E;
	  ...
	* if ((E = x25_get_neigh(...)) == NULL)
	  S
	  ... when != x25_neigh_put(...,(T1)E,...)
	      when != if (E != NULL) { ... x25_neigh_put(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	  if (...) {
	    ... when != x25_neigh_put(...,(T2)E,...)
	        when != if (E != NULL) { ... x25_neigh_put(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=xand/xand.cocci>xand/xand.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=xfrm/category2a_xfrm_bundle_create.cocci>xfrm/category2a_xfrm_bundle_create.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function xfrm_bundle_create returns an ERR
	pointer, but never returns a NULL pointer. So a NULL test that comes
	after an IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x =  xfrm_bundle_create(...)
	... when != x = E
	*  if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=zercst/zercst.cocci>zercst/zercst.cocci</A>  -  adjust suspicious bit operation
<pre>
	IRQF_TRIGGER_HIGH is 0x00000004, so it seems that & was intended rather than |.
	
	This problem was found using Coccinelle (http://coccinelle.lip6.fr/).
	
</pre>
<A HREF=zero/rezero.cocci>zero/rezero.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
</body></html>
