<!DOCTYPE html><html><head><title>Coccinelle Semantic Patch Repository</title></head><body><center><h2>Coccinelle Semantic Patch Repository</h2></center><p>About Coccinelle: <a href=http://coccinelle.lip6.fr/>http://coccinelle.lip6.fr/</a><br>Mailing list: <a href=mailto:cocci@systeme.lip6.fr>cocci@systeme.lip6.fr</a> - <a href=https://systeme.lip6.fr/mailman/listinfo/cocci>https://systeme.lip6.fr/mailman/listinfo/cocci</a><p>
<A HREF=README.html>Short index</A><P>
<A HREF=9p/category2a_p9_client_walk.cocci>9p/category2a_p9_client_walk.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function p9_client_walk returns an ERR pointer,
	but never returns a NULL pointer. So a NULL test that comes after an
	IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = p9_client_walk(...)
	... when != x = E
	*  if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=9p/p9_client_walk.cocci>9p/p9_client_walk.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function p9_client_walk returns an ERR pointer,
	but never returns a NULL pointer. So a NULL test that comes after an
	IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = p9_client_walk(...)
	... when != x = E
	*  if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=aaci/category2a_aaci_init_card.cocci>aaci/category2a_aaci_init_card.cocci</A>  -  Bad NULL test
<pre>
	----------------------------
	
	
	In case of error, the function aaci_init_card returns an ERR pointer,
	but never returns a NULL pointer. We have noticed a bad NULL test,
	which comes after a call to this function. Rather than doing an IS_ERR
	test, we suggest to duplicate the label out: one label for the case
	where aaci_init_card returns a valid pointer, and another for the case
	where aaci_init_card returns an ERR pointer.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x =  aaci_init_card(...)
	... when != x = E
	*  if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=acl/patch.cocci>acl/patch.cocci</A>  -  Add missing call to posix_acl_release
<pre>
	fs/jffs2/acl.c
	
	Send to:
	dwmw2@infradead.org, linux-mtd@lists.infradead.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] fs/jffs2: Add missing call to posix_acl_release
	
	------------------------------------------------------
	
	
	posix_acl_clone does a memory allocation and sets a reference count, so
	posix_acl_release is needed afterwards to free it.
	
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	identifier E;
	expression E1, E2;
	int ret;
	statement S;
	@@
	
	  T E;
	  <+...
	(
	  E = \(posix_acl_clone\|posix_acl_alloc\|posix_acl_dup\)(...);
	  if (E == NULL) S
	|
	  if ((E = \(posix_acl_clone\|posix_acl_alloc\|posix_acl_dup\)(...)) == NULL) S
	)
	  ... when != E2 = E
	      when strict
	(
	  posix_acl_release(E);
	|
	  E1 = E;
	|
	+ posix_acl_release(E);
	  return;
	|
	+ posix_acl_release(E);
	  return ret;
	)
	  ...+>
	// </smpl>
	
</pre>
<A HREF=acpi/category2b_back_device_reg.cocci>acpi/category2b_back_device_reg.cocci</A>  -  dereference without an error test
<pre>
	----------------------------
	
	
	After a variable is assigned the result of backlight_device_register, an error
	test should be performed before a dereference. 
	
	A simplified version of the semantic match that finds this problem is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	// <smpl>
	@def0@
	expression x;
	position p0;
	@@
	
	x@p0 = backlight_device_register(...)
	
	@protected@
	expression def0.x,E;
	position def0.p0;
	position p;
	statement S;
	@@
	x@p0
	... when != x = E
	if (!IS_ERR(x) && ...) {<... x@p ...>} else S
	
	@unprotected@
	expression def0.x,E;
	identifier fld;
	position def0.p0;
	position p != protected.p;
	@@
	x@p0
	... when != x = E
	* x@p->fld
	// </smpl>
	
</pre>
<A HREF=acpid/acpi.cocci>acpid/acpi.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=after_netif/after_netif.cocci>after_netif/after_netif.cocci</A>  -  Fix use of skb after netif_rx
<pre>
	fpavlic@de.ibm.com, wangchen@cn.fujitsu.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 3/3] Fix use of skb after netif_rx
	
	------------------------------------------------------
	
	
	Recently, Wang Chen submitted a patch
	(d30f53aeb31d453a5230f526bea592af07944564) to move a call to netif_rx(skb)
	after a subsequent reference to skb, because netif_rx may call kfree_skb on
	its argument.  netif_rx_ni calls netif_rx, so the same problem occurs in
	the files below.
	
	I have left the updating of dev->last_rx after the calls to netif_rx_ni
	because it seems time dependent, but moved the other field updates before.
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression skb, e,e1;
	@@
	
	(
	 netif_rx(skb);
	|
	 netif_rx_ni(skb);
	)
	  ... when != skb = e
	(
	  skb = e1
	|
	* skb
	)
	// </smpl>
	
</pre>
<A HREF=after_netif/after_netif_modif.cocci>after_netif/after_netif_modif.cocci</A>  -  Fix use of skb after netif_rx
<pre>
	fpavlic@de.ibm.com, wangchen@cn.fujitsu.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 3/3] Fix use of skb after netif_rx
	
	------------------------------------------------------
	
	
	Recently, Wang Chen submitted a patch
	(d30f53aeb31d453a5230f526bea592af07944564) to move a call to netif_rx(skb)
	after a subsequent reference to skb, because netif_rx may call kfree_skb on
	its argument.  netif_rx_ni calls netif_rx, so the same problem occurs in
	the files below.
	
	I have left the updating of dev->last_rx after the calls to netif_rx_ni
	because it seems time dependent, but moved the other field updates before.
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression skb, e,e1;
	@@
	
	(
	 netif_rx(skb);
	|
	 netif_rx_ni(skb);
	)
	  ... when != skb = e
	(
	  skb = e1
	|
	* skb
	)
	// </smpl>
	
</pre>
<A HREF=alloc9/kmalloc9.cocci>alloc9/kmalloc9.cocci</A>  -  Eliminate memory leak
<pre>
	----------------------------
	
	
	This code is preceded by a call to btrfs_alloc_path, which allocates some
	memory.  There is some error handling code at the end of the function that
	frees it, that can be taken advantage of with a little ordering adjustment.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E;
	identifier f1;
	iterator I;
	@@
	
	x = btrfs_alloc_path(...);
	<... when != x
	     when != true (x == NULL || ...)
	     when != if (...) { <+...x...+> }
	     when != I (...) { <+...x...+> }
	(
	 x == NULL
	|
	 x == E
	|
	 x->f1
	)
	...>
	* return ...;
	// </smpl>
	
</pre>
<A HREF=alloc_cast/alloc_cast.cocci>alloc_cast/alloc_cast.cocci</A>  -  Drop memory allocation cast
<pre>
	Greg Kroah-Hartman <gregkh@suse.de>,devel@driverdev.osuosl.org,linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 3/5] drivers/staging: Drop memory allocation cast
	
	
	----------------------------
	
	
	Drop cast on the result of kmalloc and similar functions.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	@@
	
	- (T *)
	  (\(kmalloc\|kzalloc\|kcalloc\|kmem_cache_alloc\|kmem_cache_zalloc\|
	   kmem_cache_alloc_node\|kmalloc_node\|kzalloc_node\)(...))
	// </smpl>
	
</pre>
<A HREF=alloc_domain/easykmret.cocci>alloc_domain/easykmret.cocci</A>  -  add missing free_domain_mem
<pre>
	Add missing free_domain_mem on failure path after alloc_domain.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@km exists@
	local idexpression e;
	expression e1,e2,e3;
	type T,T1;
	identifier f;
	@@
	
	* e = alloc_domain(...)
	... when any
	    when != e = e1
	    when != e1 = (T)e
	    when != e1(...,(T)e,...)
	    when != &e->f
	if(...) { ... when != e2(...,(T1)e,...)
	                 when != e3 = e
	                 when forall
	(
	             return <+...e...+>;
	|
	*             return ...;
	) }
	// </smpl>
	
</pre>
<A HREF=alloc_etherdev/alloc.cocci>alloc_etherdev/alloc.cocci</A>  -  adjust error handling
<pre>
	----------------------------
	
	
	Converts a test in error handling code to a sequence of labels.
	
	The semantic match that found the problem is:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E,E1,E2;
	@@
	
	E = alloc_etherdev(...)
	... when != E = E1
	if (...) { ... free_netdev(E); ... return ...; }
	... when != E = E2
	(
	  if (...)
	   {
	   ... when != free_netdev(E);
	   return dev; }
	|
	* if (...)
	   {
	   ... when != free_netdev(E);
	   return ...; }
	|
	register_netdev(E)
	)
	
	// </smpl>
	
</pre>
<A HREF=alloc_tty/alloc_tty.cocci>alloc_tty/alloc_tty.cocci</A>  -  adjust call to put_tty_driver
<pre>
	----------------------------
	
	
	The call to put_tty_driver is out of place and is applied to the wrong
	argument.
	
	The function enclosing the patched code calls alloc_tty_driver and stores
	the result in drv.  Subsequently, there are two occurrences of error
	handling code, one making a goto to put_tty and one making a goto to
	stop_thread.  At the point of the first one the assignment hvc_driver = drv
	has not yet been executed, and from inspecting the rest of the file it
	seems that hvc_driver would be NULL.  Thus the current call to
	put_tty_driver is useless, and one applied to drv is needed.  The goto
	stop_thread is in the error handling code for a call to
	tty_register_driver, but the error cases in tty_register_driver do not free
	its argument, so it should be done here.  Thus, I have moved the put_tty
	label after the stop_thread label, so that put_tty_driver is called in both
	cases.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E,f;
	position p1,p2,p3;
	identifier l;
	statement S;
	@@
	
	x = alloc_tty_driver@p1(...)
	...
	if (x == NULL) S
	... when != E = x
	    when != put_tty_driver(x)
	goto@p2 l;
	... when != E = x
	    when != f(...,x,...)
	    when any
	(
	return \(0\|x\);
	|
	return@p3 ...;
	)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	p3 << r.p3;
	@@
	
	print \"%s: call on line %s not freed or saved before return on line %s via line %s\" % (p1[0].file,p1[0].line,p3[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=allocs/a2.cocci>allocs/a2.cocci</A>  -  add missing fput
<pre>
	----------------------------
	
	
	fget increments a reference count, so fput is needed to decrement it.  I
	have added a goto to the end of the function where there was already such a
	call.
	
	The semantic patch that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S;
	position p1,p2;
	identifier f;
	expression E;
	expression *ptr != NULL;
	@@
	
	 x@p1 = fget(...);
	 ... when != x
	 if (x == NULL) S
	 <... when != x
	      when != if (...) { <+...x...+> }
	  x->f = E
	 ...>
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	 return@p2 ...;
	)
	
	@ script:python @
	p1 << r.p1;
	p2 << r.p2;
	@@
	print \"%s: call: %s return: %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=arraysize/array.cocci>arraysize/array.cocci</A>  -  use ARRAY_SIZE
<pre>
	----------------------------
	
	
	ARRAY_SIZE is more concise to use when the size of an array is divided by
	the size of its type or the size of its first element.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@i@
	@@
	
	#include <linux/kernel.h>
	
	@depends on i using \"paren.iso\"@
	type T;
	T[] E;
	@@
	
	- (sizeof(E)/sizeof(T))
	+ ARRAY_SIZE(E)
	// </smpl>
	
</pre>
<A HREF=arref/arref.cocci>arref/arref.cocci</A>  -  adjust array index
<pre>
	Convert array index from the loop bound to the loop index.
	
	A simplified version of the semantic patch that fixes this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e1,e2,ar;
	@@
	
	for(e1 = 0; e1 < e2; e1++) { <...
	  ar[
	- e2
	+ e1
	  ]
	  ...> }
	// </smpl>
	
</pre>
<A HREF=asprintf/asprintf.cocci>asprintf/asprintf.cocci</A>  -  Use kasprintf
<pre>
	----------------------------
	
	
	kasprintf combines kmalloc and sprintf, and takes care of the size
	calculation itself.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression a,flag;
	expression list args;
	statement S;
	@@
	
	  a =
	-  \(kmalloc\|kzalloc\)(...,flag)
	+  kasprintf(flag,args)
	  <... when != a
	  if (a == NULL || ...) S
	  ...>
	- sprintf(a,args);
	// </smpl>
	
</pre>
<A HREF=atm/atm.cocci>atm/atm.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=auth/auth.cocci>auth/auth.cocci</A>  -  Adjust error handling code involving auth_domain_put
<pre>
	----------------------------
	
	
	Once clp is assigned, it never becomes NULL, so we can make a label for it
	in the error handling code.  Because the call to path_lookup follows the
	call to auth_domain_find, its error handling code should jump to this new
	label.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S;
	position p1,p2,p3;
	@@
	
	(
	if ((x = auth_domain_find@p1(...)) == NULL || ...) S
	|
	x = auth_domain_find@p1(...)
	... when != x
	if (x == NULL || ...) S
	)
	<...
	if@p3 (...) { ... when != auth_domain_put(x)
	                  when != if (x) { ... auth_domain_put(x); ...}
	    return@p2 ...;
	}
	...>
	(
	return x;
	|
	return 0;
	|
	x = E
	|
	E = x
	|
	auth_domain_put(x)
	)
	
	@exists@
	position r.p1,r.p2,r.p3;
	expression x;
	int ret != 0;
	statement S;
	@@
	
	* x = auth_domain_find@p1(...)
	  <...
	* if@p3 (...)
	  S
	  ...>
	* return@p2 \(NULL\|ret\);
	// </smpl>
	
</pre>
<A HREF=badand/badand.cocci>badand/badand.cocci</A>  -  Convert && to ||
<pre>
	----------------------------
	
	
	The pattern !E && !E->fld is nonsensical.  The patch below updates this
	according to the assumption that && should be ||.  But perhaps another
	solution was intended.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@disable and_comm@
	expression E;
	identifier fld;
	@@
	
	- !E && !E->fld
	+ !E || !E->fld
	// </smpl>
	
</pre>
<A HREF=badftest/badftest.cocci>badftest/badftest.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=badkm/badkm.cocci>badkm/badkm.cocci</A>  -  initialize return variable with error code
<pre>
	Typically, the return value desired for the failure of a memory allocation
	is -ENOMEM.  In this case, the return value is undesirably 0.
	
	The semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@@
	identifier ret,f;
	expression E,E1,x;
	@@
	
	(
	ret = f(...);
	if (ret != 0) { ... when forall
	  return ...; }
	|
	ret = 0
	)
	... when != ret = E
	    when any
	x = \(kmalloc\|kzalloc\|kcalloc\)(...);
	*if(x == NULL) {
	 ... when != ret = E1
	* return ret;
	}
	//</smpl>
	
</pre>
<A HREF=badkm2/badkm2.cocci>badkm2/badkm2.cocci</A>  -  ensure a consistent return value in error case
<pre>
	Typically, the return value desired for the failure of a function with an
	integer return value is a negative integer.  In these cases, the return
	value is sometimes a negative integer and sometimes 0, due to a subsequent
	initialization of the return variable within the loop.
	
	Resetting ret to 0 at the end of the function is not necessary because the
	return value of xc_patch is either 0 or a negative integer.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@r exists@
	identifier ret;
	position p;
	constant C;
	expression e1,e3,e4;
	statement S;
	@@
	
	ret = -C
	... when != ret = e3
	    when any
	if@p (...) S
	... when any
	if (\(ret != 0\|ret < 0\|ret > 0\) || ...) { ... return ...; }
	... when != ret = e3
	    when any
	*if@p (...)
	{
	  ... when != ret = e4
	  return ret;
	}
	//</smpl>
	
</pre>
<A HREF=badktest/badktest.cocci>badktest/badktest.cocci</A>  -  Correct NULL test
<pre>
	----------------------------
	
	
	Test the just-allocated value for NULL rather than some other value.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,y;
	statement S;
	@@
	
	x = \(kmalloc\|kcalloc\|kzalloc\)(...);
	(
	if ((x) == NULL) S
	|
	if (
	-   y
	+   x
	       == NULL)
	 S
	)
	// </smpl>
	
</pre>
<A HREF=badmsg/badmsg.cocci>badmsg/badmsg.cocci</A>  -  Return -ENOMEM on memory allocation failure
<pre>
	----------------------------
	
	
	In this code, 0 is returned on memory allocation failure, even though other
	failures return -ENOMEM or other similar values.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression ret;
	expression x,e1,e2,e3;
	@@
	
	ret = 0
	... when != ret = e1
	*x = \(kmalloc\|kcalloc\|kzalloc\)(...)
	... when != ret = e2
	if (x == NULL) { ... when != ret = e3
	  return ret;
	}
	// </smpl>
	
</pre>
<A HREF=badmsg3/badmsg3.cocci>badmsg3/badmsg3.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=badty/badty.cocci>badty/badty.cocci</A>  -  Correct the size argument to kmalloc
<pre>
	----------------------------
	
	
	In each case, the destination of the allocation has type struct **, so the
	elements of the array should have pointer type, not structure type.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@disable sizeof_type_expr@
	type T;
	T **x;
	@@
	
	  x =
	  <+...sizeof(
	- T
	+ *x
	  )...+>
	// </smpl>
	
</pre>
<A HREF=bitcall/bitcall.cocci>bitcall/bitcall.cocci</A>  -  convert & to &&
<pre>
	----------------------------
	
	
	The use of & to obtain a conjunction that evaluates both of its arguments
	seems unnecessarily tricky.
	
	The semantic match that found this code is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@ expression E1, E2; @@
	*  !E1 & !E2
	// </smpl>
	
</pre>
<A HREF=bits/notand.cocci>bits/notand.cocci</A>  -  Correct use of ! and &
<pre>
	----------------------------
	
	
	In commit e6bafba5b4765a5a252f1b8d31cbf6d2459da337, a bug was fixed that
	involved converting !x & y to !(x & y).  The code below shows the same
	pattern, and thus should perhaps be fixed in the same way.
	
	This is not tested and clearly changes the semantics, so it is only
	something to consider.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@ expression E1,E2; @@
	(
	  !E1 & !E2
	|
	- !E1 & E2
	+ !(E1 & E2)
	)
	// </smpl>
	
</pre>
<A HREF=bits2/notand.cocci>bits2/notand.cocci</A>  -  Correct use of ! and &
<pre>
	----------------------------
	
	
	ME_IO_SINGLE_TYPE_WRITE_NONBLOCKING and ME_IO_STREAM_CONFIG_WRAPAROUND both
	hanve 0 as the rightmost bit, and thus eg
	!flags & ME_IO_SINGLE_TYPE_WRITE_NONBLOCKING is always 0.
	I assume that !(flags & ME_IO_SINGLE_TYPE_WRITE_NONBLOCKING) and
	!(flags & ME_IO_STREAM_CONFIG_WRAPAROUND) were intended.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@ expression E; constant C; @@
	(
	  !E & !C
	|
	- !E & C
	+ !(E & C)
	)
	// </smpl>
	
</pre>
<A HREF=block_nil/retsall.cocci>block_nil/retsall.cocci</A>  -  use BLOCK_NIL
<pre>
	----------------------------
	
	
	Use BLOCK_NIL consistently rather than sometimes 0xffff and sometimes
	BLOCK_NIL.
	
	The semantic patch that finds this issue is below
	(http://www.emn.fr/x-info/coccinelle/).  On the other hand, the changes
	were made by hand, in part because drivers/mtd/inftlcore.c contains dead
	code that causes spatch to ignore a relevant function.  Specifically, the
	function INFTL_findwriteunit contains a do-while loop, but always takes a
	return that leaves the loop on the first iteration.
	
	// <smpl>
	@r exists@
	identifier f,C;
	@@
	
	f(...) { ... return C; }
	
	@s@
	identifier r.C;
	expression E;
	@@
	
	#define C E
	
	@@
	identifier r.f,r.C,I;
	expression s.E;
	@@
	
	f(...) {
	 <...
	(
	  I
	|
	- E
	+ C
	)
	 ...>
	}
	
	// </smpl>
	
</pre>
<A HREF=bo/bo.cocci>bo/bo.cocci</A>  -  trivial: use BUG_ON
<pre>
	Use BUG_ON(x) rather than if(x) BUG();
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@ identifier x; @@
	-if (x) BUG();
	+BUG_ON(x);
	
	@@ identifier x; @@
	-if (!x) BUG();
	+BUG_ON(!x);
	// </smpl>
	
</pre>
<A HREF=bond/short_timeout.cocci>bond/short_timeout.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=bootmem/bootmem.cocci>bootmem/bootmem.cocci</A>  -  Eliminate NULL test and memset after alloc_bootmem
<pre>
	akinobu.mita@gmail.com, geert@linux-m68k.org, zippel@linux-m68k.org, linux-m68k@lists.linux-m68k.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH 5/14] arch/m68k/mm/Sun3mmu.c: Eliminate NULL test and memset after alloc_bootmem
	
	------------------------------------------------------
	
	
	As noted by Akinobu Mita in patch b1fceac2b9e04d278316b2faddf276015fc06e3b,
	alloc_bootmem and related functions never return NULL and always return a
	zeroed region of memory.  Thus a NULL test or memset after calls to these
	functions is unnecessary.
	
	 arch/m68k/mm/sun3mmu.c |    1 -
	 1 file changed, 1 deletion(-)
	
	This was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	statement S;
	@@
	
	E = \(alloc_bootmem\|alloc_bootmem_low\|alloc_bootmem_pages\|alloc_bootmem_low_pages\)(...)
	... when != E
	(
	- BUG_ON (E == NULL);
	|
	- if (E == NULL) S
	)
	
	@@
	expression E,E1;
	@@
	
	E = \(alloc_bootmem\|alloc_bootmem_low\|alloc_bootmem_pages\|alloc_bootmem_low_pages\)(...)
	... when != E
	- memset(E,0,E1);
	// </smpl>
	
</pre>
<A HREF=bootmem2/bootmem.cocci>bootmem2/bootmem.cocci</A>  -  Eliminate NULL test and memset after alloc_bootmem
<pre>
	tony.luck@intel.com, linux-ia64@vger.kernel.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH 3/5] arch/ia64: Eliminate NULL test and memset after alloc_bootmem
	
	------------------------------------------------------
	
	
	As noted by Akinobu Mita in patch b1fceac2b9e04d278316b2faddf276015fc06e3b,
	alloc_bootmem and related functions never return NULL and always return a
	zeroed region of memory.  Thus a NULL test or memset after calls to these
	functions is unnecessary.
	
	This was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	statement S;
	@@
	
	E = \(alloc_bootmem\|alloc_bootmem_low\|alloc_bootmem_pages\|alloc_bootmem_low_pages\|alloc_bootmem_node\|alloc_bootmem_low_pages_node\|alloc_bootmem_pages_node\)(...)
	... when != E
	(
	- BUG_ON (E == NULL);
	|
	- if (E == NULL) S
	)
	
	@@
	expression E,E1;
	@@
	
	E = \(alloc_bootmem\|alloc_bootmem_low\|alloc_bootmem_pages\|alloc_bootmem_low_pages\|alloc_bootmem_node\|alloc_bootmem_low_pages_node\|alloc_bootmem_pages_node\)(...)
	... when != E
	- memset(E,0,E1);
	// </smpl>
	
</pre>
<A HREF=bss/sp1094.cocci>bss/sp1094.cocci</A>  -  Add missing call to cfg80211_put_bss
<pre>
	A call to cfg80211_get_bss hould be accompanied by a call to
	cfg80211_put_bss in error-handling code.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct cfg80211_bss * x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = cfg80211_get_bss@p1(...)
	...  when != x = rr
	     when != cfg80211_put_bss(x,...)
	     when != if (...) { ... cfg80211_put_bss(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != cfg80211_put_bss(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"cfg80211_get_bss\",p1)
	cocci.print_secs(\"return\",p2)
	
	// </smpl>
	
</pre>
<A HREF=btrfs/btrfs.cocci>btrfs/btrfs.cocci</A>  -  Add missing btrfs_free_path
<pre>
	Btrfs_alloc_path should be matched with btrfs_free_path in error-handling code.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct btrfs_path * x;
	expression ra,rb;
	position p1,p2;
	@@
	
	x = btrfs_alloc_path@p1(...)
	...  when != btrfs_free_path(x,...)
	     when != if (...) { ... btrfs_free_path(x,...) ...}
	     when != x = ra
	if(...) { ... when != x = rb
	     when forall
	     when != btrfs_free_path(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"alloc\",p1)
	cocci.print_secs(\"return\",p2)
	// </smpl>
	
</pre>
<A HREF=bugon/newbugon.cocci>bugon/newbugon.cocci</A>  -  Use BUG_ON
<pre>
	----------------------------
	
	
	if (...) BUG(); should be replaced with BUG_ON(...) when the test has no
	side-effects to allow a definition of BUG_ON that drops the code completely.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@ disable unlikely @ expression E,f; @@
	
	(
	  if (<... f(...) ...>) { BUG(); }
	|
	- if (unlikely(E)) { BUG(); }
	+ BUG_ON(E);
	)
	
	@@ expression E,f; @@
	
	(
	  if (<... f(...) ...>) { BUG(); }
	|
	- if (E) { BUG(); }
	+ BUG_ON(E);
	)
	// </smpl>
	
</pre>
<A HREF=cache/cache.cocci>cache/cache.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=call_kern1/call_kern1.cocci>call_kern1/call_kern1.cocci</A>  -  Use GFP_ATOMIC when a lock is held
<pre>
	----------------------------
	
	
	The function adpt_i2o_post_wait is called from several places, in some of
	which, such as adpt_abort, a lock may be held.
	
	The functions adpt_i2o_reparse_lct and adpt_i2o_lct_get are called from
	several places, including adpt_rescan where a lock may be held.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@gfp exists@
	identifier fn;
	position p;
	@@
	
	fn(...) {
	 ... when != spin_unlock_irqrestore
	     when any
	 GFP_KERNEL@p
	 ... when any
	}
	
	@locked@
	identifier gfp.fn;
	@@
	
	spin_lock_irqsave(...)
	...  when != spin_unlock_irqrestore
	fn(...)
	
	@depends on locked@
	position gfp.p;
	@@
	
	- GFP_KERNEL@p
	+ GFP_ATOMIC
	// </smpl>
	
</pre>
<A HREF=call_kern3/call_kern3.cocci>call_kern3/call_kern3.cocci</A>  -  Use GFP_ATOMIC when a lock is held
<pre>
	----------------------------
	
	
	The containing function is called from several places.  At one of them, in
	the function __sigp_stop, the spin lock &fi->lock is held.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@gfp exists@
	identifier fn;
	position p;
	@@
	
	fn(...) {
	... when != spin_unlock
	    when any
	  GFP_KERNEL@p
	 ... when any
	}
	
	@locked@
	identifier gfp.fn;
	@@
	
	spin_lock(...)
	... when != spin_unlock
	fn(...)
	
	@depends on locked@
	position gfp.p;
	@@
	
	- GFP_KERNEL@p
	+ GFP_ATOMIC
	// </smpl>
	
</pre>
<A HREF=capi/capi.cocci>capi/capi.cocci</A>  -  Adjust error handling code involving capi_ctr_put
<pre>
	----------------------------
	
	
	After calling capi_ctr_get, error handling code should call
	capi_ctr_put.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S;
	position p1,p2,p3;
	@@
	
	(
	if ((x = capi_ctr_get@p1(...)) == NULL || ...) S
	|
	x = capi_ctr_get@p1(...)
	... when != x
	if (x == NULL || ...) S
	)
	<...
	if@p3 (...) { ... when != capi_ctr_put(x)
	                  when != if (x) { ... capi_ctr_put(x); ...}
	    return@p2 ...;
	}
	...>
	(
	return x;
	|
	return 0;
	|
	x = E
	|
	E = x
	|
	capi_ctr_put(x)
	)
	
	@exists@
	position r.p1,r.p2,r.p3;
	expression x;
	int ret != 0;
	statement S;
	@@
	
	* x = capi_ctr_get@p1(...)
	  <...
	* if@p3 (...)
	  S
	  ...>
	* return@p2 \(NULL\|ret\);
	// </smpl>
	
</pre>
<A HREF=clkput/clkput.cocci>clkput/clkput.cocci</A>  -  add missing clk_put
<pre>
	Add a label before the call to clk_put and jump to that in the error
	handling code that occurs after the call to clk_get has succeeded.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression e1,e2;
	statement S;
	@@
	
	e1 = clk_get@p1(...);
	... when != e1 = e2
	    when != clk_put(e1)
	    when any
	if (...) { ... when != clk_put(e1)
	               when != if (...) { ... clk_put(e1) ... }
	* return@p3 ...;
	 } else S
	// </smpl>
	
</pre>
<A HREF=consts/consts.cocci>consts/consts.cocci</A>  -  use the constant InterlaceMode
<pre>
	----------------------------
	
	
	Use the constant InterlaceMode rather than the magic number 0x0080.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	type T;
	T E;
	identifier fld;
	identifier c;
	@@
	
	E->fld & c
	
	@s@
	constant C;
	identifier r.c;
	@@
	
	#define c C
	
	@@
	r.T E;
	identifier r.fld;
	identifier r.c;
	constant s.C;
	@@
	
	 E->fld &
	- C
	+ c
	// </smpl>
	
</pre>
<A HREF=countptr/countptr.cocci>countptr/countptr.cocci</A>  -  remove exceptional & on function name
<pre>
	----------------------------
	
	
	In this file, function names are otherwise used as pointers without &.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier f;
	@@
	
	f(...) { ... }
	
	@@
	identifier r.f;
	@@
	
	- &f
	+ f
	// </smpl>
	
</pre>
<A HREF=cpu/cpu.cocci>cpu/cpu.cocci</A>  -  Adjust error handling code involving cpufreq_cpu_put
<pre>
	----------------------------
	
	
	After calling cpufreq_cpu_get, error handling code should call
	cpufreq_cpu_put.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S;
	position p1,p2,p3;
	@@
	
	(
	if ((x = cpufreq_cpu_get@p1(...)) == NULL || ...) S
	|
	x = cpufreq_cpu_get@p1(...)
	... when != x
	if (x == NULL || ...) S
	)
	<...
	if@p3 (...) { ... when != cpufreq_cpu_put(x)
	                  when != if (x) { ... cpufreq_cpu_put(x); ...}
	    return@p2 ...;
	}
	...>
	(
	return x;
	|
	return 0;
	|
	x = E
	|
	E = x
	|
	cpufreq_cpu_put(x)
	)
	
	@exists@
	position r.p1,r.p2,r.p3;
	expression x;
	int ret != 0;
	statement S;
	@@
	
	* x = cpufreq_cpu_get@p1(...)
	  <...
	* if@p3 (...)
	  S
	  ...>
	* return@p2 \(NULL\|ret\);
	// </smpl>
	
</pre>
<A HREF=cpu_mask/cpu_mask.cocci>cpu_mask/cpu_mask.cocci</A>  -  Use set_cpus_allowed_ptr
<pre>
	----------------------------
	
	
	Use set_cpus_allowed_ptr rather than set_cpus_allowed.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E1,E2;
	@@
	
	- set_cpus_allowed(E1, cpumask_of_cpu(E2))
	+ set_cpus_allowed_ptr(E1, cpumask_of(E2))
	
	@@
	expression E;
	identifier I;
	@@
	
	- set_cpus_allowed(E, I)
	+ set_cpus_allowed_ptr(E, &I)
	// </smpl>
	
</pre>
<A HREF=cpufreq/patch.cocci>cpufreq/patch.cocci</A>  -  Add calls to cpufreq_cpu_put
<pre>
	drivers/cpufreq/cpufreq.c
	
	
	Send to:
	davej@codemonkey.org.uk, cpufreq@lists.linux.org.uk, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/cpufreq: Add calls to cpufreq_cpu_put
	
	------------------------------------------------------
	
	
	A call to cpufreq_cpu_get should be matched by a call to cpufreq_cpu_put.
	
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	identifier E;
	expression E1, E2;
	int ret;
	statement S;
	@@
	
	  T E;
	  ... when any
	(
	  E = cpufreq_cpu_get(...);
	  if (E == NULL) S
	|
	  if ((E = cpufreq_cpu_get(...)) == NULL) S
	)
	  ... when != E2 = E
	      when strict
	(
	  cpufreq_cpu_put(E);
	|
	  E1 = E;
	|
	+ cpufreq_cpu_put(E);
	  return;
	|
	+ cpufreq_cpu_put(E);
	  return ret;
	)
	// </smpl>
	
</pre>
<A HREF=cris/mutex2.cocci>cris/mutex2.cocci</A>  -  Use mutex_unlock rather than spin_unlock
<pre>
	----------------------------
	
	
	It looks at least odd to apply spin_unlock to a mutex.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@def@
	declarer DEFINE_MUTEX;
	identifier m;
	@@
	
	DEFINE_MUTEX(m);
	
	@@
	identifier def.m;
	@@
	
	(
	- spin_lock(&m)
	+ mutex_lock(&m)
	|
	- spin_unlock(&m)
	+ mutex_unlock(&m)
	)
	// </smpl>
	
</pre>
<A HREF=crypto/crypto.cocci>crypto/crypto.cocci</A>  -  add NULL test around call to crypto_free_hash
<pre>
	crypto_free_hash calls the function crypto_hash_tfm and then
	crypto_free_tfm on the result.  crypto_free_tfm calls crypto_destroy_tfm,
	which tests this result for NULL and then dereferences it.  crypto_hash_tfm
	returns &tfm->base where tfm is its argument.  base is actually the first
	and only field of a crypto_hash-typed structure, so perhaps one can rely on
	it to return NULL for a NULL value of tfm.  But most calls to
	crypto_hash_tfm where the argument might be NULL don't rely on this
	property and test for NULL explicitly.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@safe@
	position p;
	expression x;
	@@
	
	if (x) { <+... crypto_free_hash@p(x) ...+> }
	
	@@
	expression x;
	position p!=safe.p;
	@@
	
	*x = NULL
	...
	*crypto_free_hash@p(x)
	// </smpl>
	
</pre>
<A HREF=cstptr/cstptr.cocci>cstptr/cstptr.cocci</A>  -  Move call to PTR_ERR after reassignment
<pre>
	PTR_ERR should be called before its argument is cleared.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1;
	constant c;
	@@
	
	*e = c
	... when != e = e1
	    when != &e
	    when != true IS_ERR(e)
	*PTR_ERR(e)
	// </smpl>
	
	Reported-by: Josh Triplett <josh@joshtriplett.org>
</pre>
<A HREF=ctu/ctu.cocci>ctu/ctu.cocci</A>  -  initialize all fields
<pre>
	The c32 structure is allocated on the stack and its idx field is not
	initialized before copying it to user level.  This patch takes the value
	from the result of the ioctl, as done for the other fields.
	
</pre>
<A HREF=da/da.cocci>da/da.cocci</A>  -  delete double assignment
<pre>
	Delete successive assignments to the same location.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression i;
	@@
	
	*i = ...;
	 i = ...;
	// </smpl>
	
</pre>
<A HREF=dall/dall.cocci>dall/dall.cocci</A>  -  use devm_ functions consistently
<pre>
	Use devm_kzalloc for all calls to kzalloc and not just the first.  Use devm
	functions for other allocations as well.
	
	Move the call to platform_get_resource(pdev, IORESOURCE_MEM, 0) closer to
	where its result is passed to devm_request_and_ioremap to make the lack of
	need for a NULL test more evident.
	
	The semantic match that finds the inconsistency is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	*devm_kzalloc(...)
	...
	*kzalloc(...)
	// </smpl>
	
</pre>
<A HREF=dangling/dangling.cocci>dangling/dangling.cocci</A>  -  Remove potential for use after free
<pre>
	In each function, the value apcm is stored in the private_data field of
	runtime.  At the same time the function ct_atc_pcm_free_substream is stored
	in the private_free field of the same structure.  ct_atc_pcm_free_substream
	dereferences and ultimately frees the value in the private_data field.  But
	each function can exit in an error case with apcm having been freed, in
	which case a subsequent call to the private_free function would perform a
	dereference after free.  On the other hand, if the private_free field is
	not initialized, it is NULL, and not invoked (see snd_pcm_detach_substream
	in sound/core/pcm.c).  To avoid the introduction of a dangling pointer, the
	initializations of the private_data and private_free fields are moved to
	the end of the function, past any possible free of apcm.  This is safe
	because the previous calls to snd_pcm_hw_constraint_integer and
	snd_pcm_hw_constraint_minmax, which take runtime as an argument, do not
	refer to either of these fields.
	
	In each function, there is one error case where apcm needs to be freed, and
	a call to kfree is added.
	
	The sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1,e2,e3;
	identifier f,free1,free2;
	expression a;
	@@
	
	*e->f = a
	... when != e->f = e1
	    when any
	if (...) {
	  ... when != free1(...,e,...)
	      when != e->f = e2
	* kfree(a)
	  ... when != free2(...,e,...)
	      when != e->f = e3
	}
	// </smpl>
	
</pre>
<A HREF=depspin/sl.cocci>depspin/sl.cocci</A>  -  Use DEFINE_SPINLOCK
<pre>
	----------------------------
	
	
	SPIN_LOCK_UNLOCKED is deprecated.  The following makes the change suggested
	in Documentation/spinlocks.txt
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	declarer name DEFINE_SPINLOCK;
	identifier xxx_lock;
	@@
	
	- spinlock_t xxx_lock = SPIN_LOCK_UNLOCKED;
	+ DEFINE_SPINLOCK(xxx_lock);
	// </smpl>
	
</pre>
<A HREF=derefnull/isnull.cocci>derefnull/isnull.cocci</A>  -  remove null pointer dereference
<pre>
	----------------------------
	
	
	If dev is NULL, it is not possible to access its name field.  So I have
	simply modified the error message to drop the printing of the name field.
	
	
	This problem was found using the following semantic match
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E, E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	* if (E == NULL)
	{
	  ... when != if (E == NULL) S1 else S2
	      when != E = E1
	* E->f
	  ... when any
	  return ...;
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=devm2/devm2i.cocci>devm2/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses devm_kzalloc, devm_request_mem_region and
	devm_ioremap for data that is allocated in the probe function of a platform
	device and is only freed in the remove function.
	
</pre>
<A HREF=devm2a/devm2i.cocci>devm2a/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2b/devm2i.cocci>devm2b/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2i_0729/devm2i.cocci>devm2i_0729/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2i_0729/request_and_ioremap.cocci>devm2i_0729/request_and_ioremap.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2i_0730/devm2i.cocci>devm2i_0730/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2i_0730/request_and_ioremap.cocci>devm2i_0730/request_and_ioremap.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
</pre>
<A HREF=devm2i_0731/devm2i.cocci>devm2i_0731/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	In two cases, the original memory allocation function was kmalloc, which
	has been changed to a zeroing allocation to benefit from the devm function.
	
</pre>
<A HREF=devm2i_0731/request_and_ioremap.cocci>devm2i_0731/request_and_ioremap.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	In two cases, the original memory allocation function was kmalloc, which
	has been changed to a zeroing allocation to benefit from the devm function.
	
</pre>
<A HREF=devm2i_aug25/devm2i.cocci>devm2i_aug25/devm2i.cocci</A>  -  au1550: use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	The initial call to platform_get_resource is moved down to the introduced
	call to devm_request_and_ioremap thta uses its result.
	
</pre>
<A HREF=devm2i_aug25/request_and_ioremap.cocci>devm2i_aug25/request_and_ioremap.cocci</A>  -  au1550: use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	The initial call to platform_get_resource is moved down to the introduced
	call to devm_request_and_ioremap thta uses its result.
	
</pre>
<A HREF=devm4/devm4.cocci>devm4/devm4.cocci</A>  -  drop iounmap for devm_ allocated data
<pre>
	Data allocated with devm_ioremap or devm_ioremap_nocache should not be
	freed using iounmap, because doing so causes a dangling pointer, and a
	subsequent double free.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression x;
	@@
	(
	 x = devm_ioremap(...)
	|
	 x = devm_ioremap_nocache(...)
	)
	
	@@
	expression r.x;
	@@
	* iounmap(x)
	// </smpl>
	
</pre>
<A HREF=devm6/devm6.cocci>devm6/devm6.cocci</A>  -  use devm_request_and_ioremap
<pre>
	Reimplement a call to devm_request_mem_region followed by a call to ioremap
	or ioremap_nocache by a call to devm_request_and_ioremap.
	
	The variable res_size is then no longer needed.
	
	The semantic patch that makes this transformation is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@nm@
	expression myname;
	identifier i;
	@@
	
	struct platform_driver i = { .driver = { .name = myname } };
	
	@@
	expression dev,res,size;
	expression nm.myname;
	@@
	
	-if (!devm_request_mem_region(dev, res->start, size,
	-                              \(res->name\|dev_name(dev)\|myname\))) {
	-   ...
	-   return ...;
	-}
	... when != res->start
	(
	-devm_ioremap(dev,res->start,size)
	+devm_request_and_ioremap(dev,res)
	|
	-devm_ioremap_nocache(dev,res->start,size)
	+devm_request_and_ioremap(dev,res)
	)
	... when any
	    when != res->start
	// </smpl>
	
</pre>
<A HREF=devname/devname.cocci>devname/devname.cocci</A>  -  eliminate NULL dereference
<pre>
	----------------------------
	
	
	dev_name always dereferences its argument, so it should not be called if
	the argument is NULL.  The function indeed later tests the argument for
	being NULL.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression dev,E;
	@@
	
	*dev_name(dev)
	... when != dev = E
	(
	*dev == NULL
	|
	*dev != NULL
	)
	// </smpl>
	
</pre>
<A HREF=diou/diou.cocci>diou/diou.cocci</A>  -  drop kfree of devm_kzalloc's data
<pre>
	Using kfree to free data allocated with devm_kzalloc causes double frees.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x;
	@@
	
	x = devm_kzalloc(...)
	...
	?-kfree(x);
	// </smpl>
	
</pre>
<A HREF=diou2/diou.cocci>diou2/diou.cocci</A>  -  drop frees of devm allocated data
<pre>
	devm_kfree and devm_iounmap should not have to be explicitly used.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,d;
	@@
	
	x = devm_kzalloc(...)
	...
	?-devm_kfree(d,x);
	// </smpl>
	
</pre>
<A HREF=diou3/devm3.cocci>diou3/devm3.cocci</A>  -  drop frees of devm_ alloc'd data
<pre>
	devm free functions should not have to be explicitly used.
	
	A semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	(
	* devm_kfree(...);
	|
	* devm_free_irq(...);
	|
	* devm_iounmap(...);
	|
	* devm_release_region(...);
	|
	* devm_release_mem_region(...);
	)
	// </smpl>
	
</pre>
<A HREF=dma/set_dma_mode_1.cocci>dma/set_dma_mode_1.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=double_call/dc.cocci>double_call/dc.cocci</A>  -  Eliminate useless code
<pre>
	----------------------------
	
	
	The variable qdev is initialized twice to the same (side effect-free)
	expression.  Drop one initialization.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@forall@
	idexpression *x;
	identifier f!=ERR_PTR;
	@@
	
	x = f(...)
	... when != x
	(
	x = f(...,<+...x...+>,...)
	|
	* x = f(...)
	)
	// </smpl>
	
</pre>
<A HREF=double_lock/double_lock.cocci>double_lock/double_lock.cocci</A>  -  Eliminate a double lock
<pre>
	----------------------------
	
	
	The path around the loop ends with the lock held, so the call to mutex_lock
	is moved before the beginning of the loop.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@locked@
	expression E1;
	position p;
	@@
	
	read_lock(E1@p,...);
	
	@r exists@
	expression x <= locked.E1;
	expression locked.E1;
	expression E2;
	identifier lock;
	position locked.p,p1,p2;
	@@
	
	*lock@p1 (E1@p,...);
	... when != E1
	    when != \(x = E2\|&x\)
	*lock@p2 (E1,...);
	// </smpl>
	
</pre>
<A HREF=double_null/double_null.cocci>double_null/double_null.cocci</A>  -  Correct NULL test
<pre>
	----------------------------
	
	
	dev was tested just above, so drop the second test.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression *x;
	expression e;
	identifier l;
	@@
	
	if (x == NULL || ...) {
	    ... when forall
	    return ...; }
	... when != goto l;
	    when != x = e
	    when != &x
	*x == NULL
	// </smpl>
	
</pre>
<A HREF=double_test/double_test.cocci>double_test/double_test.cocci</A>  -  introduce missing initialization
<pre>
	The result of one call to a function is tested, and then at the second call
	to the same function, the previous result, and not the current result, is
	tested again.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression ret;
	identifier f;
	statement S1,S2;
	@@
	
	*ret = f(...);
	if (\(ret != 0\|ret < 0\|ret == NULL\)) S1
	... when any
	*f(...);
	if (\(ret != 0\|ret < 0\|ret == NULL\)) S2
	// </smpl>
	
</pre>
<A HREF=doublefree/frees.cocci>doublefree/frees.cocci</A>  -  Eliminate double kfree
<pre>
	jbarnes@virtuousgeek.org, linux-pci@vger.kernel.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH 1/2] Eliminate double kfree
	
	------------------------------------------------------
	
	
	The destination of goto error also does a kfree(g_iommus), so it is not
	correct to do one here.
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r1@
	expression E;
	position p1,p2;
	@@
	
	kfree@p1(E);
	...
	kfree@p2(E);
	
	@subexps@
	expression E1;
	position r1.p1,p;
	@@
	
	kfree@p1(<+... E1@p ...+>);
	
	@recollect@
	position subexps.p;
	expression E1;
	@@
	
	E1@p
	
	@doublekfree@
	position r1.p1,r1.p2;
	expression recollect.E1,E2,E;
	position p;
	statement S;
	@@
	
	kfree@p1(E);
	<+... E1@p=E2 ...+> // the actual semantic match contains other assignments
	kfree@p2(E);
	
	@notdoublekfree@
	position r1.p1,r1.p2;
	position any doublekfree.p;
	expression E,E1,E2;
	@@
	
	* kfree@p1(E);
	... when != E1@p
	    when != E1@p = E2 // needed to match a variable decl
	* kfree@p2(E);
	// </smpl>
	
</pre>
<A HREF=doubleinit/doubleinit.cocci>doubleinit/doubleinit.cocci</A>  -  remove duplicate structure field initialization
<pre>
	----------------------------
	
	
	The definition of uml_netdev_ops has initializations of a local function
	and eth_mac_addr for its ndo_set_mac_address field.  This change uses only
	the local function.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier I, s, fld;
	position p0,p;
	expression E;
	@@
	
	struct I s =@p0 { ... .fld@p = E, ...};
	
	@s@
	identifier I, s, r.fld;
	position r.p0,p;
	expression E;
	@@
	
	struct I s =@p0 { ... .fld@p = E, ...};
	
	@script:python@
	p0 << r.p0;
	fld << r.fld;
	ps << s.p;
	pr << r.p;
	@@
	
	if int(ps[0].line)!=int(pr[0].line) or int(ps[0].column)!=int(pr[0].column):
	  cocci.print_main(fld,p0)
	// </smpl>
	
</pre>
<A HREF=doublermr/doublermr.cocci>doublermr/doublermr.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=doubletest/doubletest.cocci>doubletest/doubletest.cocci</A>  -  Remove double test
<pre>
	The nic_type field is compared to athr_l2c twice.
	
	The sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@expression@
	expression E;
	@@
	
	(
	* E
	  || ... || E
	|
	* E
	  && ... && E
	)
	// </smpl>
	
</pre>
<A HREF=doubletest_high/doubletest_highconfidence.cocci>doubletest_high/doubletest_highconfidence.cocci</A>  -  adjust double test
<pre>
	Rewrite a duplicated test to test the correct value
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E;
	@@
	
	(
	* E
	  || ... || E
	|
	* E
	  && ... && E
	)
	// </smpl>
	
</pre>
<A HREF=drop_continue/cont.cocci>drop_continue/cont.cocci</A>  -  Drop unnecessary continue
<pre>
	Send to:
	perex@suse.cz, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 4/4] sound/pci: Drop unnecessary continue
	
	
	------------------------------------------------------
	
	
	Continue is not needed at the bottom of a loop.
	
	The semantic patch implementing this change is as follows:
	
	@@
	@@
	
	for (...;...;...) {
	  ...
	  if (...) {
	    ...
	-   continue;
	  }
	}
	
</pre>
<A HREF=drvdata/drvdata.cocci>drvdata/drvdata.cocci</A>  -  use dev_get_drvdata
<pre>
	----------------------------
	
	
	Eliminate direct accesses to the driver_data field.
	cf 82ab13b26f15f49be45f15ccc96bfa0b81dfd015
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct device *dev;
	expression E;
	type T;
	@@
	
	- dev->driver_data = (T)E
	+ dev_set_drvdata(dev, E)
	
	@@
	struct device *dev;
	type T;
	@@
	
	- (T)dev->driver_data
	+ dev_get_drvdata(dev)
	// </smpl>
	
</pre>
<A HREF=dst/dst.cocci>dst/dst.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=enter/enter.cocci>enter/enter.cocci</A>  -  Convert func_enter to func_exit
<pre>
	Convert calls to func_enter on leaving a function to func_exit.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	- func_enter();
	+ func_exit();
	  return...;
	// </smpl>
	
</pre>
<A HREF=epd/epd.cocci>epd/epd.cocci</A>  -  use USB API functions rather than constants
<pre>
	----------------------------
	
	This set of patches introduces calls to the following functions:
	
	usb_endpoint_dir_in(epd)
	usb_endpoint_dir_out(epd)
	usb_endpoint_is_bulk_in(epd)
	usb_endpoint_is_bulk_out(epd)
	usb_endpoint_is_int_in(epd)
	usb_endpoint_is_int_out(epd)
	usb_endpoint_num(epd)
	usb_endpoint_type(epd)
	usb_endpoint_xfer_bulk(epd)
	usb_endpoint_xfer_control(epd)
	usb_endpoint_xfer_int(epd)
	usb_endpoint_xfer_isoc(epd)
	
	In some cases, introducing one of these functions is not possible, and it
	just replaces an explicit integer value by one of the following constants:
	
	USB_ENDPOINT_XFER_BULK
	USB_ENDPOINT_XFER_CONTROL
	USB_ENDPOINT_XFER_INT
	USB_ENDPOINT_XFER_ISOC
	
	The complete semantic patch that makes these changes is below
	(http://www.emn.fr/x-info/coccinelle/).  Most of the transformations are
	straightforward, based on the definition of the added function.  A few are
	slightly less straightforward, as follows:
	
	1. Normally, the direction of an endpoint is determined by extracting the
	direction information and comparing it to USB_DIR_IN or USB_DIR_OUT (rules
	r5 and r8).  But the mask for extracting the direction information is the
	same as USB_DIR_IN, so it is fairly common to just perform an & with
	USB_DIR_IN.  When the result is used as a test expression, the effect is
	the same as the normal case, so I have used usb_endpoint_dir_in in these
	cases as well (rules r6 and r7).
	
	2. Normally, the direction of an endpoint is compared in a positive way to
	USB_DIR_IN or USB_DIR_OUT, corresponding to the definitions of
	usb_endpoint_dir_in and usb_endpoint_dir_out, respectively.  Sometimes,
	however, it is compared in a negative way.  Since the mask for extracting
	the direction information has only one bit that is non-zero, there are only
	two possible values, and an endpoint that is not in must be out, and vice
	versa.  This is taken case of by rules r9 and r10.
	
	There is one case where the field bEndpointAddress is bit-anded with a
	constant that is not one of the constants considered here.  This is noted
	in the log of the patch ([6/13]) where it occurs.
	
	// <smpl>
	@r1@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_CONTROL\|0\))
	+ usb_endpoint_xfer_control(epd)
	
	@r2@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_ISOC\|1\))
	+ usb_endpoint_xfer_isoc(epd)
	
	@r3@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_BULK\|2\))
	+ usb_endpoint_xfer_bulk(epd)
	
	@r4@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_INT\|3\))
	+ usb_endpoint_xfer_int(epd)
	
	@r5@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) ==
	-  \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_in(epd)
	
	// Since USB_ENDPOINT_DIR_MASK selects only one bit and USB_DIR_IN is nonzero,
	// anding with USB_DIR_IN in a test expression has the same effect as the above
	@r6 expression@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_in(epd)
	  || ...
	
	// The same comment applies here
	@r7 expression@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_in(epd)
	  && ...
	
	@r8@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) ==
	-  \(USB_DIR_OUT\|0\))
	+ usb_endpoint_dir_out(epd)
	
	// Not IN must be OUT, since USB_ENDPOINT_DIR_MASK extracts a single bit
	@r9@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) !=
	-  \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_out(epd)
	
	// Not OUT must be IN, since USB_ENDPOINT_DIR_MASK extracts a single bit
	@r10@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) !=
	-  \(USB_DIR_OUT\|0\))
	+ usb_endpoint_dir_in(epd)
	
	@r11 expression@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\))
	+ usb_endpoint_dir_in(epd)
	  && ...
	
	@r12 expression@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\))
	+ usb_endpoint_dir_in(epd)
	  || ...
	
	@r13@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_ENDPOINT_NUMBER_MASK\|0x0f\))
	+ usb_endpoint_num(epd)
	
	@r14@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\))
	+ usb_endpoint_type(epd)
	
	@r15@ struct usb_endpoint_descriptor *epd; @@
	
	usb_endpoint_type(epd) !=
	- 0
	+ USB_ENDPOINT_XFER_CONTROL
	
	@r16@ struct usb_endpoint_descriptor *epd; @@
	
	usb_endpoint_type(epd) !=
	- 1
	+ USB_ENDPOINT_XFER_ISOC
	
	@r17@ struct usb_endpoint_descriptor *epd; @@
	
	usb_endpoint_type(epd) !=
	- 2
	+ USB_ENDPOINT_XFER_BULK
	
	@r18@ struct usb_endpoint_descriptor *epd; @@
	
	usb_endpoint_type(epd) !=
	- 3
	+ USB_ENDPOINT_XFER_INT
	
	@r19@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_in(epd))
	+ usb_endpoint_is_bulk_in(epd)
	
	@r20@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_out(epd))
	+ usb_endpoint_is_bulk_out(epd)
	
	@r21@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_in(epd))
	+ usb_endpoint_is_int_in(epd)
	
	@r22@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_out(epd))
	+ usb_endpoint_is_int_out(epd)
	
	@inc@
	@@
	
	#include <linux/usb.h>
	
	@depends on !inc && (r1||r2||r3||r4||r5||r6||r7||r8||r9||r10||
	r11||r12||r13||r14||r15||r16||r17||r18||r19||r20||r21||r22)@
	@@
	
	+ #include <linux/usb.h>
	  #include <linux/usb/...>
	// </smpl>
</pre>
<A HREF=epd/mini.cocci>epd/mini.cocci</A>  -  use USB API functions rather than constants
<pre>
	----------------------------
	
	This set of patches introduces calls to the following functions:
	
	usb_endpoint_dir_in(epd)
	usb_endpoint_dir_out(epd)
	usb_endpoint_is_bulk_in(epd)
	usb_endpoint_is_bulk_out(epd)
	usb_endpoint_is_int_in(epd)
	usb_endpoint_is_int_out(epd)
	usb_endpoint_num(epd)
	usb_endpoint_type(epd)
	usb_endpoint_xfer_bulk(epd)
	usb_endpoint_xfer_control(epd)
	usb_endpoint_xfer_int(epd)
	usb_endpoint_xfer_isoc(epd)
	
	In some cases, introducing one of these functions is not possible, and it
	just replaces an explicit integer value by one of the following constants:
	
	USB_ENDPOINT_XFER_BULK
	USB_ENDPOINT_XFER_CONTROL
	USB_ENDPOINT_XFER_INT
	USB_ENDPOINT_XFER_ISOC
	
	The complete semantic patch that makes these changes is below
	(http://www.emn.fr/x-info/coccinelle/).  Most of the transformations are
	straightforward, based on the definition of the added function.  A few are
	slightly less straightforward, as follows:
	
	1. Normally, the direction of an endpoint is determined by extracting the
	direction information and comparing it to USB_DIR_IN or USB_DIR_OUT (rules
	r5 and r8).  But the mask for extracting the direction information is the
	same as USB_DIR_IN, so it is fairly common to just perform an & with
	USB_DIR_IN.  When the result is used as a test expression, the effect is
	the same as the normal case, so I have used usb_endpoint_dir_in in these
	cases as well (rules r6 and r7).
	
	2. Normally, the direction of an endpoint is compared in a positive way to
	USB_DIR_IN or USB_DIR_OUT, corresponding to the definitions of
	usb_endpoint_dir_in and usb_endpoint_dir_out, respectively.  Sometimes,
	however, it is compared in a negative way.  Since the mask for extracting
	the direction information has only one bit that is non-zero, there are only
	two possible values, and an endpoint that is not in must be out, and vice
	versa.  This is taken case of by rules r9 and r10.
	
	There is one case where the field bEndpointAddress is bit-anded with a
	constant that is not one of the constants considered here.  This is noted
	in the log of the patch ([6/13]) where it occurs.
	
	// <smpl>
	@r1@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_CONTROL\|0\))
	+ usb_endpoint_xfer_control(epd)
	
	@r2@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_ISOC\|1\))
	+ usb_endpoint_xfer_isoc(epd)
	
	@r3@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_BULK\|2\))
	+ usb_endpoint_xfer_bulk(epd)
	
	@r4@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\)) ==
	- \(USB_ENDPOINT_XFER_INT\|3\))
	+ usb_endpoint_xfer_int(epd)
	
	@r5@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) ==
	-  \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_in(epd)
	
	// Since USB_ENDPOINT_DIR_MASK selects only one bit and USB_DIR_IN is nonzero,
	// anding with USB_DIR_IN in a test expression has the same effect as the above
	@r6 expression@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_in(epd)
	  || ...
	
	// The same comment applies here
	@r7 expression@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_in(epd)
	  && ...
	
	@r8@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) ==
	-  \(USB_DIR_OUT\|0\))
	+ usb_endpoint_dir_out(epd)
	
	// Not IN must be OUT, since USB_ENDPOINT_DIR_MASK extracts a single bit
	@r9@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) !=
	-  \(USB_DIR_IN\|0x80\))
	+ usb_endpoint_dir_out(epd)
	
	// Not OUT must be IN, since USB_ENDPOINT_DIR_MASK extracts a single bit
	@r10@ struct usb_endpoint_descriptor *epd; @@
	
	- ((epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\)) !=
	-  \(USB_DIR_OUT\|0\))
	+ usb_endpoint_dir_in(epd)
	
	@r11 expression@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\))
	+ usb_endpoint_dir_in(epd)
	  && ...
	
	@r12 expression@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_ENDPOINT_DIR_MASK\|0x80\))
	+ usb_endpoint_dir_in(epd)
	  || ...
	
	@r13@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bEndpointAddress & \(USB_ENDPOINT_NUMBER_MASK\|0x0f\))
	+ usb_endpoint_num(epd)
	
	@r14@ struct usb_endpoint_descriptor *epd; @@
	
	- (epd->bmAttributes & \(USB_ENDPOINT_XFERTYPE_MASK\|3\))
	+ usb_endpoint_type(epd)
	
	@r15@ struct usb_endpoint_descriptor *epd; @@
	
	usb_endpoint_type(epd) !=
	- 0
	+ USB_ENDPOINT_XFER_CONTROL
	
	@r16@ struct usb_endpoint_descriptor *epd; @@
	
	usb_endpoint_type(epd) !=
	- 1
	+ USB_ENDPOINT_XFER_ISOC
	
	@r17@ struct usb_endpoint_descriptor *epd; @@
	
	usb_endpoint_type(epd) !=
	- 2
	+ USB_ENDPOINT_XFER_BULK
	
	@r18@ struct usb_endpoint_descriptor *epd; @@
	
	usb_endpoint_type(epd) !=
	- 3
	+ USB_ENDPOINT_XFER_INT
	
	@r19@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_in(epd))
	+ usb_endpoint_is_bulk_in(epd)
	
	@r20@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_out(epd))
	+ usb_endpoint_is_bulk_out(epd)
	
	@r21@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_in(epd))
	+ usb_endpoint_is_int_in(epd)
	
	@r22@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_out(epd))
	+ usb_endpoint_is_int_out(epd)
	
	@inc@
	@@
	
	#include <linux/usb.h>
	
	@depends on !inc && (r1||r2||r3||r4||r5||r6||r7||r8||r9||r10||
	r11||r12||r13||r14||r15||r16||r17||r18||r19||r20||r21||r22)@
	@@
	
	+ #include <linux/usb.h>
	  #include <linux/usb/...>
	// </smpl>
</pre>
<A HREF=epdneg/epdneg.cocci>epdneg/epdneg.cocci</A>  -  Use negated usb_endpoint_xfer_control, etc
<pre>
	----------------------------
	
	
	This patch extends 134179823b3ca9c8b98e0631906459dbb022ff9b by using
	usb_endpoint_xfer_control, usb_endpoint_xfer_isoc, usb_endpoint_xfer_bulk,
	and usb_endpoint_xfer_int in the negated case as well.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_type(epd) != \(USB_ENDPOINT_XFER_CONTROL\|0\))
	+ !usb_endpoint_xfer_control(epd)
	
	@@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_type(epd) != \(USB_ENDPOINT_XFER_ISOC\|1\))
	+ !usb_endpoint_xfer_isoc(epd)
	
	@@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_type(epd) != \(USB_ENDPOINT_XFER_BULK\|2\))
	+ !usb_endpoint_xfer_bulk(epd)
	
	@@ struct usb_endpoint_descriptor *epd; @@
	
	- (usb_endpoint_type(epd) != \(USB_ENDPOINT_XFER_INT\|3\))
	+ !usb_endpoint_xfer_int(epd)
	// </smpl>
	
</pre>
<A HREF=even_more_pci/get_slot.cocci>even_more_pci/get_slot.cocci</A>  -  Add missing pci_dev_get
<pre>
	drivers/char/agp/amd64-agp.c
	
	Send to:
	airlied@linux.ie, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/2] drivers/char/agp: Add missing pci_dev_get
	
	------------------------------------------------------
	
	
	pci_get_slot does a pci_dev_get, so pci_dev_put needs to be called in an
	error case.
	
	In the first three cases, it might also be possible to move the call to
	pci_get_slot downwards below the error handling code.
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	local idexpression *n;
	statement S1,S2;
	expression E,E1;
	expression *ptr != NULL;
	type T,T1;
	@@
	
	(
	if (!(n = pci_get_slot(...))) S1
	|
	n = pci_get_slot(...)
	)
	<... when != pci_dev_put(n)
	    when != if (...) { <+... pci_dev_put(n) ...+> }
	    when != true !n  || ...
	    when != n = (T)E
	    when != E = n
	if (!n || ...) S2
	...>
	(
	  return \(0\|<+...n...+>\|ptr\);
	|
	+ pci_dev_put(n);
	return ...;
	|
	pci_dev_put(n);
	|
	n = (T1)E1
	|
	E1 = n
	)
	// </smpl>
	
</pre>
<A HREF=extra_put/extra_put.cocci>extra_put/extra_put.cocci</A>  -  Drop unneeded of_node_put
<pre>
	Send to:
	benh@kernel.crashing.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] arch/powerpc/platforms/powermac: Drop unneeded of_node_put
	
	
	------------------------------------------------------
	
	
	After using for_each_node_by_name, there is no need for of_node_put unless
	there was a break in the loop body, as for_each_node_by_name does a
	of_node_put on each of the elements it returns.
	
	This was detected and fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	iterator for_each_node_by_name;
	expression d;
	@@
	
	  for_each_node_by_name(d,...) {
	    ... when != break;
	  }
	  ... when != d
	?- of_node_put(d);
	// </smpl>
	
</pre>
<A HREF=fbrelease/metapatch.cocci>fbrelease/metapatch.cocci</A>  -  eliminate double free
<pre>
	adaplas@gmail.com, linux-fbdev-devel@lists.sourceforge.net, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH] drivers/video/pnx4008: eliminate double free
	
	------------------------------------------------------
	
	
	The function framebuffer_release just calls kfree, so calling kfree
	subsequently on the same argument represents a double free.  The
	comments with the definition of framebuffer_release
	in drivers/video/fbsysfs.c suggest that a more elaborate definition of this
	function is planned, such that the splitting up of framebuffer_release and
	kfree as done in the second instance might someday make sense, but it does
	not make sense now. 
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	@@
	
	* kfree(E);
	...
	* framebuffer_release(E);
	
	@@
	expression E;
	@@
	
	* framebuffer_release(E);
	...
	* kfree(E);
	// </smpl>
	
</pre>
<A HREF=fbrelease/patch.cocci>fbrelease/patch.cocci</A>  -  eliminate double free
<pre>
	adaplas@gmail.com, linux-fbdev-devel@lists.sourceforge.net, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH] drivers/video/pnx4008: eliminate double free
	
	------------------------------------------------------
	
	
	The function framebuffer_release just calls kfree, so calling kfree
	subsequently on the same argument represents a double free.  The
	comments with the definition of framebuffer_release
	in drivers/video/fbsysfs.c suggest that a more elaborate definition of this
	function is planned, such that the splitting up of framebuffer_release and
	kfree as done in the second instance might someday make sense, but it does
	not make sense now. 
	
	This was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	@@
	
	* kfree(E);
	...
	* framebuffer_release(E);
	
	@@
	expression E;
	@@
	
	* framebuffer_release(E);
	...
	* kfree(E);
	// </smpl>
	
</pre>
<A HREF=fen/fen.cocci>fen/fen.cocci</A>  -  Drop unnecessary of_node_put
<pre>
	----------------------------
	
	
	for_each_node_by_name only exits when its first argument is NULL, and a
	subsequent call to of_node_put on that argument is unnecessary.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	iterator name for_each_node_by_name;
	expression np,E;
	identifier l;
	@@
	
	for_each_node_by_name(np,...) {
	  ... when != break;
	      when != goto l;
	}
	... when != np = E
	- of_node_put(np);
	// </smpl>
	
</pre>
<A HREF=fields/field.cocci>fields/field.cocci</A>  -  Use FIELD_SIZEOF
<pre>
	----------------------------
	
	
	Robert P.J. Day proposed to use the macro FIELD_SIZEOF in replace of code
	that matches its definition.
	
	The modification was made using the following semantic patch
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@haskernel@
	@@
	
	#include <linux/kernel.h>
	
	@depends on haskernel@
	type t;
	identifier f;
	@@
	
	- (sizeof(((t*)0)->f))
	+ FIELD_SIZEOF(t, f)
	
	@depends on haskernel@
	type t;
	identifier f;
	@@
	
	- sizeof(((t*)0)->f)
	+ FIELD_SIZEOF(t, f)
	// </smpl>
	
</pre>
<A HREF=frfr/frfr.cocci>frfr/frfr.cocci</A>  -  Eliminate double free
<pre>
	----------------------------
	
	
	The few lines below the kfree of hdr_buf may go to the label err_free which
	will also free hdr_buf.  The most straightforward solution seems to be to
	just move the kfree of hdr_buf after these gotos.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier E;
	expression E1;
	iterator I;
	statement S;
	@@
	
	*kfree(E);
	... when != E = E1
	    when != I(E,...) S
	    when != &E
	*kfree(E);
	// </smpl>
	
</pre>
<A HREF=fuse/fuse.cocci>fuse/fuse.cocci</A>  -  Add missing fuse_request_alloc
<pre>
	----------------------------
	
	
	The error handling code for the second call to fuse_request_alloc should
	include freeing the result of the first one.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S;
	position p1,p2,p3;
	@@
	
	(
	if ((x = fuse_request_alloc@p1(...)) == NULL || ...) S
	|
	x = fuse_request_alloc@p1(...)
	... when != x
	if (x == NULL || ...) S
	)
	<...
	if@p3 (...) { ... when != fuse_request_free(x)
	    return@p2 ...;
	}
	...>
	(
	return x;
	|
	return 0;
	|
	x = E
	|
	E = x
	|
	fuse_request_free(x)
	)
	
	@exists@
	position r.p1,r.p2,r.p3;
	expression x;
	int ret != 0;
	statement S;
	@@
	
	* x = fuse_request_alloc@p1(...)
	  <...
	* if@p3 (...)
	  S
	  ...>
	* return@p2 \(NULL\|ret\);
	
	// </smpl>
	
</pre>
<A HREF=gdth/gdth.cocci>gdth/gdth.cocci</A>  -  Add missing call to gdth_ioctl_free
<pre>
	----------------------------
	
	
	Add missing call to gdth_ioctl_free before aborting.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression buf,ha,len,addr,E;
	@@
	
	buf = gdth_ioctl_alloc(ha, len, FALSE, &addr)
	... when != false buf != NULL
	    when != true buf == NULL
	    when != \(E = buf\|buf = E\)
	    when != gdth_ioctl_free(ha, len, buf, addr)
	*return ...;
	// </smpl>
	
</pre>
<A HREF=gfs2/category2a_gfs2_inode_lookup.cocci>gfs2/category2a_gfs2_inode_lookup.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function gfs2_inode_lookup returns an
	ERR pointer, but never returns a NULL pointer. So a NULL test that
	necessarily comes after an IS_ERR test should be deleted, and a NULL
	test that may come after a call to this function should be
	strengthened by an IS_ERR test.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = gfs2_inode_lookup(...)
	... when != x = E
	* if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=gmc/gmc.cocci>gmc/gmc.cocci</A>  -  Avoid call to genlmsg_cancel
<pre>
	genlmsg_cancel subtracts some constants from its second argument before
	calling nlmsg_cancel.  nlmsg_cancel then calls nlmsg_trim on the same
	arguments.  nlmsg_trim tests for NULL before doing any computation, but a
	NULL second argument to genlmsg_cancel is no longer NULL due to the initial
	subtraction.  Nothing else happens in this execution, so the call to
	genlmsg_cancel is simply unnecessary in this case.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression data;
	@@
	
	if (data == NULL) { ...
	* genlmsg_cancel(..., data);
	  ...
	  return ...;
	}
	// </smpl>
	
</pre>
<A HREF=handle/handle.cocci>handle/handle.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=hrtimer/hrtimer.cocci>hrtimer/hrtimer.cocci</A>  -  use function hrtimer_is_queued
<pre>
	----------------------------
	
	
	Use the hrtimer_is_queued function rather than an explicit bit-and for
	testing timer->state, as done elsewhere.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@header@
	@@
	
	#include <linux/hrtimer.h>
	
	@depends on header@
	struct hrtimer *timer;
	@@
	
	- (timer->state & HRTIMER_STATE_ENQUEUED)
	+ hrtimer_is_queued(timer)
	// </smpl>
	
</pre>
<A HREF=i2c_msg/i2c_msg.cocci>i2c_msg/i2c_msg.cocci</A>  -  use macros for i2c_msg initialization
<pre>
	Introduce use of I2c_MSG_READ/WRITE/OP, for readability.
	
	A length expressed as an explicit constant is also re-expressed as the size
	of the buffer, when this is possible.
	
	The second case is simplified to use simple variables rather than arrays.
	The variable b0 is dropped completely, and the variable reg that it
	contains is used instead.  The variable b1 is replaced by a u8-typed
	variable named buf (the name used earlier in the file).  The uses of b1 are
	then adjusted accordingly.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression a,b,c;
	identifier x;
	@@
	
	struct i2c_msg x =
	- {.addr = a, .buf = b, .len = c, .flags = I2C_M_RD}
	+ I2C_MSG_READ(a,b,c)
	 ;
	
	@@
	expression a,b,c;
	identifier x;
	@@
	
	struct i2c_msg x =
	- {.addr = a, .buf = b, .len = c, .flags = 0}
	+ I2C_MSG_WRITE(a,b,c)
	 ;
	
	@@
	expression a,b,c,d;
	identifier x;
	@@
	
	struct i2c_msg x = 
	- {.addr = a, .buf = b, .len = c, .flags = d}
	+ I2C_MSG_OP(a,b,c,d)
	 ;
	// </smpl>
	
</pre>
<A HREF=i915/sp1517.cocci>i915/sp1517.cocci</A>  -  Add missing error handling code
<pre>
	The cleanup code at the end of the function should also be carried out when
	the function only partly completes its work.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct page ** x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = drm_malloc_ab@p1(...)
	...  when != x = rr
	     when != drm_free_large(x,...)
	     when != if (...) { ... drm_free_large(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != drm_free_large(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"drm_malloc_ab\",p1)
	cocci.print_secs(\"return\",p2)
	
	// </smpl>
	
</pre>
<A HREF=ie2/ie2.cocci>ie2/ie2.cocci</A>  -  Convert IS_ERR result to PTR_ERR
<pre>
	This code elsewhere returns a negative constant to an indicate an error,
	while IS_ERR returns the result of a >= operation.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x;
	@@
	
	 if (...) { ...
	- return IS_ERR(x);
	+ return PTR_ERR(x);
	}
	// </smpl>
	
</pre>
<A HREF=if-semicolon/if-semicolon.cocci>if-semicolon/if-semicolon.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=ifcol/ifcol.cocci>ifcol/ifcol.cocci</A>  -  Adjust confusing if indentation
<pre>
	----------------------------
	
	
	Indent the branch of an if.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r disable braces4@
	position p1,p2;
	statement S1,S2;
	@@
	
	(
	if (...) { ... }
	|
	if (...) S1@p1 S2@p2
	)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	if (p1[0].column == p2[0].column):
	  cocci.print_main(\"branch\",p1)
	  cocci.print_secs(\"after\",p2)
	// </smpl>
	
</pre>
<A HREF=iff/iff.cocci>iff/iff.cocci</A>  -  fix error return code
<pre>
	Convert a possibly 0 error return code to a negative one, as returned
	elsewhere in the function.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression ret;
	constant C;
	expression e1,e2;
	identifier l;
	@@
	
	* ret = -C;
	  ...
	* if (...)
	 {
	  ... when any
	* if (ret)
	    { ...
	*     return ret;
	    }
	  ... when any
	      when forall
	      when != return ...;
	      when != goto l;
	 }
	... when any
	    when != ret = e1
	* if (...)
	  { ... when != ret = e2
	*   return ret;
	  }
	// </smpl>
	
</pre>
<A HREF=ifseqerr/ifseqerr.cocci>ifseqerr/ifseqerr.cocci</A>  -  Add missing error handling code
<pre>
	Extend the error handling code with operations found in other nearby error
	handling code
	
	A simplified version of the sematic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	@r@
	statement S1,S2,S3;
	constant C1,C2,C3;
	@@
	
	*if (...)
	 {... S1 return -C1;}
	...
	*if (...)
	 {... when != S1
	    return -C2;}
	...
	*if (...)
	 {... S1 return -C3;}
	// </smpl>
	
</pre>
<A HREF=inconsistent/inconsistent1.cocci>inconsistent/inconsistent1.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=infiniband/category2a_ib_create_send_mad.cocci>infiniband/category2a_ib_create_send_mad.cocci</A>  -  Use a NULL test rather than an IS_ERR test
<pre>
	general@lists.openfabrics.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/infiniband/core: Use a NULL test rather than an IS_ERR test
	
	----------------------------
	
	
	In case of error, the function ucma_alloc_multicast returns a NULL
	pointer, but never returns an ERR pointer. So after a call to this
	function, an IS_ERR test should be replaced by a NULL test.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match bad_is_err_test@
	expression x, E;
	@@
	
	x = ucma_alloc_multicast(...)
	... when != x = E
	IS_ERR(x)
	// </smpl>
	
</pre>
<A HREF=infiniband/category2a_ucma_alloc_multicast.cocci>infiniband/category2a_ucma_alloc_multicast.cocci</A>  -  Use a NULL test rather than an IS_ERR test
<pre>
	general@lists.openfabrics.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/infiniband/core: Use a NULL test rather than an IS_ERR test
	
	----------------------------
	
	
	In case of error, the function ucma_alloc_multicast returns a NULL
	pointer, but never returns an ERR pointer. So after a call to this
	function, an IS_ERR test should be replaced by a NULL test.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match bad_is_err_test@
	expression x, E;
	@@
	
	x = ucma_alloc_multicast(...)
	... when != x = E
	IS_ERR(x)
	// </smpl>
	
</pre>
<A HREF=input/sp2486.cocci>input/sp2486.cocci</A>  -  Correct call to input_free_device
<pre>
	This error handling code can be reached before ts_dev->input is
	initialized, so it is safer to always use the original name, input_dev.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct input_dev * x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = input_allocate_device@p1(...)
	...  when != x = rr
	     when != input_free_device(x,...)
	     when != if (...) { ... input_free_device(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != input_free_device(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"input_allocate_device\",p1)
	cocci.print_secs(\"input_free_device\",p2)
	// </smpl>
	
</pre>
<A HREF=input/sp2495.cocci>input/sp2495.cocci</A>  -  Correct call to input_free_device
<pre>
	This error handling code can be reached before ts_dev->input is
	initialized, so it is safer to always use the original name, input_dev.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct input_dev * x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = input_allocate_device@p1(...)
	...  when != x = rr
	     when != input_free_device(x,...)
	     when != if (...) { ... input_free_device(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != input_free_device(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"input_allocate_device\",p1)
	cocci.print_secs(\"input_free_device\",p2)
	// </smpl>
	
</pre>
<A HREF=input/sp2506.cocci>input/sp2506.cocci</A>  -  Correct call to input_free_device
<pre>
	This error handling code can be reached before ts_dev->input is
	initialized, so it is safer to always use the original name, input_dev.
	
	A simplified version of the semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression struct input_dev * x;
	expression ra,rr;
	position p1,p2;
	@@
	
	x = input_allocate_device@p1(...)
	...  when != x = rr
	     when != input_free_device(x,...)
	     when != if (...) { ... input_free_device(x,...) ...}
	if(...) { ... when != x = ra
	     when forall
	     when != input_free_device(x,...)
	 \(return <+...x...+>; \| return@p2...; \) }
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"input_allocate_device\",p1)
	cocci.print_secs(\"input_free_device\",p2)
	// </smpl>
	
</pre>
<A HREF=iom/devm2i.cocci>iom/devm2i.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	By removing the need for kfree and iounmap, this also eliminates missing
	resource-release problems.
	
</pre>
<A HREF=iom/iom.cocci>iom/iom.cocci</A>  -  use devm_ functions
<pre>
	The various devm_ functions allocate memory that is released when a driver
	detaches.  This patch uses these functions for data that is allocated in
	the probe function of a platform device and is only freed in the remove
	function.
	
	By removing the need for kfree and iounmap, this also eliminates missing
	resource-release problems.
	
</pre>
<A HREF=iounmap/ioremap_check.cocci>iounmap/ioremap_check.cocci</A>  -  Added a missing iounmap
<pre>
	----------------------------
	
	
	An extra error handling label is needed for the case where the ioremap has
	succeeded.
	
	The problem was detected using the following semantic match
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2;
	constant C;
	int ret;
	@@
	
	  T E;
	  ...
	* E = ioremap(...);
	  if (E == NULL) S
	  ... when != iounmap(E)
	      when != if (E != NULL) { ... iounmap(E); ...}
	      when != x1 = (T1)E
	  if (...) {
	    ... when != iounmap(E)
	        when != if (E != NULL) { ... iounmap(E); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return C;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=is_static/is_static.cocci>is_static/is_static.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=iserr/patch1.cocci>iserr/patch1.cocci</A>  -  test for IS_ERR rather than 0
<pre>
	Send to:
	swhiteho@redhat.com, cluster-devel@redhat.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/5] fs/gfs2: test for IS_ERR rather than 0
	
	------------------------------------------------------
	
	
	The function gfs2_inode_lookup always returns either a valid pointer or a
	value made with ERR_PTR, so its result should be tested with IS_ERR, not
	with a test for 0.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	//<smpl>
	@a@
	expression E, E1;
	statement S,S1;
	position p;
	@@
	
	E = gfs2_inode_lookup(...)
	... when != E = E1
	if@p (E) S else S1
	
	@n@
	position a.p;
	expression E,E1;
	statement S,S1;
	@@
	
	E = NULL
	... when != E = E1
	if@p (E) S else S1
	
	@depends on !n@
	expression E;
	statement S,S1;
	position a.p;
	@@
	
	* if@p (E)
	  S else S1
	//</smpl>
	
</pre>
<A HREF=iserr/patch2.cocci>iserr/patch2.cocci</A>  -  test for IS_ERR rather than 0
<pre>
	Send to:
	swhiteho@redhat.com, cluster-devel@redhat.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/5] fs/gfs2: test for IS_ERR rather than 0
	
	------------------------------------------------------
	
	
	The function gfs2_inode_lookup always returns either a valid pointer or a
	value made with ERR_PTR, so its result should be tested with IS_ERR, not
	with a test for 0.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	//<smpl>
	@a@
	expression E, E1;
	statement S,S1;
	position p;
	@@
	
	E = gfs2_inode_lookup(...)
	... when != E = E1
	if@p (E) S else S1
	
	@n@
	position a.p;
	expression E,E1;
	statement S,S1;
	@@
	
	E = NULL
	... when != E = E1
	if@p (E) S else S1
	
	@depends on !n@
	expression E;
	statement S,S1;
	position a.p;
	@@
	
	* if@p (E)
	  S else S1
	//</smpl>
	
</pre>
<A HREF=iserr/patch3.cocci>iserr/patch3.cocci</A>  -  test for IS_ERR rather than 0
<pre>
	Send to:
	swhiteho@redhat.com, cluster-devel@redhat.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/5] fs/gfs2: test for IS_ERR rather than 0
	
	------------------------------------------------------
	
	
	The function gfs2_inode_lookup always returns either a valid pointer or a
	value made with ERR_PTR, so its result should be tested with IS_ERR, not
	with a test for 0.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	//<smpl>
	@a@
	expression E, E1;
	statement S,S1;
	position p;
	@@
	
	E = gfs2_inode_lookup(...)
	... when != E = E1
	if@p (E) S else S1
	
	@n@
	position a.p;
	expression E,E1;
	statement S,S1;
	@@
	
	E = NULL
	... when != E = E1
	if@p (E) S else S1
	
	@depends on !n@
	expression E;
	statement S,S1;
	position a.p;
	@@
	
	* if@p (E)
	  S else S1
	//</smpl>
	
</pre>
<A HREF=iserr/patch45.cocci>iserr/patch45.cocci</A>  -  test for IS_ERR rather than 0
<pre>
	Send to:
	swhiteho@redhat.com, cluster-devel@redhat.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/5] fs/gfs2: test for IS_ERR rather than 0
	
	------------------------------------------------------
	
	
	The function gfs2_inode_lookup always returns either a valid pointer or a
	value made with ERR_PTR, so its result should be tested with IS_ERR, not
	with a test for 0.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	//<smpl>
	@a@
	expression E, E1;
	statement S,S1;
	position p;
	@@
	
	E = gfs2_inode_lookup(...)
	... when != E = E1
	if@p (E) S else S1
	
	@n@
	position a.p;
	expression E,E1;
	statement S,S1;
	@@
	
	E = NULL
	... when != E = E1
	if@p (E) S else S1
	
	@depends on !n@
	expression E;
	statement S,S1;
	position a.p;
	@@
	
	* if@p (E)
	  S else S1
	//</smpl>
	
</pre>
<A HREF=iserr/send_ct.cocci>iserr/send_ct.cocci</A>  -  test for IS_ERR rather than 0
<pre>
	Send to:
	swhiteho@redhat.com, cluster-devel@redhat.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/5] fs/gfs2: test for IS_ERR rather than 0
	
	------------------------------------------------------
	
	
	The function gfs2_inode_lookup always returns either a valid pointer or a
	value made with ERR_PTR, so its result should be tested with IS_ERR, not
	with a test for 0.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	//<smpl>
	@a@
	expression E, E1;
	statement S,S1;
	position p;
	@@
	
	E = gfs2_inode_lookup(...)
	... when != E = E1
	if@p (E) S else S1
	
	@n@
	position a.p;
	expression E,E1;
	statement S,S1;
	@@
	
	E = NULL
	... when != E = E1
	if@p (E) S else S1
	
	@depends on !n@
	expression E;
	statement S,S1;
	position a.p;
	@@
	
	* if@p (E)
	  S else S1
	//</smpl>
	
</pre>
<A HREF=iserr_cata/category2a.cocci>iserr_cata/category2a.cocci</A>  -  correct error-handling code
<pre>
	----------------------------
	
	
	romfs_iget returns an ERR_PTR value in an error case instead of NULL.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@match exists@
	expression x, E;
	statement S1, S2;
	@@
	
	x = romfs_iget(...)
	... when != x = E
	(
	*  if (x == NULL || ...) S1 else S2
	|
	*  if (x == NULL && ...) S1 else S2
	)
	// </smpl>
	
</pre>
<A HREF=iserr_ref/iserr_mini.cocci>iserr_ref/iserr_mini.cocci</A>  -  correct an error check
<pre>
	----------------------------
	
	
	rtc is clearly does not satisfy IS_ERR at the point where it is tested, so
	I have changed the test to consider the just initialized rtc->rtc_dev.
	
	The semantic match that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match exists@
	expression x, E;
	identifier fld;
	position p1,p2;
	@@
	
	(
	x = E;
	|
	x = E
	|
	x@p1->fld
	... when != x = E
	IS_ERR(x@p2)
	... when any
	)
	
	@other_match exists@
	expression match.x, E1, E2;
	position match.p1,match.p2;
	@@
	
	x = E1
	... when != x = E2
	    when != x@p1
	x@p2
	
	@ script:python depends on !other_match@
	p1 << match.p1;
	p2 << match.p2;
	@@
	
	print \"* file %s dereference %s test %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=iserr_ref/iserr_ref.cocci>iserr_ref/iserr_ref.cocci</A>  -  correct an error check
<pre>
	----------------------------
	
	
	rtc is clearly does not satisfy IS_ERR at the point where it is tested, so
	I have changed the test to consider the just initialized rtc->rtc_dev.
	
	The semantic match that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match exists@
	expression x, E;
	identifier fld;
	position p1,p2;
	@@
	
	(
	x = E;
	|
	x = E
	|
	x@p1->fld
	... when != x = E
	IS_ERR(x@p2)
	... when any
	)
	
	@other_match exists@
	expression match.x, E1, E2;
	position match.p1,match.p2;
	@@
	
	x = E1
	... when != x = E2
	    when != x@p1
	x@p2
	
	@ script:python depends on !other_match@
	p1 << match.p1;
	p2 << match.p2;
	@@
	
	print \"* file %s dereference %s test %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=iserreq/ise2.cocci>iserreq/ise2.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=isnull_oct/isnull.cocci>isnull_oct/isnull.cocci</A>  -  eliminate a null pointer dereference
<pre>
	It is not possible to take the lock in device if device is NULL.
	The mutex_lock is thus moved after the NULL test.  New error handling
	labels are added at the end to differentiate between the cases where
	different sets of locks should be unlocks, and between whether or not
	reader should be freed (only on error).
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression E, E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	if (E == NULL)
	{
	  ... when != if (E == NULL || ...) S1 else S2
	      when != E = E1
	*E->f
	  ... when any
	  return ...;
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=isnullo/isnull.cocci>isnullo/isnull.cocci</A>  -  keep pointer to resource so it can be freed
<pre>
	Add a new variable for storing resources accessed subsequent to the one
	accessed using request_mem_region, so the one accessed using
	request_mem_region can be released if needed.
	
	This code is also missing some calls to iounmap.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression E, E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	if (E == NULL)
	{
	  ... when != if (E == NULL || ...) S1 else S2
	      when != E = E1
	*E->f
	  ... when any
	  return ...;
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=itnull/itnull.cocci>itnull/itnull.cocci</A>  -  Drop unnecessary null test
<pre>
	----------------------------
	
	
	list_for_each_entry binds its first argument to a non-null value, and thus
	any null test on the value of that argument is superfluous.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	iterator I;
	expression x,E;
	@@
	
	I(x,...) { <...
	(
	- (x == NULL) || 
	  E
	|
	- (x != NULL) &&
	  E
	)
	  ...> }
	// </smpl>
	
</pre>
<A HREF=iwcontainer/extra_null.cocci>iwcontainer/extra_null.cocci</A>  -  Drop unnecessary NULL test
<pre>
	----------------------------
	
	
	The result of container_of should not be NULL.  In particular, in this case
	the argument to the enclosing function has passed though INIT_WORK,
	which dereferences it, implying that its container cannot be NULL.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression x,e;
	@@
	
	x = container_of(...)
	... when != x = e
	* x == NULL
	// </smpl>
	
</pre>
<A HREF=jiffies/jiffies.cocci>jiffies/jiffies.cocci</A>  -  Subject:
<pre>
	Send to:
	mingo@redhat.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject:
	[PATCH 9/38] arch/x86/kernel/io_apic_{64,32}.c: Use time_before, time_before_eq, etc.
	
	
	------------------------------------------------------
	
	
	The functions time_before, time_before_eq, time_after, and time_after_eq
	are more robust for comparing jiffies against other values.
	
	A simplified version of the semantic patch making this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@ change_compare_np @
	expression E;
	@@
	
	(
	- jiffies <= E
	+ time_before_eq(jiffies,E)
	|
	- jiffies >= E
	+ time_after_eq(jiffies,E)
	|
	- jiffies < E
	+ time_before(jiffies,E)
	|
	- jiffies > E
	+ time_after(jiffies,E)
	)
	
	@ include depends on change_compare_np @
	@@
	
	#include <linux/jiffies.h>
	
	@ no_include depends on !include && change_compare_np @
	@@
	
	  #include <linux/...>
	+ #include <linux/jiffies.h>
	// </smpl>
	
</pre>
<A HREF=k-zc-alloc/kzalloc.cocci>k-zc-alloc/kzalloc.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=kasp/kasp.cocci>kasp/kasp.cocci</A>  -  Eliminate kstrdup memory leak
<pre>
	The string clone is only used as a temporary copy of the argument val
	within the while loop, and so it should be freed before leaving the
	function.  The call to strsep, however, modifies clone, so a pointer to the
	front of the string is kept in saved_clone, to make it possible to free it.
	
	The sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E;
	identifier l;
	statement S;
	@@
	
	*x= \(kasprintf\|kstrdup\)(...);
	...
	if (x == NULL) S
	... when != kfree(x)
	    when != E = x
	if (...) {
	  <... when != kfree(x)
	* goto l;
	  ...>
	* return ...;
	}
	// </smpl>
	
</pre>
<A HREF=kasprintf2/aspmem.cocci>kasprintf2/aspmem.cocci</A>  -  Use kmemdup
<pre>
	Convert a sequence of kmalloc and memcpy to use kmemdup.
	
	The semantic patch that performs this transformation is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression a,flag,len;
	expression arg,e1,e2;
	statement S;
	@@
	
	  a =
	-  \(kmalloc\|kzalloc\)(len,flag)
	+  kmemdup(arg,len,flag)
	  <... when != a
	  if (a == NULL || ...) S
	  ...>
	- memcpy(a,arg,len+1);
	// </smpl>
	
</pre>
<A HREF=kc/kc.cocci>kc/kc.cocci</A>  -  Use kzalloc for allocating only one thing
<pre>
	----------------------------
	
	
	Use kzalloc rather than kcalloc(1,...)
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	- kcalloc(1,
	+ kzalloc(
	          ...)
	// </smpl>
	
</pre>
<A HREF=kfree3/kmalloc.cocci>kfree3/kmalloc.cocci</A>  -  introduce missing kfree
<pre>
	pdata needs to be freed before leaving the function in an error case.
	
	A simplified version of the semantic match that finds the problem is as
	follows: (http://coccinelle.lip6.fr)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S;
	identifier f1;
	position p1,p2;
	expression *ptr != NULL;
	@@
	
	x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...);
	...
	if (x == NULL) S
	<... when != x
	     when != if (...) { <+...x...+> }
	x->f1
	...>
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	 return@p2 ...;
	)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	print \"* file: %s kmalloc %s return %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=kfree3/kmalloc8a.cocci>kfree3/kmalloc8a.cocci</A>  -  introduce missing kfree
<pre>
	pdata needs to be freed before leaving the function in an error case.
	
	A simplified version of the semantic match that finds the problem is as
	follows: (http://coccinelle.lip6.fr)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S;
	identifier f1;
	position p1,p2;
	expression *ptr != NULL;
	@@
	
	x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...);
	...
	if (x == NULL) S
	<... when != x
	     when != if (...) { <+...x...+> }
	x->f1
	...>
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	 return@p2 ...;
	)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	print \"* file: %s kmalloc %s return %s\" % (p1[0].file,p1[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=kfree_after/kfree_after.cocci>kfree_after/kfree_after.cocci</A>  -  add missing error-handling code
<pre>
	At this point, the ioremap has taken place, so the error handling code at
	the label err_iounmap should be used rather than returning directly.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier x;
	@@
	
	kfree(x)
	
	@@
	identifier r.x;
	expression E1!=0,E2,E3,E4;
	statement S;
	@@
	
	(
	if (<+...x...+>) S
	|
	if (...) { ... when != kfree(x)
	               when != if (...) { ... kfree(x); ... }
	               when != x = E3
	* return E1;
	}
	... when != x = E2
	if (...) { ... when != x = E4
	 kfree(x); ... return ...; }
	)
	// </smpl>
	
</pre>
<A HREF=kfree_after2/kfree_after.cocci>kfree_after2/kfree_after.cocci</A>  -  avoid missing kfree
<pre>
	Move the test on pdev->id before the kzalloc to avoid requiring kfree when
	the test fails.  This fix was suggested by Wolfram Sang.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	identifier x;
	expression E1!=0,E2,E3,E4;
	statement S;
	iterator I;
	@@
	
	(
	if (...) { ... when != kfree(x)
	               when != x = E3
	               when != E3 = x
	*  return ...;
	 }
	... when != x = E2
	    when != I(...,x,...) S
	if (...) { ... when != x = E4
	 kfree(x); ... return ...; }
	)
	// </smpl>
	
</pre>
<A HREF=kfree_skb/skbfree.cocci>kfree_skb/skbfree.cocci</A>  -  Convert kfree/kfree_skb to dev_kfree_skb_irq
<pre>
	Send to:
	marcel@holtmann.org, maxk@qualcomm.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/bluetooth: Convert kfree/kfree_skb to dev_kfree_skb_irq
	revision of send_skb
	
	------------------------------------------------------
	
	
	When values of type struct sk_buff * are freed from within an interrupt
	handler, dev_kfree_skb_irq should be used rather than kfree or kfree_skb.
	
	In most of the cases below, the function containing the free ends up as a
	URB completion callback.  Such callbacks are called from an interrupt
	handler.  In drivers/bluetooth/btsdio.c, the enclosing function is
	ultimately referenced from the second argument of sdio_claim_irq, which is
	also used as an interrupt handler.
	
	All of these cases except the last were fixed using the following semantic
	patch (http://www.emn.fr/x-info/coccinelle/).
	
	// <smpl>
	@rule1@
	identifier f;
	@@
	
	f(...) {
	<+...
	   kfree_skb(...)
	...+>
	}
	
	@ call @
	identifier rule1.f;
	@@
	
	(
	usb_fill_bulk_urb(...,f,...)
	|
	usb_fill_control_urb(...,f,...)
	|
	usb_fill_int_urb(...,f,...)
	)
	
	@ toplevel @
	identifier rule1.f;
	struct urb u;
	@@
	
	u.complete = f;
	
	@ depends on call || toplevel @
	identifier rule1.f;
	expression E;
	@@
	
	f(...) {
	<...
	-  kfree_skb(E)
	+  dev_kfree_skb_irq(E)
	...>
	}
	// </smpl>
	
</pre>
<A HREF=kfrees/kfree.cocci>kfrees/kfree.cocci</A>  -  eliminate early return
<pre>
	----------------------------
	
	
	There seems to be no reason why this error case should do less cleaning up
	than the other adjacent ones, so the goto, which is currently dead code,
	seems to be what is intended.
	
	
</pre>
<A HREF=kmalloc9/kmalloc9.cocci>kmalloc9/kmalloc9.cocci</A>  -  add missing kfree
<pre>
	Currently, error handling code in this function calls the function
	sata_dwc_port_stop, but this function has essentially no effect if hsdevp
	has not been stored in ap, which is the case throughout this function.  The
	only effect is to print a debugging message including ap->print_id.
	
	The code is rewritten to not call sata_dwc_port_stop, but instead to jump
	to a local label that prints the original error message and the print_id
	information.  In the case where hsdevp has been already allocated (but not
	yet stored in ap), this value is freed as well.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression x;
	statement S,S1;
	expression E;
	identifier fl;
	expression *ptr != NULL;
	@@
	
	x = \(kmalloc\|kzalloc\|kcalloc\)(...);
	...
	if (x == NULL) S
	<... when != x
	     when != if (...) { <+...kfree(x)...+> }
	     when any
	     when != true x == NULL
	x->fl
	...>
	(
	if (x == NULL) S1
	|
	if (...) { ... when != x
	               when forall
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	* return ...;
	)
	}
	)
	// </smpl>
	
</pre>
<A HREF=kmc1/kmc1.cocci>kmc1/kmc1.cocci</A>  -  free kmem_cache_zalloc'd data using kmem_cache_free
<pre>
	Memory allocated using kmem_cache_zalloc should be freed using
	kmem_cache_free, not kfree.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e,e1,e2;
	@@
	
	x = kmem_cache_zalloc(e1,e2)
	... when != x = e
	?-kfree(x)
	+kmem_cache_free(e1,x)
	// </smpl>
	
</pre>
<A HREF=kmc1a/kmc1.cocci>kmc1a/kmc1.cocci</A>  -  eliminate NULL pointer dereference
<pre>
	In this code, blkvsc_req is allocated in the cache blkdev->request_pool,
	but freed in the first case to the cache blkvsc_req->dev->request_pool.
	blkvsc_req->dev is subsequently initialized to blkdev, making these the
	same at the second call to kmem_cache_free.  But at the point of the first
	call, blkvsc_req->dev is NULL.  The second call is changed too, for
	uniformity.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e,e1,e2,e3;
	@@
	
	x = \(kmem_cache_alloc\|kmem_cache_zalloc\)(e1,e2)
	... when != x = e
	(
	kmem_cache_free(e1,x);
	|
	?-kmem_cache_free(e3,x);
	+kmem_cache_free(e1,x);
	)
	// </smpl>
	
</pre>
<A HREF=kmtest/kmtest.cocci>kmtest/kmtest.cocci</A>  -  Add kmalloc NULL tests
<pre>
	----------------------------
	
	
	Check that the result of kmalloc is not NULL before dereferencing it.
	The patch also replaces kmalloc + memset by kzalloc.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *x;
	identifier f;
	constant char *C;
	@@
	
	x = \(kmalloc\|kcalloc\|kzalloc\)(...);
	... when != x == NULL
	    when != x != NULL
	    when != (x || ...)
	(
	kfree(x)
	|
	f(...,C,...,x,...)
	|
	*f(...,x,...)
	|
	*x->f
	)
	// </smpl>
	
</pre>
<A HREF=kstr/kstr.cocci>kstr/kstr.cocci</A>  -  use kstrtoul, etc
<pre>
	Use kstrtoul, etc instead of the now deprecated strict_strtoul, etc.
	
	A semantic patch rule for the kstrtoul case is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression a,b;
	{int,long} *c;
	@@
	
	-strict_strtoul
	+kstrtoul
	 (a,b,c)
	// </smpl>
	
</pre>
<A HREF=kstrdup/kstrdup.cocci>kstrdup/kstrdup.cocci</A>  -  Use kstrdup
<pre>
	----------------------------
	
	
	Use kstrdup when the goal of an allocation is copy a string into the
	allocated region.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression from,to;
	expression flag,E1,E2;
	statement S;
	@@
	
	-  to = kmalloc(strlen(from) + 1,flag);
	+  to = kstrdup(from, flag);
	   ... when != \(from = E1 \| to = E1 \)
	   if (to==NULL || ...) S
	   ... when != \(from = E2 \| to = E2 \)
	-  strcpy(to, from);
	// </smpl>
	
</pre>
<A HREF=lcd/category2b_back_device_reg.cocci>lcd/category2b_back_device_reg.cocci</A>  -  Bad error test before a dereference
<pre>
	----------------------------
	
	
	The error test that follows the call to backlight_device_register
	seems not to concern the right variable.
	
	A simplified version of the semantic match that finds this problem is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	// <smpl>
	@def0@
	expression x;
	position p0;
	@@
	x@p0 = backlight_device_register(...)
	
	@protected@
	expression def0.x,E;
	position def0.p0;
	position p;
	statement S;
	@@
	x@p0
	... when != x = E
	if (!IS_ERR(x) && ...) {<... x@p ...>} else S
	
	@unprotected@
	expression def0.x;
	identifier fld;
	position def0.p0;
	position p != protected.p;
	@@
	x@p0
	... when != x = E
	* x@p->fld
	// </smpl>
	
</pre>
<A HREF=lenull/lenull.cocci>lenull/lenull.cocci</A>  -  Drop NULL test on list_entry result
<pre>
	----------------------------
	
	
	list_entry, which is an alias for container_of, cannot return NULL, as
	there is no way to add a NULL value to a doubly linked list.
	
	A simplified version of the semantic match that findds this problem is as
	follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	expression x,E;
	statement S1,S2;
	position p,p1;
	@@
	
	*x = list_entry@p(...)
	... when != x = E
	*if@p1 (x == NULL) S1 else S2
	// </smpl>
	
</pre>
<A HREF=leq/leq.cocci>leq/leq.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=lfee/lfee.cocci>lfee/lfee.cocci</A>  -  remove invalid reference to list iterator variable
<pre>
	If list_for_each_entry, etc complete a traversal of the list, the iterator
	variable ends up pointing to an address at an offset from the list head,
	and not a meaningful structure.  Thus this value should not be used after
	the end of the iterator.
	
	A break is added after the switch; the break in the switch would jump out
	of the switch, but not out of the complete iteration.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	identifier c;
	expression E;
	iterator name list_for_each_entry;
	statement S;
	@@
	
	list_for_each_entry(c,...) { ... when != break;
	                                 when forall
	                                 when strict
	}
	...
	(
	c = E
	|
	*c
	)
	// </smpl>
	
	Acked-by: Paul Menzel <paulepanter@users.sourceforge.net>
</pre>
<A HREF=list_entry/rcu2.cocci>list_entry/rcu2.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=list_entry_update/list_entry_update.cocci>list_entry_update/list_entry_update.cocci</A>  -  Eliminate update of list_for_each_entry loop cursor
<pre>
	----------------------------
	
	
	list_for_each_entry uses its first argument to move from one element to the
	next, so modifying it can break the iteration.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	iterator name list_for_each_entry;
	expression x,E;
	position p1,p2;
	@@
	
	list_for_each_entry@p1(x,...) { <... x =@p2 E ...> }
	
	@@
	expression x,E;
	position r.p1,r.p2;
	statement S;
	@@
	
	*x =@p2 E
	...
	list_for_each_entry@p1(x,...) S
	// </smpl>
	
</pre>
<A HREF=listfree/listfree.cocci>listfree/listfree.cocci</A>  -  Avoid leaving freed data in a list
<pre>
	If the call to drm_map_handle fails, list is freed, but not removed from
	&dev->maplist.  &dev->maplist is not used by drm_map_handle, so the
	list_add is moved after the call.
	
	The sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E,E1,E2;
	identifier l;
	@@
	
	*list_add(&E->l,E1);
	... when != E1
	    when != list_del(&E->l)
	    when != list_del_init(&E->l)
	    when != E = E2
	*kfree(E);// </smpl>
	
</pre>
<A HREF=local/local.cocci>local/local.cocci</A>  -  Add local_irq_restore in error handling code
<pre>
	----------------------------
	
	
	There is a call to local_irq_restore in the normal exit case, so it would
	seem that there should be one on an error return as well.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression l;
	expression E,E1,E2;
	@@
	
	local_irq_save(l);
	... when != local_irq_restore(l)
	    when != spin_unlock_irqrestore(E,l)
	    when any
	    when strict
	(
	if (...) { ... when != local_irq_restore(l)
	               when != spin_unlock_irqrestore(E1,l)
	+   local_irq_restore(l);
	    return ...;
	}
	|
	if (...)
	+   {local_irq_restore(l);
	    return ...;
	+   }
	|
	spin_unlock_irqrestore(E2,l);
	|
	local_irq_restore(l);
	)
	// </smpl>
	
</pre>
<A HREF=lock/o_lock_inconsistent.cocci>lock/o_lock_inconsistent.cocci</A>  -  Add missing local_irq_restore
<pre>
	----------------------------
	
	
	Add local_irq_restore after the labels that can be reached after a
	local_irq_save.
	
	A simplified version of the semantic patch that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression E1;
	identifier f;
	@@
	
	f (...) { <+...
	* local_irq_save (E1,...);
	... when != E1
	* return ...;
	...+> }
	// </smpl>
	
</pre>
<A HREF=lock_flags/flags.cocci>lock_flags/flags.cocci</A>  -  convert nested spin_lock_irqsave to spin_lock
<pre>
	----------------------------
	
	
	If spin_lock_irqsave is called twice in a row with the same second
	argument, the interrupt state at the point of the second call overwrites
	the value saved by the first call.  Indeed, the second call does not need
	to save the interrupt state, so it is changed to a simple spin_lock.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression lock1,lock2;
	expression flags;
	@@
	
	*spin_lock_irqsave(lock1,flags)
	... when != flags
	*spin_lock_irqsave(lock2,flags)
	// </smpl>
	
</pre>
<A HREF=lock_flags/flags1.cocci>lock_flags/flags1.cocci</A>  -  convert nested spin_lock_irqsave to spin_lock
<pre>
	----------------------------
	
	
	If spin_lock_irqsave is called twice in a row with the same second
	argument, the interrupt state at the point of the second call overwrites
	the value saved by the first call.  Indeed, the second call does not need
	to save the interrupt state, so it is changed to a simple spin_lock.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression lock1,lock2;
	expression flags;
	@@
	
	*spin_lock_irqsave(lock1,flags)
	... when != flags
	*spin_lock_irqsave(lock2,flags)
	// </smpl>
	
</pre>
<A HREF=map_destroy/map_destroy.cocci>map_destroy/map_destroy.cocci</A>  -  avoid calling map_destroy on NULL
<pre>
	map_destroy dereferences its argument.  The call is furthermore only
	reachable when this argument is NULL.  Thus the call is dropped.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *x;
	@@
	
	*if (x == NULL)
	{ ...
	* map_destroy(x);
	  ...
	  return ...;
	}
	// </smpl>
	
</pre>
<A HREF=markbusy/usb_mark_last_busy.cocci>markbusy/usb_mark_last_busy.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=mem2/mem2.cocci>mem2/mem2.cocci</A>  -  drop redundant memset
<pre>
	----------------------------
	
	
	The region set by the call to memset is immediately overwritten by the
	subsequent call to memcpy.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e1,e2,e3,e4;
	@@
	
	- memset(e1,e2,e3);
	  memcpy(e1,e4,e3);
	// </smpl>
	
</pre>
<A HREF=memdup/memdup.cocci>memdup/memdup.cocci</A>  -  Use kmemdup
<pre>
	----------------------------
	
	
	Use kmemdup when some other buffer is immediately copied into the
	allocated region.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression from,to,size,flag;
	statement S;
	@@
	
	-  to = \(kmalloc\|kzalloc\)(size,flag);
	+  to = kmemdup(from,size,flag);
	   if (to==NULL || ...) S
	-  memcpy(to, from, size);
	// </smpl>
	
</pre>
<A HREF=memdup_user/memdup_user.cocci>memdup_user/memdup_user.cocci</A>  -  Use memdup_user
<pre>
	----------------------------
	
	
	Use memdup_user when user data is immediately copied into the
	allocated region.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression from,to,size,flag;
	position p;
	identifier l1,l2;
	@@
	
	-  to = \(kmalloc@p\|kzalloc@p\)(size,flag);
	+  to = memdup_user(from,size);
	   if (
	-      to==NULL
	+      IS_ERR(to)
	                 || ...) {
	   <+... when != goto l1;
	-  -ENOMEM
	+  PTR_ERR(to)
	   ...+>
	   }
	-  if (copy_from_user(to, from, size) != 0) {
	-    <+... when != goto l2;
	-    -EFAULT
	-    ...+>
	-  }
	// </smpl>
	
</pre>
<A HREF=memuser/memuser.cocci>memuser/memuser.cocci</A>  -  add missing kfree
<pre>
	The label fail frees dev->buf, but kbuf hasn't yet been stored there at
	this point.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression x;
	statement S;
	expression E;
	expression *ptr != NULL;
	@@
	
	x = memdup_user(...);
	...
	if (IS_ERR(x)) S
	... when != x
	    when != x = E
	(
	 return \(0\|<+...x...+>\|ptr\);
	|
	*return ...;
	)
	// </smpl>
	
</pre>
<A HREF=mesh/mesh.cocci>mesh/mesh.cocci</A>  -  correct the argument to __mesh_table_free
<pre>
	----------------------------
	
	
	In the function mesh_table_grow, it is the new table not the argument table
	that should be freed if the function fails (cf commit
	bd9b448f4c0a514559bdae4ca18ca3e8cd999c6d)
	
	The semantic match that detects this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E,f;
	position p1,p2,p3;
	identifier l;
	statement S;
	@@
	
	x = mesh_table_alloc@p1(...)
	...
	if (x == NULL) S
	... when != E = x
	    when != mesh_table_free(x)
	goto@p2 l;
	... when != E = x
	    when != f(...,x,...)
	    when any
	(
	return \(0\|x\);
	|
	return@p3 ...;
	)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	p3 << r.p3;
	@@
	
	print \"%s: call on line %s not freed or saved before return on line %s via line %s\" % (p1[0].file,p1[0].line,p3[0].line,p2[0].line)
	// </smpl>
	
</pre>
<A HREF=mini_lock/mini_lock.cocci>mini_lock/mini_lock.cocci</A>  -  Add missing spin_unlock
<pre>
	----------------------------
	
	
	Add a spin_unlock missing on the error path.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E1;
	@@
	
	* spin_lock(E1,...);
	  <+... when != E1
	  if (...) {
	    ... when != E1
	*   return ...;
	  }
	  ...+>
	* spin_unlock(E1,...);
	// </smpl>
	
</pre>
<A HREF=mini_null/mini_null_ref.cocci>mini_null/mini_null_ref.cocci</A>  -  Move a dereference below a NULL test
<pre>
	----------------------------
	
	
	If the NULL test is necessary, then the dereference should be moved below
	the NULL test.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/).
	
	// <smpl>
	@@
	type T;
	expression E;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E
	      when != i
	  if (E == NULL) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=mini_null3/mini_null_ref3.cocci>mini_null3/mini_null_ref3.cocci</A>  -  Move a dereference below a NULL test
<pre>
	----------------------------
	
	
	If the NULL test is necessary, then the dereference should be moved below
	the NULL test.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/).
	
	// <smpl>
	@disable is_null@
	identifier f;
	expression E;
	identifier fld;
	statement S;
	@@
	
	+ if (E == NULL) S
	  f(...,E->fld,...);
	- if (E == NULL) S
	
	@@
	identifier f;
	expression E;
	identifier fld;
	statement S;
	@@
	
	+ if (!E) S
	  f(...,E->fld,...);
	- if (!E) S
	// </smpl>
	
</pre>
<A HREF=mini_null_check/mini_null_check.cocci>mini_null_check/mini_null_check.cocci</A>  -  Move dereferences below a NULL test
<pre>
	----------------------------
	
	
	If the NULL test is necessary, then the dereferences should be moved below
	the NULL test.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	expression E,E1;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E=E1
	      when != i
	  if (E == NULL||...) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=mini_null_check/second_mini_null_check.cocci>mini_null_check/second_mini_null_check.cocci</A>  -  Move dereferences below a NULL test
<pre>
	----------------------------
	
	
	If the NULL test is necessary, then the dereferences should be moved below
	the NULL test.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	expression E,E1;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E=E1
	      when != i
	  if (E == NULL||...) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=mini_null_ref_aug10/mini_null_ref.cocci>mini_null_ref_aug10/mini_null_ref.cocci</A>  -  Remove potential NULL dereference
<pre>
	If the NULL test is necessary, the initialization involving a dereference of
	the tested value should be moved after the NULL test.
	
	The sematic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	expression E;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E
	      when != i
	  if (E == NULL) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=mini_null_ref_aug14/mini_null_ref.cocci>mini_null_ref_aug14/mini_null_ref.cocci</A>  -  Remove potential NULL dereferences
<pre>
	If the NULL test is necessary, the initialization involving a dereference of
	the tested value should be moved after the NULL test.
	
	The sematic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	expression E;
	identifier i,fld;
	statement S;
	@@
	
	- T i = E->fld;
	+ T i;
	  ... when != E
	      when != i
	  if (E == NULL) S
	+ i = E->fld;
	// </smpl>
	
</pre>
<A HREF=misc_undo/send_m1.cocci>misc_undo/send_m1.cocci</A>  -  Add missing pci_dev_put
<pre>
	----------------------------
	
	
	pci_get_device increments a reference count that should be decremented
	using pci_dev_put.
	
	The semantic patch that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S,S1;
	position p1,p2,p3;
	expression E,E1;
	type T,T1;
	expression *ptr != NULL;
	@@
	
	(
	 if ((x@p1 = pci_get_device(...)) == NULL) S
	|
	 x@p1 = pci_get_device(...);
	)
	 ... when != pci_dev_put(...,(T)x,...)
	     when != if (...) { <+... pci_dev_put(...,(T)x,...) ...+> }
	     when != true x == NULL || ...
	     when != x = E
	     when != E = (T)x
	     when any
	(
	 if (x == NULL || ...) S1
	|
	 if@p2 (...) {
	  ... when != pci_dev_put(...,(T1)x,...)
	      when != if (...) { <+... pci_dev_put(...,(T1)x,...) ...+> }
	      when != x = E1
	      when != E1 = (T1)x
	(
	  return \(0\|<+...x...+>\|ptr\);
	|
	  return@p3 ...;
	)
	}
	)
	
	@ script:python @
	p1 << r.p1;
	p3 << r.p3;
	@@
	
	print \"* file: %s pci_get_device: %s return: %s\" % (p1[0].file,p1[0].line,p3[0].line)
	// </smpl>
	
</pre>
<A HREF=misc_undo/send_m2.cocci>misc_undo/send_m2.cocci</A>  -  Add missing pci_dev_put
<pre>
	----------------------------
	
	
	pci_get_device increments a reference count that should be decremented
	using pci_dev_put.
	
	The semantic patch that finds the problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	statement S,S1;
	position p1,p2,p3;
	expression E,E1;
	type T,T1;
	expression *ptr != NULL;
	@@
	
	(
	 if ((x@p1 = pci_get_device(...)) == NULL) S
	|
	 x@p1 = pci_get_device(...);
	)
	 ... when != pci_dev_put(...,(T)x,...)
	     when != if (...) { <+... pci_dev_put(...,(T)x,...) ...+> }
	     when != true x == NULL || ...
	     when != x = E
	     when != E = (T)x
	     when any
	(
	 if (x == NULL || ...) S1
	|
	 if@p2 (...) {
	  ... when != pci_dev_put(...,(T1)x,...)
	      when != if (...) { <+... pci_dev_put(...,(T1)x,...) ...+> }
	      when != x = E1
	      when != E1 = (T1)x
	(
	  return \(0\|<+...x...+>\|ptr\);
	|
	  return@p3 ...;
	)
	}
	)
	
	@ script:python @
	p1 << r.p1;
	p3 << r.p3;
	@@
	
	print \"* file: %s pci_get_device: %s return: %s\" % (p1[0].file,p1[0].line,p3[0].line)
	// </smpl>
	
</pre>
<A HREF=missing_put/missing_put.cocci>missing_put/missing_put.cocci</A>  -  Add missing of_node_put
<pre>
	Send to:
	wli@holomorphy.com, davem@davemloft.net, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 2/3] arch/sparc: Add missing of_node_put
	
	
	------------------------------------------------------
	
	
	There should be an of_node_put when breaking out of a loop that iterates
	using for_each_node_by_type.
	
	This was detected and fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	identifier d;
	type T;
	expression e;
	iterator for_each_node_by_type;
	@@
	
	T *d;
	...
	for_each_node_by_type(d,...)
	  {... when != of_node_put(d)
	       when != e = d
	(
	   return d;
	|
	+  of_node_put(d);
	?  return ...;
	)
	...}
	// </smpl>
	
</pre>
<A HREF=moduleparam/rule5.cocci>moduleparam/rule5.cocci</A>  -  Drop redundant includes of moduleparam.h
<pre>
	Send to:
	khali@linux-fr.org,
	i2c@lm-sensors.org,
	linux-kernel@vger.kernel.org,
	kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/4] drivers/i2c: Drop redundant includes of moduleparam.h
	
	
	------------------------------------------------------
	
	
	Drop #include <linux/moduleparam.h> in files that also include #include
	<linux/module.h>.  module.h includes moduleparam.h already.
	
	The semantic patch implementing this change is as follows:
	
	@ includesmodule @
	@@
	
	#include <linux/module.h>
	
	@ depends on includesmodule @
	@@
	
	- #include <linux/moduleparam.h>
	
</pre>
<A HREF=more_of_noput/patch.cocci>more_of_noput/patch.cocci</A>  -  Add missing of_node_put
<pre>
	mpc8xx_pic.c
	
	Send to:
	paulus@samba.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 2/3] arch/powerpc/sysdev: Add missing of_node_put
	
	
	------------------------------------------------------
	
	
	The functions of_find_compatible_node and of_find_node_by_type both call
	of_node_get on their result.  So any error handling code thereafter should
	call of_node_put(np).  This is taken care of in the case where there is a goto
	out, but not when there is a direct return.
	
	The function irq_alloc_host puts np into the returned structure, which is
	stored in the global variable mpc8xx_pic_host, so the reference count
	should be set for the lifetime of that variable.  The current solution ups
	the reference count again in the argument to irq_alloc_host so that it can
	be decremented on the way out.  This seems a bit unnecessary, and also
	doesn't work in the case where irq_alloc_host fails, because then the
	reference count only goes does by one, whereas it should go down by two.  A
	better solution is to not increment the reference count in the argument to
	irq_alloc_host and only decrement it on the way out in an error case.
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2,x3;
	int ret;
	@@
	
	  T E;
	  ...
	* E = \(of_get_parent\|of_find_compatible_node\)(...);
	  if (E == NULL) S
	  ... when != of_node_put(...,(T1)E,...)
	      when != if (E != NULL) { ... of_node_put(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	  if (...) {
	    ... when != of_node_put(...,(T2)E,...)
	        when != if (E != NULL) { ... of_node_put(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=more_pci/get_slot.cocci>more_pci/get_slot.cocci</A>  -  Add missing pci_dev_get
<pre>
	drivers/macintosh/via-pmu.c
	
	Send to:
	benh@kernel.crashing.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/macintosh: Add missing pci_dev_get
	
	------------------------------------------------------
	
	
	pci_get_bus_and_slot does a pci_dev_get, so pci_dev_put needs to be called
	in an error case.
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@exists@
	type T1,T2;
	identifier E;
	statement S,S1;
	expression x1,x2,x3;
	expression test;
	int ret != 0;
	@@
	
	  struct pci_dev *E;
	  ...
	(
	  E = \(pci_get_slot\|pci_get_device\|pci_get_bus_and_slot\)(...);
	  if (E == NULL) S
	|
	  if ((E = \(pci_get_slot\|pci_get_device\|pci_get_bus_and_slot\)(...)) == NULL) S
	)
	  ... when != pci_dev_put(...,(T1)E,...)
	      when != if (E != NULL) { ... pci_dev_put(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	(
	  if (E == NULL) S1
	|
	  if (test)
	+   {
	(
	+   pci_dev_put(E);
	    return;
	|
	+   pci_dev_put(E);
	    return ret;
	)
	+   }
	|
	  if (test) {
	    ... when != pci_dev_put(...,(T2)E,...)
	        when != if (E != NULL) { ... pci_dev_put(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	+   pci_dev_put(E);
	    return;
	|
	+   pci_dev_put(E);
	    return ret;
	)
	  }
	)
	// </smpl>
	
</pre>
<A HREF=more_pci/more_pci.cocci>more_pci/more_pci.cocci</A>  -  Add missing pci_dev_get
<pre>
	drivers/macintosh/via-pmu.c
	
	Send to:
	benh@kernel.crashing.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/macintosh: Add missing pci_dev_get
	
	------------------------------------------------------
	
	
	pci_get_bus_and_slot does a pci_dev_get, so pci_dev_put needs to be called
	in an error case.
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@exists@
	type T1,T2;
	identifier E;
	statement S,S1;
	expression x1,x2,x3;
	expression test;
	int ret != 0;
	@@
	
	  struct pci_dev *E;
	  ...
	(
	  E = \(pci_get_slot\|pci_get_device\|pci_get_bus_and_slot\)(...);
	  if (E == NULL) S
	|
	  if ((E = \(pci_get_slot\|pci_get_device\|pci_get_bus_and_slot\)(...)) == NULL) S
	)
	  ... when != pci_dev_put(...,(T1)E,...)
	      when != if (E != NULL) { ... pci_dev_put(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	(
	  if (E == NULL) S1
	|
	  if (test)
	+   {
	(
	+   pci_dev_put(E);
	    return;
	|
	+   pci_dev_put(E);
	    return ret;
	)
	+   }
	|
	  if (test) {
	    ... when != pci_dev_put(...,(T2)E,...)
	        when != if (E != NULL) { ... pci_dev_put(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	+   pci_dev_put(E);
	    return;
	|
	+   pci_dev_put(E);
	    return ret;
	)
	  }
	)
	// </smpl>
	
</pre>
<A HREF=mutex/mut.cocci>mutex/mut.cocci</A>  -  Release mutex in error handling code
<pre>
	----------------------------
	
	
	The mutex is released on a successful return, so it would seem that it
	should be released on an error return as well.
	
	The semantic patch finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression l;
	@@
	
	mutex_lock(l);
	... when != mutex_unlock(l)
	    when any
	    when strict
	(
	if (...) { ... when != mutex_unlock(l)
	+   mutex_unlock(l);
	    return ...;
	}
	|
	mutex_unlock(l);
	)
	// </smpl>
	
</pre>
<A HREF=mutex2/mutex2.cocci>mutex2/mutex2.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=noderef/noderef.cocci>noderef/noderef.cocci</A>  -  correct size computation
<pre>
	----------------------------
	
	
	The size argument to ioremap_nocache should be the size of desired
	information, not the pointer to it.
	
	The semantic match that finds this problem:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@expression@
	expression *x;
	@@
	
	x =
	 <+...
	*sizeof(x)
	...+>// </smpl>
	
</pre>
<A HREF=noderef2/noderef2.cocci>noderef2/noderef2.cocci</A>  -  Correct size given to memset
<pre>
	----------------------------
	
	
	Memset should be given the size of the structure, not the size of the pointer.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	T *x;
	expression E;
	@@
	
	memset(x, E, sizeof(
	+ *
	 x))
	// </smpl>
	
</pre>
<A HREF=notnull/notnull.cocci>notnull/notnull.cocci</A>  -  Remove redundant test
<pre>
	----------------------------
	
	
	atif is tested for being NULL twice, with the same effect in each case.  I
	have kept the second test, as it seems to fit well with the comment above it.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E;
	position p1,p2;
	@@
	
	if (x@p1 == NULL || ...) { ... when forall
	   return ...; }
	... when != \(x=E\|x--\|x++\|--x\|++x\|x-=E\|x+=E\|x|=E\|x&=E\|&x\)
	(
	x@p2 == NULL
	|
	x@p2 != NULL
	)
	
	// another path to the test that is not through p1?
	@s exists@
	local idexpression r.x;
	position r.p1,r.p2;
	@@
	
	... when != x@p1
	(
	x@p2 == NULL
	|
	x@p2 != NULL
	)
	
	@fix depends on !s@
	position r.p1,r.p2;
	expression x,E;
	statement S1,S2;
	@@
	
	(
	- if ((x@p2 != NULL) || ...)
	  S1
	|
	- if ((x@p2 == NULL) && ...) S1
	|
	- BUG_ON(x@p2 == NULL);
	)
	// </smpl>
	
</pre>
<A HREF=notnull/notnull2.cocci>notnull/notnull2.cocci</A>  -  Remove redundant test
<pre>
	----------------------------
	
	
	atif is tested for being NULL twice, with the same effect in each case.  I
	have kept the second test, as it seems to fit well with the comment above it.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E;
	position p1,p2;
	@@
	
	if (x@p1 == NULL || ...) { ... when forall
	   return ...; }
	... when != \(x=E\|x--\|x++\|--x\|++x\|x-=E\|x+=E\|x|=E\|x&=E\|&x\)
	(
	x@p2 == NULL
	|
	x@p2 != NULL
	)
	
	// another path to the test that is not through p1?
	@s exists@
	local idexpression r.x;
	position r.p1,r.p2;
	@@
	
	... when != x@p1
	(
	x@p2 == NULL
	|
	x@p2 != NULL
	)
	
	@fix depends on !s@
	position r.p1,r.p2;
	expression x,E;
	statement S1,S2;
	@@
	
	(
	- if ((x@p2 != NULL) || ...)
	  S1
	|
	- if ((x@p2 == NULL) && ...) S1
	|
	- BUG_ON(x@p2 == NULL);
	)
	// </smpl>
	
</pre>
<A HREF=null_ref/null_ref.cocci>null_ref/null_ref.cocci</A>  -  Move dereference after NULL test
<pre>
	----------------------------
	
	
	If the NULL test on buf is needed, then the dereference should be after the
	NULL test.
	
	A simplified version of the semantic match that detects this problem is as
	follows (http://coccinelle.lip6.fr/):
	
	// <smpl>
	@match exists@
	expression x, E;
	identifier fld;
	@@
	
	* x->fld
	  ... when != \(x = E\|&x\)
	* x == NULL
	// </smpl>
	
</pre>
<A HREF=null_ref2/mini_null_ref2.cocci>null_ref2/mini_null_ref2.cocci</A>  -  Adjust NULL test
<pre>
	----------------------------
	
	
	Since ei is already known to be non-NULL, I assume that what was intended
	was to test the result of kzalloc.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E,E1;
	identifier f,fld,fld1;
	statement S1,S2;
	@@
	
	E->fld = f(...);
	... when != E = E1
	    when != E->fld1 = E1
	if (
	-   E
	+   E->fld
	           == NULL) S1 else S2
	// </smpl>
	
</pre>
<A HREF=oddpe/oddpe.cocci>oddpe/oddpe.cocci</A>  -  adjust inconsistent IS_ERR and PTR_ERR
<pre>
	Change the call to PTR_ERR to access the value just tested by IS_ERR.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1;
	@@
	
	(
	if (IS_ERR(e)) { ... PTR_ERR(e) ... }
	|
	if (IS_ERR(e=e1)) { ... PTR_ERR(e) ... }
	|
	*if (IS_ERR(e))
	 { ...
	*  PTR_ERR(e1)
	   ... }
	)
	// </smpl>
	
</pre>
<A HREF=of_noput/of_noput.cocci>of_noput/of_noput.cocci</A>  -  Add missing of_node_put
<pre>
	Send to:
	olof@lixom.net, paulus@samba.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] arch/powerpc: Add missing of_node_put
	
	
	------------------------------------------------------
	
	
	There should be an of_node_put when breaking out of a loop that iterates
	over calls to of_find_all_nodes, as this function does an of_node_get on
	the value it returns.
	
	This was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	identifier d;
	expression e;
	@@
	
	T *d;
	...
	for (d = NULL; (d = of_find_all_nodes(d)) != NULL; )
	 {... when != of_node_put(d)
	      when != e = d
	(
	   return d;
	|
	+  of_node_put(d);
	?  return ...;
	)
	...}
	// </smpl>
	
</pre>
<A HREF=offset/offset.cocci>offset/offset.cocci</A>  -  Use offsetof
<pre>
	Send to:
	tglx@linutronix.de, viro@ftp.linux.org.uk, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/3] arch/x86: Use offsetof
	
	
	------------------------------------------------------
	
	In the patch cc154ac64aa8d3396b187f64cef01ce67f433324, Al Viro observed
	that the proper way to compute the distance between two structure fields is
	to use offsetof() or a cast to a pointer to character.  The same change can
	be applied to a few more files.
	
	The change was made using the following semantic patch
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	type T;
	T s;
	type T1, T2;
	identifier fld1, fld2;
	typedef uint8_t;
	typedef u8;
	@@
	
	(
	  (char *)&s.fld1 - (char *)&s.fld2
	|
	  (uint8_t *)&s.fld1 - (uint8_t *)&s.fld2
	|
	  (u8 *)&s.fld1 - (u8 *)&s.fld2
	|
	- (T1)&s.fld1 - (T2)&s.fld2
	+ offsetof(T,fld1) - offsetof(T,fld2)
	)
	// </smpl>
	
</pre>
<A HREF=ofiomap/of_iomap-iounmap.cocci>ofiomap/of_iomap-iounmap.cocci</A>  -  Add missing iounmap
<pre>
	drivers/pcmcia/m8xx_pcmcia.c
	
	Send to:
	linux-pcmcia@lists.infradead.org, vbordug@ru.mvista.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] drivers/pcmcia: Add missing iounmap
	
	------------------------------------------------------
	
	
	of_iomap calls ioremap, and so should be matched with an iounmap.  At the
	two error returns, the result of calling of_iomap is only stored in a local
	variable, so these error paths need to call iounmap.  Furthermore, this
	function ultimately stores the result of of_iomap in an array that is local
	to the file.  These values should be iounmapped at some point.  I have
	added a corresponding call to iounmap at the end of the function m8xx_remove.
	
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2,x3;
	int ret;
	@@
	
	  T E;
	  ...
	* E = of_iomap(...);
	  if (E == NULL) S
	  ... when != iounmap(...,(T1)E,...)
	      when != if (E != NULL) { ... iounmap(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	  if (...) {
	    ... when != iounmap(...,(T2)E,...)
	        when != if (E != NULL) { ... iounmap(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=ofnametype/ofname1.cocci>ofnametype/ofname1.cocci</A>  -  add missing of_node_put
<pre>
	----------------------------
	
	
	of_node_put is needed before discarding a value received from
	of_find_node_by_type, eg in error handling code.
	
	The semantic patch that makes the change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct device_node *n;
	struct device_node *n1;
	struct device_node *n2;
	statement S;
	identifier f1,f2;
	expression E1,E2;
	constant C;
	@@
	
	n = of_find_node_by_type(...)
	...
	if (!n) S
	... when != of_node_put(n)
	    when != n1 = f1(n,...)
	    when != E1 = n
	    when any
	    when strict
	(
	+ of_node_put(n);
	  return -C;
	|
	  of_node_put(n);
	|
	  n2 = f2(n,...)
	|
	  E2 = n
	|
	  return ...;
	)
	// </smpl>
	
</pre>
<A HREF=ofnametype/oftype1.cocci>ofnametype/oftype1.cocci</A>  -  add missing of_node_put
<pre>
	----------------------------
	
	
	of_node_put is needed before discarding a value received from
	of_find_node_by_type, eg in error handling code.
	
	The semantic patch that makes the change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct device_node *n;
	struct device_node *n1;
	struct device_node *n2;
	statement S;
	identifier f1,f2;
	expression E1,E2;
	constant C;
	@@
	
	n = of_find_node_by_type(...)
	...
	if (!n) S
	... when != of_node_put(n)
	    when != n1 = f1(n,...)
	    when != E1 = n
	    when any
	    when strict
	(
	+ of_node_put(n);
	  return -C;
	|
	  of_node_put(n);
	|
	  n2 = f2(n,...)
	|
	  E2 = n
	|
	  return ...;
	)
	// </smpl>
	
</pre>
<A HREF=ofnodeget/ofnodeget.cocci>ofnodeget/ofnodeget.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	Add a call to of_node_put in the error handling code following a call to
	of_find_compatible_node.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E,E1;
	statement S;
	@@
	
	*x = 
	(of_find_node_by_path
	|of_find_node_by_name
	|of_find_node_by_phandle
	|of_get_parent
	|of_get_next_parent
	|of_get_next_child
	|of_find_compatible_node
	|of_match_node
	)(...);
	...
	if (x == NULL) S
	<... when != x = E
	*if (...) {
	  ... when != of_node_put(x)
	      when != if (...) { ... of_node_put(x); ... }
	(
	  return <+...x...+>;
	|
	*  return ...;
	)
	}
	...>
	of_node_put(x);
	// </smpl>
	
</pre>
<A HREF=ofnodeget/ofnodeget1.cocci>ofnodeget/ofnodeget1.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	Add a call to of_node_put in the error handling code following a call to
	of_find_compatible_node.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E,E1;
	statement S;
	@@
	
	*x = 
	(of_find_node_by_path
	|of_find_node_by_name
	|of_find_node_by_phandle
	|of_get_parent
	|of_get_next_parent
	|of_get_next_child
	|of_find_compatible_node
	|of_match_node
	)(...);
	...
	if (x == NULL) S
	<... when != x = E
	*if (...) {
	  ... when != of_node_put(x)
	      when != if (...) { ... of_node_put(x); ... }
	(
	  return <+...x...+>;
	|
	*  return ...;
	)
	}
	...>
	of_node_put(x);
	// </smpl>
	
</pre>
<A HREF=ofnodeget/ofnodeget2.cocci>ofnodeget/ofnodeget2.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	Add a call to of_node_put in the error handling code following a call to
	of_find_compatible_node.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E,E1;
	statement S;
	@@
	
	*x = 
	(of_find_node_by_path
	|of_find_node_by_name
	|of_find_node_by_phandle
	|of_get_parent
	|of_get_next_parent
	|of_get_next_child
	|of_find_compatible_node
	|of_match_node
	)(...);
	...
	if (x == NULL) S
	<... when != x = E
	*if (...) {
	  ... when != of_node_put(x)
	      when != if (...) { ... of_node_put(x); ... }
	(
	  return <+...x...+>;
	|
	*  return ...;
	)
	}
	...>
	of_node_put(x);
	// </smpl>
	
</pre>
<A HREF=ofnodeget3/ofnodeget3.cocci>ofnodeget3/ofnodeget3.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	This function is implemented as though the function of_get_next_child does
	not increment the reference count of its result, but actually it does.
	Thus the patch adds of_node_put in error handling code and drops a call to
	of_node_get.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	local idexpression x;
	expression E1;
	position p1,p2;
	@@
	
	x@p1 = of_get_next_child(...);
	... when != x = E1
	of_node_get@p2(x)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	
	cocci.print_main(\"call\",p1)
	cocci.print_secs(\"get\",p2)
	// </smpl>
	
</pre>
<A HREF=ofnodeget4/ofnodeget4.cocci>ofnodeget4/ofnodeget4.cocci</A>  -  Add of_node_put to avoid memory leak
<pre>
	In this case, a device_node structure is stored in another structure that
	is then freed without first decrementing the reference count of the
	device_node structure.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression x;
	identifier f;
	position p1,p2;
	@@
	
	x@p1->f = \(of_find_node_by_path\|of_find_node_by_name\|of_find_node_by_phandle\|of_get_parent\|of_get_next_parent\|of_get_next_child\|of_find_compatible_node\|of_match_node\|of_find_node_by_type\|of_find_node_with_property\|of_find_matching_node\|of_parse_phandle\|of_node_get\)(...);
	... when != of_node_put(x)
	kfree@p2(x)
	
	@script:python@
	p1 << r.p1;
	p2 << r.p2;
	@@
	cocci.print_main(\"call\",p1)
	cocci.print_secs(\"free\",p2)
	// </smpl>
	
</pre>
<A HREF=ofredef/ofredef.cocci>ofredef/ofredef.cocci</A>  -  add missing of_node_put
<pre>
	np is initialized to the result of calling a function that calls
	of_node_get, so of_node_put should be called before the pointer is dropped.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1,e2;
	@@
	
	* e = \(of_find_node_by_type\|of_find_node_by_name\)(...)
	  ... when != of_node_put(e)
	      when != true e == NULL
	      when != e2 = e
	  e = e1
	// </smpl>
	
</pre>
<A HREF=osdi_isnull/osdi_isnull.cocci>osdi_isnull/osdi_isnull.cocci</A>  -  Eliminate what looks like a NULL pointer dereference
<pre>
	----------------------------
	
	
	At the point of the test, action cannot be NULL, as it has been dereferenced
	in the code just above.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression E,E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	if ((E == NULL && ...) || ...)
	{
	  ... when != if (...) S1 else S2
	      when != E = E1
	* E->f
	  ... when any
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=osdi_isnull/osdi_isnull3.cocci>osdi_isnull/osdi_isnull3.cocci</A>  -  Eliminate what looks like a NULL pointer dereference
<pre>
	----------------------------
	
	
	At the point of the test, action cannot be NULL, as it has been dereferenced
	in the code just above.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression E,E1;
	identifier f;
	statement S1,S2,S3;
	@@
	
	if ((E == NULL && ...) || ...)
	{
	  ... when != if (...) S1 else S2
	      when != E = E1
	* E->f
	  ... when any
	}
	else S3
	// </smpl>
	
</pre>
<A HREF=osdi_kfree/osdi_kfree.cocci>osdi_kfree/osdi_kfree.cocci</A>  -  Eliminate use after free
<pre>
	----------------------------
	
	
	The skip label frees resp, which has not been allocated at the point of
	this goto and then does a break, based on the fact that err is non-zero.
	This is replaced by a break directly.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@free@
	expression E;
	position p;
	@@
	kfree@p(E)
	
	@@
	expression free.E, subE<=free.E, E1;
	position free.p;
	@@
	
	  kfree@p(E)
	  ...
	(
	  subE = E1
	|
	* E
	)
	// </smpl>
	
</pre>
<A HREF=parport/sp8188.cocci>parport/sp8188.cocci</A>  -  Put gotten port value
<pre>
	parport_find_number calls parport_get_port on its result, so there should
	be a corresponding call to parport_put_port before dropping the reference.
	Similar code is found in the function register_device in the same file.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression struct parport * x;
	expression ra,rr;
	statement S1,S2;
	@@
	
	x = parport_find_number(...)
	... when != x = rr
	    when any
	    when != parport_put_port(x,...)
	    when != if (...) { ... parport_put_port(x,...) ...}
	(
	if(<+...x...+>) S1 else S2
	|
	if(...) { ... when != x = ra
	     when forall
	     when != parport_put_port(x,...)
	*return...;
	}
	)
	// </smpl>
	
</pre>
<A HREF=parse_phandle/parse_phandle.cocci>parse_phandle/parse_phandle.cocci</A>  -  add missing of_node_put
<pre>
	of_parse_phandle increments the reference count of np, so this should be
	decremented before trying the next possibility.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,e1,e2;
	@@
	
	*e = of_parse_phandle(...)
	... when != of_node_put(e)
	    when != true e == NULL
	    when != e2 = e
	e = e1
	// </smpl>
	
</pre>
<A HREF=pci_add_put/pci_noputm.cocci>pci_add_put/pci_noputm.cocci</A>  -  Add missing pci_dev_put
<pre>
	Send to:
	perex@suse.cz, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 5/5] sound/core/memalloc.c: Add missing pci_dev_put
	
	
	------------------------------------------------------
	
	
	There should be a pci_dev_put when breaking out of a loop that iterates
	over calls to pci_get_device and similar functions.
	
	In this case, the return under the initial if needs a pci_dev_put in the
	same way that the return under the subsequent for loop has a pci_dev_put.
	
	This was fixed using the following semantic patch.
	
	// <smpl>
	@@
	type T;
	identifier d;
	expression e;
	@@
	
	T *d;
	...
	while ((d = \(pci_get_device\|pci_get_device_reverse\|pci_get_subsys\|pci_get_class\)(..., d)) != NULL)
	 {... when != pci_dev_put(d)
	      when != e = d
	(
	   return d;
	|
	+  pci_dev_put(d);
	?  return ...;
	)
	...}
	// </smpl>
	
</pre>
<A HREF=pci_drop_put/pci_get.cocci>pci_drop_put/pci_get.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=pciom/pciom3.cocci>pciom/pciom3.cocci</A>  -  exchange pci_iounmaps
<pre>
	The calls to pci_iounmap are in the wrong order, as compared to the
	associated calls to pci_iomap.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e,x;
	statement S,S1;
	int ret;
	@@
	e = pci_iomap(x,...)
	... when != pci_iounmap(x,e)
	if (<+...e...+>) S
	... when any
	    when != pci_iounmap(x,e)
	*if (...)
	   { ... when != pci_iounmap(x,e)
	     return ...; }
	... when any
	pci_iounmap(x,e);
	// </smpl>
	
</pre>
<A HREF=pd/pd.cocci>pd/pd.cocci</A>  -  Invert calls to platform_device_put and platform_device_del
<pre>
	Platform_device_del should be called before platform_device_put, as
	platform_device_put can delete the structure.
	
	Additionally, improve the error handling code for the call to ioremap, so
	that it calls platform_device_put.
	
	The semantic match that finds this problem is:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e1,e2;
	@@
	
	*platform_device_put(e1);
	... when != e1 = e2
	*platform_device_del(e1);
	// </smpl>
	
</pre>
<A HREF=platret/platret.cocci>platret/platret.cocci</A>  -  failure test for null rather than negative integer
<pre>
	dev_get_platdata returns a pointer, so the failure value would be NULL
	rather than a negative integer.
	
	The semantic match that finds this problem is: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e;
	statement S1,S2;
	@@
	
	*x = dev_get_platdata(...)
	... when != x = e
	*if (x < 0) S1 else S2
	// </smpl>
	
</pre>
<A HREF=pointless_err/pointless_err.cocci>pointless_err/pointless_err.cocci</A>  -  Use ERR_CAST
<pre>
	----------------------------
	
	
	Use ERR_CAST(x) rather than ERR_PTR(PTR_ERR(x)).  The former makes more
	clear what is the purpose of the operation, which otherwise looks like a
	no-op.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	type T;
	T x;
	identifier f;
	@@
	
	T f (...) { <+...
	- ERR_PTR(PTR_ERR(x))
	+ x
	 ...+> }
	
	@@
	expression x;
	@@
	
	- ERR_PTR(PTR_ERR(x))
	+ ERR_CAST(x)
	// </smpl>
	
</pre>
<A HREF=prepare2/prepare2.cocci>prepare2/prepare2.cocci</A>  -  use clk_prepare_enable and clk_disable_unprepare
<pre>
	Clk_prepare_enable and clk_disable_unprepare combine clk_prepare and
	clk_enable, and clk_disable and clk_unprepare.  They make the code more
	concise, and ensure that clk_unprepare is called when clk_enable fails.
	
	A simplified version of the semantic patch that introduces calls to these
	functions is as follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression e;
	@@
	
	- clk_prepare(e);
	- clk_enable(e);
	+ clk_prepare_enable(e);
	
	@@
	expression e;
	@@
	
	- clk_disable(e);
	- clk_unprepare(e);
	+ clk_disable_unprepare(e);
	// </smpl>
	
</pre>
<A HREF=ptr/ptr.cocci>ptr/ptr.cocci</A>  -  Correct error handling code
<pre>
	----------------------------
	
	
	If it is reasonable to apply PTR_ERR to the result of calling clk_get, then
	that result should first be tested with IS_ERR, not with !.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E,E1;
	@@
	
	if (
	-   E == NULL
	+   IS_ERR(E)
	   ) { <+... when != E = E1
	        PTR_ERR(E)
	       ...+> }
	// </smpl>
	
</pre>
<A HREF=put_after/put_after.cocci>put_after/put_after.cocci</A>  -  add missing of_node_put
<pre>
	dma_channel_np has been accessed at this point, so decrease its reference
	count before leaving the function.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	identifier x;
	expression E1!=0,E2,E3,E4;
	statement S;
	iterator I;
	@@
	
	(
	if (...) { ... when != of_node_put(x)
	               when != x = E3
	               when != E3 = x
	*  return ...;
	 }
	... when != x = E2
	    when != I(...,x,...) S
	if (...) { ... when != x = E4
	 of_node_put(x); ... return ...; }
	)
	// </smpl>
	
</pre>
<A HREF=put_deref/patch.cocci>put_deref/patch.cocci</A>  -  move of_node_put
<pre>
	----------------------------
	
	
	It seems better to dereference master before decrementing the reference
	count rather than afterwards.
	
	The problem was found using the following semantic match:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@
	expression n,E;
	identifier fld;
	iterator I;
	statement S;
	@@
	
	* of_node_put(n)
	... when != n = E
	    when != I(n,...) S
	* n->fld
	// </smpl>
	
</pre>
<A HREF=putty/putty.cocci>putty/putty.cocci</A>  -  avoid calling put_tty_driver on NULL
<pre>
	put_tty_driver calls tty_driver_kref_put on its argument, and then
	tty_driver_kref_put calls kref_put on the address of a field of this
	argument.  kref_put checks for NULL, but in this case the field is likely
	to have some offset and so the result of taking its address will not be
	NULL.  Labels are added to be able to skip over the call to put_tty_driver
	when the argument will be NULL.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *x;
	@@
	
	*if (x == NULL)
	{ ...
	* put_tty_driver(x);
	  ...
	  return ...;
	}
	// </smpl>
	
</pre>
<A HREF=rcu/rcu.cocci>rcu/rcu.cocci</A>  -  call rcu_read_unlock in default case
<pre>
	----------------------------
	
	
	Adjust the default case so that it benefits from the call to rcu_read_unlock.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@rcu@
	position p1;
	@@
	
	rcu_read_lock@p1();
	...
	rcu_read_unlock();
	
	@@
	position rcu.p1;
	@@
	
	*rcu_read_lock@p1();
	... when != rcu_read_unlock();
	// </smpl>
	
</pre>
<A HREF=reiserfs/category2a_open_xa_dir.cocci>reiserfs/category2a_open_xa_dir.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function open_xa_dir returns an ERR pointer,
	but never returns a NULL pointer. So a NULL test that comes after an
	IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = open_xa_dir(...)
	... when != x = E
	(
	*  if (x == NULL && ...) S1 else S2
	|
	*  if (x == NULL || ...) S1 else S2
	)
	// </smpl>
	
</pre>
<A HREF=remap_bar/remap_bar.cocci>remap_bar/remap_bar.cocci</A>  -  reorder error handling code to include iounmap
<pre>
	The out_msi_disable label should be before cleanup_nomem to additionally
	benefit from the call to iounmap.  Subsequent gotos are adjusted to go to
	out_msi_disable instead of cleanup_nomem, which now follows it.  This is
	safe because pci_disable_msi does nothing if pci_enable_msi was not called.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	expression e1,e2;
	statement S;
	@@
	
	e1 = pci_ioremap_bar(...);
	... when != e1 = e2
	    when != iounmap(e1)
	    when any
	(
	 if (<+...e1...+>) S
	|
	 if(...) { ... return 0; }
	|
	 if (...) { ... when != iounmap(e1)
	                when != if (...) { ... iounmap(e1) ... }
	* return ...;
	 } else S
	)
	// </smpl>
	
</pre>
<A HREF=remove/remove.cocci>remove/remove.cocci</A>  -  Drop return value from platform_driver remove functions
<pre>
	----------------------------
	
	
	The return value of the remove function of a driver structure, and thus of
	a platform_driver structure, is ultimately ignored, and is thus
	unnecessary.  This patch removes the return value for the remove function
	stored in a platform_driver structure.  For the files in this patch, the
	return values are always 0.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r@
	struct platform_driver I;
	identifier a,f;
	position p;
	@@
	I.remove = \(f@p\|a(f@p)\);
	
	@void_called@
	identifier r.f;
	position p;
	@@
	f@p(...);
	
	@called@
	identifier r.f;
	position p1 != void_called.p;
	@@
	f@p1(...)
	
	@localfn@
	identifier r.f;
	@@
	static int f(...) { ... }
	
	@depends on !called && localfn@
	struct platform_driver I;
	identifier a,f;
	position r.p;
	@@
	
	I.
	- remove
	+ remove_new
	   = \(f@p\|a(f@p)\);
	
	@depends on !called && localfn@
	identifier r.f,i;
	constant C;
	expression E;
	@@
	
	- int
	+ void
	       f(...) {
	  <...
	(
	-  return \(C\|i\);
	+  return;
	|
	-  return E;
	+  E;
	+  return;
	)
	  ...>
	}
	// </smpl>
	
</pre>
<A HREF=reqrel2/reqrel2.cocci>reqrel2/reqrel2.cocci</A>  -  Use release_mem_region after request_mem_region
<pre>
	The memory allocated using request_mem_region should be released using
	release_mem_region, not release_region.
	
	The semantic patch that fixes part of this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E1,E2,E3;
	@@
	
	request_mem_region(E1,E2,E3)
	...
	?- release_region(E1,E2)
	+ release_mem_region(E1,E2)
	// </smpl>
	
</pre>
<A HREF=requests/diou.cocci>requests/diou.cocci</A>  -  fix usage of devm functions
<pre>
	Fix some problems with the use of devm_ functions.
	
	devm_kzalloc: devm_kfree is not needed
	
	devm_ioremap: iounmap should not be used, no free is needed
	
	devm_request_irq: the devm_free_irq is followed by irq_dispose_mapping.  I
	don't know if it is safe to move the freeing of the irq in this case, so I
	have just un-devm'd this function, since the implicit freeing is never
	taken advantage of.
	
	In the original code failure of of_address_to_resource jumped to free_mem,
	but should have jumped to irq_dispose, since irq_of_parse_and_map has
	completed at this point.
	
	In the original code unmap_mem was after irq_dispose, but it should have
	been before, again since irq_of_parse_and_map has completed at this point.
	
	One of these problems was found using the following semantic match:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x;
	@@
	
	*x = devm_ioremap(...)
	...
	iounmap(x);
	// </smpl>
	
</pre>
<A HREF=requests/dirq.cocci>requests/dirq.cocci</A>  -  fix usage of devm functions
<pre>
	Fix some problems with the use of devm_ functions.
	
	devm_kzalloc: devm_kfree is not needed
	
	devm_ioremap: iounmap should not be used, no free is needed
	
	devm_request_irq: the devm_free_irq is followed by irq_dispose_mapping.  I
	don't know if it is safe to move the freeing of the irq in this case, so I
	have just un-devm'd this function, since the implicit freeing is never
	taken advantage of.
	
	In the original code failure of of_address_to_resource jumped to free_mem,
	but should have jumped to irq_dispose, since irq_of_parse_and_map has
	completed at this point.
	
	In the original code unmap_mem was after irq_dispose, but it should have
	been before, again since irq_of_parse_and_map has completed at this point.
	
	One of these problems was found using the following semantic match:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x;
	@@
	
	*x = devm_ioremap(...)
	...
	iounmap(x);
	// </smpl>
	
</pre>
<A HREF=resource/reg.cocci>resource/reg.cocci</A>  -  Convert release_resource to release_region/release_mem_region
<pre>
	Request_region should be used with release_region, not release_resource.
	
	This patch contains a number of changes, related to calls to request_region,
	request_mem_region, and the associated error handling code.
	
	1. For the call to request_region, the variable io_resource storing the
	result is dropped.  The call to release_resource at the end of the function
	is changed to a call to release_region with the first two arguments of
	request_region as its arguments.  The same call to release_region is also
	added to release_ipwireless.
	
	2. The first call to request_mem_region is now tested and ret is set to
	-EBUSY if the the call has failed.  This call was associated with the
	initialization of ipw->attr_memory.  But the error handling code was
	testing ipw->common_memory.  The definition of release_ipwireless also
	suggests that this call should be associated with ipw->common_memory, not
	ipw->attr_memory.
	
	3. The second call to request_mem_region is now tested and ret is
	set to -EBUSY if the the call has failed.
	
	4. The various gotos to the error handling code is adjusted so that there
	is no need for ifs.
	
	5. Return the value stored in the ret variable rather than -1.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,E;
	@@
	(
	*x = request_region(...)
	|
	*x = request_mem_region(...)
	)
	... when != release_region(x)
	    when != x = E
	* release_resource(x);
	// </smpl>
	
</pre>
<A HREF=resource/resource.cocci>resource/resource.cocci</A>  -  Convert release_resource to release_region/release_mem_region
<pre>
	Request_region should be used with release_region, not release_resource.
	
	This patch contains a number of changes, related to calls to request_region,
	request_mem_region, and the associated error handling code.
	
	1. For the call to request_region, the variable io_resource storing the
	result is dropped.  The call to release_resource at the end of the function
	is changed to a call to release_region with the first two arguments of
	request_region as its arguments.  The same call to release_region is also
	added to release_ipwireless.
	
	2. The first call to request_mem_region is now tested and ret is set to
	-EBUSY if the the call has failed.  This call was associated with the
	initialization of ipw->attr_memory.  But the error handling code was
	testing ipw->common_memory.  The definition of release_ipwireless also
	suggests that this call should be associated with ipw->common_memory, not
	ipw->attr_memory.
	
	3. The second call to request_mem_region is now tested and ret is
	set to -EBUSY if the the call has failed.
	
	4. The various gotos to the error handling code is adjusted so that there
	is no need for ifs.
	
	5. Return the value stored in the ret variable rather than -1.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,E;
	@@
	(
	*x = request_region(...)
	|
	*x = request_mem_region(...)
	)
	... when != release_region(x)
	    when != x = E
	* release_resource(x);
	// </smpl>
	
</pre>
<A HREF=resource_fix1/resource_fix1.cocci>resource_fix1/resource_fix1.cocci</A>  -  Convert release_resource to release_mem_region
<pre>
	Request_mem_region should be used with release_mem_region, not
	release_resource.
	
	A semantic patch that partially fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@b@
	expression x,E;
	@@
	
	x = request_mem_region(x->start,...)
	... when != release_mem_region(x->start,...)
	    when != x = E
	(
	- release_resource(x);
	- kfree(x);
	+  release_mem_region(x->start,resource_size(x));
	|
	?- release_resource(x);
	+  release_mem_region(x->start,resource_size(x));
	)
	// </smpl>
	
</pre>
<A HREF=resource_size/resource_size.cocci>resource_size/resource_size.cocci</A>  -  Use resource_size
<pre>
	----------------------------
	
	
	Use the function resource_size, which reduces the chance of introducing
	off-by-one errors in calculating the resource size.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct resource *res;
	@@
	
	- (res->end - res->start) + 1
	+ resource_size(res)
	// </smpl>
	
</pre>
<A HREF=ret3/ret3.cocci>ret3/ret3.cocci</A>  -  fix error return code
<pre>
	Convert a nonnegative error return code to a negative one, as returned
	elsewhere in the function.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	identifier ret;
	expression e1,e2;
	@@
	
	if (ret < 0)
	 { ... return ret; }
	 ... when != ret = e1
	     when forall
	*if(...)
	 {
	  ... when != ret = e2
	* return ret;
	 }
	// </smpl>
	
</pre>
<A HREF=ret4/ret4.cocci>ret4/ret4.cocci</A>  -  fix error return code
<pre>
	Initialize return variable before exiting on an error path.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	(
	if@p1 (\(ret < 0\|ret != 0\))
	 { ... return ret; }
	|
	ret@p1 = 0
	)
	... when != ret = e1
	    when != &ret
	*if(...)
	{
	  ... when != ret = e2
	      when forall
	 return ret;
	}
	
	// </smpl>
	
</pre>
<A HREF=retalloc/retalloc.cocci>retalloc/retalloc.cocci</A>  -  fix error return code
<pre>
	Convert a 0 error return code to a negative one, as returned elsewhere in the
	function.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	identifier ret;
	expression e,e1,e2,e3,e4,x;
	@@
	
	(
	if (\(ret != 0\|ret < 0\) || ...) { ... return ...; }
	|
	ret = 0
	)
	... when != ret = e1
	*x = \(kmalloc\|kzalloc\|kcalloc\|devm_kzalloc\|ioremap\|ioremap_nocache\|devm_ioremap\|devm_ioremap_nocache\)(...);
	... when != x = e2
	    when != ret = e3
	*if (x == NULL || ...)
	{
	  ... when != ret = e4
	*  return ret;
	}
	// </smpl>
	
</pre>
<A HREF=rirqp/rirqp.cocci>rirqp/rirqp.cocci</A>  -  ensure arguments to request_irq and free_irq are compatible
<pre>
	Convert calls to free_irq so that the second argument is the same as the
	last argument of the corresponding call to request_irq.  Without this
	property, free_irq does nothing.
	
</pre>
<A HREF=round/round.cocci>round/round.cocci</A>  -  Use DIV_ROUND_UP
<pre>
	----------------------------
	
	
	The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
	(d)) but is perhaps more readable.
	
	An extract of the semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@haskernel@
	@@
	
	#include <linux/kernel.h>
	
	@depends on haskernel@
	expression n,d;
	@@
	
	(
	- (n + d - 1) / d
	+ DIV_ROUND_UP(n,d)
	|
	- (n + (d - 1)) / d
	+ DIV_ROUND_UP(n,d)
	)
	
	@depends on haskernel@
	expression n,d;
	@@
	
	- DIV_ROUND_UP((n),d)
	+ DIV_ROUND_UP(n,d)
	
	@depends on haskernel@
	expression n,d;
	@@
	
	- DIV_ROUND_UP(n,(d))
	+ DIV_ROUND_UP(n,d)
	// </smpl>
	
</pre>
<A HREF=round2/round.cocci>round2/round.cocci</A>  -  Use DIV_ROUND_UP
<pre>
	----------------------------
	
	
	The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
	(d)) but is perhaps more readable.
	
	An extract of the semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@haskernel@
	@@
	
	#include <linux/kernel.h>
	
	@depends on haskernel@
	expression n,d;
	@@
	
	(
	- (n + d - 1) / d
	+ DIV_ROUND_UP(n,d)
	|
	- (n + (d - 1)) / d
	+ DIV_ROUND_UP(n,d)
	)
	
	@depends on haskernel@
	expression n,d;
	@@
	
	- DIV_ROUND_UP((n),d)
	+ DIV_ROUND_UP(n,d)
	
	@depends on haskernel@
	expression n,d;
	@@
	
	- DIV_ROUND_UP(n,(d))
	+ DIV_ROUND_UP(n,d)
	// </smpl>
	
</pre>
<A HREF=round_closest/round_closest.cocci>round_closest/round_closest.cocci</A>  -  Use DIV_ROUND_CLOSEST
<pre>
	----------------------------
	
	
	The kernel.h macro DIV_ROUND_CLOSEST performs the computation (x + d/2)/d
	but is perhaps more readable.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@haskernel@
	@@
	
	#include <linux/kernel.h>
	
	@depends on haskernel@
	expression x,__divisor;
	@@
	
	- (((x) + ((__divisor) / 2)) / (__divisor))
	+ DIV_ROUND_CLOSEST(x,__divisor)
	// </smpl>
	
</pre>
<A HREF=rr/rr.cocci>rr/rr.cocci</A>  -  Correct use of request_region/request_mem_region
<pre>
	----------------------------
	
	
	request_mem_region should be used with release_mem_region, not request_region.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r2@
	expression start;
	@@
	
	request_mem_region(start,...)
	
	@b2@
	expression r2.start;
	@@
	
	request_region(start,...)
	
	@depends on !b2@
	expression r2.start;
	expression E;
	@@
	
	- release_region
	+ release_mem_region
	  (start,E)
	// </smpl>
	
</pre>
<A HREF=rr/rr1.cocci>rr/rr1.cocci</A>  -  Correct use of request_region/request_mem_region
<pre>
	----------------------------
	
	
	request_mem_region should be used with release_mem_region, not request_region.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r2@
	expression start;
	@@
	
	request_mem_region(start,...)
	
	@b2@
	expression r2.start;
	@@
	
	request_region(start,...)
	
	@depends on !b2@
	expression r2.start;
	expression E;
	@@
	
	- release_region
	+ release_mem_region
	  (start,E)
	// </smpl>
	
</pre>
<A HREF=rxrpc/category2a_rxrpc_get_transport.cocci>rxrpc/category2a_rxrpc_get_transport.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function rxrpc_get_transport returns an ERR
	pointer, but never returns a NULL pointer. So after a call to this
	function, a NULL test should be replaced by an IS_ERR test.
	
	A simplified version of the semantic patch that makes this change is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@correct_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x =  rxrpc_get_transport(...)
	<... when != x = E
	if (
	(
	- x@p2 != NULL
	+ ! IS_ERR ( x )
	|
	- x@p2 == NULL
	+ IS_ERR( x )
	)
	 )
	S1
	else S2
	...>
	? x = E;
	// </smpl>
	
</pre>
<A HREF=s390/category2a_dasd_kmalloc_request.cocci>s390/category2a_dasd_kmalloc_request.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, functions dasd_kmalloc_request and idal_buffer_alloc
	return an ERR pointer, but never return the NULL pointer. So after a
	call to one of these functions, a NULL test should be replaced by an
	IS_ERR test.
	
	A simplified version of the semantic patch that makes this change is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@correct_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x = 
	(
	  dasd_kmalloc_request(...)
	|
	  idal_buffer_alloc(...)
	)
	<... when != x = E
	if (
	(
	- x@p2 != NULL
	+ ! IS_ERR ( x )
	|
	- x@p2 == NULL
	+ IS_ERR( x )
	)
	 )
	S1
	else S2
	...>
	? x = E;
	// </smpl>
	
</pre>
<A HREF=s390/category2a_idal_buffer_alloc.cocci>s390/category2a_idal_buffer_alloc.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, functions dasd_kmalloc_request and idal_buffer_alloc
	return an ERR pointer, but never return the NULL pointer. So after a
	call to one of these functions, a NULL test should be replaced by an
	IS_ERR test.
	
	A simplified version of the semantic patch that makes this change is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@correct_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x = 
	(
	  dasd_kmalloc_request(...)
	|
	  idal_buffer_alloc(...)
	)
	<... when != x = E
	if (
	(
	- x@p2 != NULL
	+ ! IS_ERR ( x )
	|
	- x@p2 == NULL
	+ IS_ERR( x )
	)
	 )
	S1
	else S2
	...>
	? x = E;
	// </smpl>
	
</pre>
<A HREF=s390/s390.cocci>s390/s390.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, functions dasd_kmalloc_request and idal_buffer_alloc
	return an ERR pointer, but never return the NULL pointer. So after a
	call to one of these functions, a NULL test should be replaced by an
	IS_ERR test.
	
	A simplified version of the semantic patch that makes this change is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@correct_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x = 
	(
	  dasd_kmalloc_request(...)
	|
	  idal_buffer_alloc(...)
	)
	<... when != x = E
	if (
	(
	- x@p2 != NULL
	+ ! IS_ERR ( x )
	|
	- x@p2 == NULL
	+ IS_ERR( x )
	)
	 )
	S1
	else S2
	...>
	? x = E;
	// </smpl>
	
</pre>
<A HREF=samba_free/samba.cocci>samba_free/samba.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=semicolon/semicolon.cocci>semicolon/semicolon.cocci</A>  -  removes unnecessary semicolon
<pre>
	removes unnecessary semicolon
	
	Found by Coccinelle: http://coccinelle.lip6.fr/
	
</pre>
<A HREF=serial_core/serial_core.cocci>serial_core/serial_core.cocci</A>  -  Use UPIO_MEM rather than SERIAL_IO_MEM
<pre>
	----------------------------
	
	
	As in the commit 9b4a1617772d6d5ab5eeda0cd95302fae119e359, use UPIO_MEM
	rather than SERIAL_IO_MEM.  Both have the same value.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@has_sc@
	@@
	
	#include <linux/serial_core.h>
	
	@depends on has_sc@
	@@
	
	- SERIAL_IO_MEM
	+ UPIO_MEM
	// </smpl>
	
</pre>
<A HREF=signed/signed.cocci>signed/signed.cocci</A>  -  use unsigned for loop index
<pre>
	----------------------------
	
	
	A few more cases in the spirit of the patch \"Trivial: Replacement of always
	>0 ints with unsigned ints\" submitted by Ricardo Martins <ricardo@scarybox.net>
	
	The transformation was made using the following semantic patch
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r exists@ // find anything that might decrement the variable
	identifier i;
	expression E;
	position p;
	@@
	
	  int i@p;
	  ...
	(
	  &i
	|
	  i--
	|
	  --i
	|
	  i-=E
	|
	  i+=E
	)
	
	@x disable decl_init@
	identifier r.i;
	expression E;
	position p1 != r.p;
	@@
	
	(
	  volatile int i = 0;
	|
	  volatile int i;
	|
	+ unsigned
	  int i@p1 = 0;
	|
	+ unsigned
	  int i@p1;
	)
	  <... when != i = E      
	(
	  i = 0
	|
	  i = 1
	)
	  ...>
	// </smpl>
	
</pre>
<A HREF=simple_kzalloc/simple_kzalloc1.cocci>simple_kzalloc/simple_kzalloc1.cocci</A>  -  Use kcalloc
<pre>
	----------------------------
	
	
	Use kcalloc rather than the combination of kmalloc and memset.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,y,flags;
	statement S;
	type T;
	@@
	
	x = 
	-   kmalloc
	+   kcalloc
	           (
	-           y * sizeof(T),
	+           y, sizeof(T),
	                flags);
	 if (x == NULL) S
	-memset(x, 0, y * sizeof(T));
	// </smpl>
	
</pre>
<A HREF=sin_family/sin_family.cocci>sin_family/sin_family.cocci</A>  -  Use AF_INET for sin_family field
<pre>
	----------------------------
	
	
	Elsewhere the sin_family field holds a value with a name of the form
	AF_..., so it seems reasonable to do so here as well.  Also the values of
	PF_INET and AF_INET are the same.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	struct sockaddr_in sip;
	@@
	
	(
	sip.sin_family ==
	- PF_INET
	+ AF_INET
	|
	sip.sin_family !=
	- PF_INET
	+ AF_INET
	|
	sip.sin_family =
	- PF_INET
	+ AF_INET
	)
	// </smpl>
	
</pre>
<A HREF=sizeof/sizeof_sizeof.cocci>sizeof/sizeof_sizeof.cocci</A>  -  Eliminate double sizeof
<pre>
	florian.fainelli@telecomint.eu, jgarzik@pobox.com, netdev@vger.kernel.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	
	Subject: [PATCH] drivers/net/r6040.c: Eliminate double sizeof
	
	------------------------------------------------------
	
	
	Taking sizeof the result of sizeof is quite strange and does not seem to be
	what is wanted here.
	
	This was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression E;
	@@
	
	- sizeof (
	  sizeof (E)
	- )
	// </smpl>
	
</pre>
<A HREF=sla/sla.cocci>sla/sla.cocci</A>  -  Use GFP_ATOMIC when a lock is held
<pre>
	----------------------------
	
	
	A spin lock is taken near the beginning of the enclosing function.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	@@
	
	spin_lock(...)
	... when != spin_unlock(...)
	-GFP_KERNEL
	+GFP_ATOMIC
	// </smpl>
	
</pre>
<A HREF=slot/slot.cocci>slot/slot.cocci</A>  -  Add missing pci_dev_put
<pre>
	Pci_get_slot calls pci_dev_get, so pci_dev_put is needed before leaving the
	function.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	local idexpression x;
	expression e;
	@@
	
	*x = pci_get_slot(...)
	... when != true x == NULL
	    when != pci_dev_put(x)
	    when != e = x
	    when != if (x != NULL) {<+... pci_dev_put(x); ...+>}
	*return ...;
	// </smpl>
	
</pre>
<A HREF=soc_sound/category2a_ssc_request.cocci>soc_sound/category2a_ssc_request.cocci</A>  -  Useless NULL test
<pre>
	----------------------------
	
	
	The test (ssc != NULL) can only be reached if the call to the function
	ssc_request, the result of which ssc is assigned, succeeds. Moreover,
	two statements assign NULL to ssc just before a return, which is useless
	since it is a local variable. So, we suggest to delete the test and
	the two assignments.
	
	A simplified version of the semantic match that finds this problem is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@bad_null_test@
	expression x,E;
	@@
	x = ssc_request(...)
	... when != x = E
	* x != NULL
	// </smpl>
	
</pre>
<A HREF=sockfd/patch.cocci>sockfd/patch.cocci</A>  -  Use sockfd_put
<pre>
	net/bluetooth/bnep/sock.c
	net/bluetooth/cmtp/sock.c
	net/bluetooth/hidp/sock.c
	
	Send to:
	marcel@holtmann.org, maxk@qualcomm.com, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] /net/bluetooth: Use sockfd_put
	
	------------------------------------------------------
	
	
	The function sockfd_lookup uses fget on the value that is stored in the
	file field of the returned structure, so fput should ultimately be applied
	to this value.  This can be done directly, but it seems better to use the
	sockfd specific macro sockfd_put, which does the same thing.
	
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	expression s;
	@@
	
	   s = sockfd_lookup(...)
	   ...
	+  sockfd_put(s);
	?- fput(s->file);
	// </smpl>
	
</pre>
<A HREF=stest/stest.cocci>stest/stest.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=strsize/strsizeof.cocci>strsize/strsizeof.cocci</A>  -  decrement sizeof size in strncmp
<pre>
	----------------------------
	
	
	As observed by Joe Perches, sizeof of a constant string includes the
	trailing 0.  If what is wanted is to check the initial characters of
	another string, this trailing 0 should not be taken into account.  If an
	exact match is wanted, strcmp should be used instead.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression foo;
	constant char *abc;
	@@
	
	strncmp(foo, abc, 
	- sizeof(abc)
	+ sizeof(abc)-1
	 )
	// </smpl>
	
</pre>
<A HREF=strtoul/simple.cocci>strtoul/simple.cocci</A>  -  change simple_strtol to simple_strtoul
<pre>
	----------------------------
	
	
	Since bridge is unsigned, it would seem better to use simple_strtoul that
	simple_strtol.
	
	A simplified version of the semantic patch that makes this change is as
	follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@r2@
	long e;
	position p;
	@@
	
	e = simple_strtol@p(...)
	
	@@
	position p != r2.p;
	type T;
	T e;
	@@
	
	e = 
	- simple_strtol@p
	+ simple_strtoul
	  (...)
	// </smpl>
	
</pre>
<A HREF=sz/sz.cocci>sz/sz.cocci</A>  -  Correct code taking the size of a pointer
<pre>
	----------------------------
	
	
	sizeof(print_buf) is just the size of the pointer.  Change it to the size
	used in the allocation of print_buf earlier in the same function.
	
	A simplified version of the semantic patch that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *x;
	expression f;
	type T;
	@@
	
	*f(...,(T)x,...)
	// </smpl>
	
</pre>
<A HREF=sz3/sz3.cocci>sz3/sz3.cocci</A>  -  take size of pointed value, not pointer
<pre>
	Sizeof a pointer-typed expression returns the size of the pointer, not that
	of the pointed data.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression *e;
	type T;
	identifier f;
	@@
	
	f(...,(T)e,...,
	-sizeof(e)
	+sizeof(*e)
	,...)
	// </smpl>
	
</pre>
<A HREF=tipc/tipc.cocci>tipc/tipc.cocci</A>  -  Use tipc_port_unlock
<pre>
	net/tipc/port.c
	
	Send to:
	per.liden@ericsson.com, jon.maloy@ericsson.com, allan.stephens@windriver.com, tipc-discussion@lists.sourceforge.net, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] /net/tipc/port.c: Use tipc_port_unlock
	
	------------------------------------------------------
	
	
	The file net/tipc/port.c takes a lock using the function tipc_port_lock and
	then releases the lock sometimes using tipc_port_unlock and sometimes using
	spin_unlock_bh(p_ptr->publ.lock).  tipc_port_unlock simply does the
	spin_unlock_bh, but it seems cleaner to use it everywhere.
	
	
	The problem was fixed using the following semantic patch.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	struct port *p_ptr;
	@@
	
	   p_ptr = tipc_port_lock(...)
	   ...
	(
	   p_ptr = tipc_port_lock(...);
	|
	?- spin_unlock_bh(p_ptr->publ.lock);
	+  tipc_port_unlock(p_ptr);
	)
	// </smpl>
	
</pre>
<A HREF=tty_port/sp10730.cocci>tty_port/sp10730.cocci</A>  -  Put correct tty value
<pre>
	The tty value that should be put is the one that was just gotten by
	tty_port_tty_get, not the one that is the argument to the enclosing
	function.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	local idexpression struct tty_struct *x;
	expression ra,rr;
	statement S1,S2;
	@@
	
	x = tty_port_tty_get(...)
	... when != x = rr
	    when any
	    when != tty_kref_put(x,...)
	    when != if (...) { ... tty_kref_put(x,...) ...}
	(
	if(<+...x...+>) S1 else S2
	|
	if(...) { ... when != x = ra
	     when forall
	     when != tty_kref_put(x,...)
	*return...;
	}
	)
	// </smpl>
	
</pre>
<A HREF=typedef/handle.cocci>typedef/handle.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=typedef/hv/device_object/DEVICE_OBJECT.cocci>typedef/hv/device_object/DEVICE_OBJECT.cocci</A>  -  Staging: hv: Transform PDEVICE_OBJECT and DEVICE_OBJECT typedefs into their corresponding structs
<pre>
	
	Remove typedef DEVICE_OBJECT and use a struct named hv_device instead.
	
	Remove typedef PDEVICE_OBJECT which aliases a pointer and use the
	struct pointer (struct hv_device *).
	
	Here is the semantic patch to perform this transformation:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@rm_PDEVICE_OBJECT@
	@@
	-typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
	
	@rm_DEVICE_OBJECT@
	@@
	-typedef struct _DEVICE_OBJECT
	+struct hv_device
	{...}
	-DEVICE_OBJECT
	;
	
	@fixtypedef_PDEVICE_OBJECT@
	typedef PDEVICE_OBJECT;
	@@
	-PDEVICE_OBJECT
	+struct hv_device*
	
	@fixtypedef_DEVICE_OBJECT@
	typedef DEVICE_OBJECT;
	@@
	-DEVICE_OBJECT
	+struct hv_device
	
	@fixstruct__DEVICE_OBJECT@
	@@
	struct
	-_DEVICE_OBJECT
	+hv_device
	//</smpl>
</pre>
<A HREF=typedef/hv/driver_object/DRIVER_OBJECT.cocci>typedef/hv/driver_object/DRIVER_OBJECT.cocci</A>  -  Staging: hv: Remove typedef DRIVER_OBJECT and PDRIVER_OBJECT
<pre>
	
	typedef DRIVER_OBJECT and PDRIVER_OBJECT are removed and their usages
	are replace by the use of struct hv_driver and struct hv_driver *
	respectively.
	
	Here is the semantic patch generated to perform this transformation:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@rm_DRIVER_OBJECT@
	@@
	-typedef struct _DRIVER_OBJECT
	+struct hv_driver
	{...}
	-DRIVER_OBJECT
	;
	
	@rm_PDRIVER_OBJECT@
	@@
	-typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;
	+struct hv_driver;
	
	@fixtypedef_DRIVER_OBJECT@
	typedef DRIVER_OBJECT;
	@@
	-DRIVER_OBJECT
	+struct hv_driver
	
	@fixstruct__DRIVER_OBJECT@
	@@
	struct
	-_DRIVER_OBJECT
	+hv_driver
	
	@fixtypedef_PDRIVER_OBJECT@
	typedef PDRIVER_OBJECT;
	@@
	-PDRIVER_OBJECT
	+struct hv_driver*
	//</smpl>
</pre>
<A HREF=typedef/hv/netvsc/NETVSC_PACKET.cocci>typedef/hv/netvsc/NETVSC_PACKET.cocci</A>  -  Staging: hv: Remove typedef NETVSC_PACKET and PNETVSC_PACKET
<pre>
	
	typedef NETVSC_PACKET and PNETVSC_PACKET are removed and their usages
	are replace by the use of struct hv_netvsc_packet and
	struct hv_netvsc_packet * respectively.
	
	Here is the semantic patch generated to perform this transformation:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@rm_NETVSC_PACKET@
	@@
	-typedef struct _NETVSC_PACKET
	+struct hv_netvsc_packet
	{...}
	-NETVSC_PACKET
	;
	
	@rm_PNETVSC_PACKET@
	@@
	-typedef struct _NETVSC_PACKET *PNETVSC_PACKET;
	+struct hv_netvsc_packet;
	
	@fixtypedef_NETVSC_PACKET@
	typedef NETVSC_PACKET;
	@@
	-NETVSC_PACKET
	+struct hv_netvsc_packet
	
	@fixstruct__NETVSC_PACKET@
	@@
	struct
	-_NETVSC_PACKET
	+hv_netvsc_packet
	
	@fixtypedef_PNETVSC_PACKET@
	typedef PNETVSC_PACKET;
	@@
	-PNETVSC_PACKET
	+struct hv_netvsc_packet*
	//</smpl>
</pre>
<A HREF=typedef/hv/storvsc/STORVSC_REQUEST.cocci>typedef/hv/storvsc/STORVSC_REQUEST.cocci</A>  -  Staging: hv: Remove typedef STORVSC_REQUEST and PSTORVSC_REQUEST
<pre>
	
	typedef STORVSC_REQUEST and PSTORVSC_REQUEST are removed and their
	usages are replace by the use of struct hv_storvsc_request and
	struct hv_storvsc_request * respectively.
	
	Here is the semantic patch generated to perform this transformation:
	(http://coccinelle.lip6.fr/)
	
	//<smpl>
	@rm_STORVSC_REQUEST@
	@@
	-typedef struct _STORVSC_REQUEST
	+struct hv_storvsc_request
	{...}
	-STORVSC_REQUEST
	;
	
	@rm_PSTORVSC_REQUEST@
	@@
	-typedef struct _STORVSC_REQUEST *PSTORVSC_REQUEST;
	+struct hv_storvsc_request;
	
	@fixtypedef_STORVSC_REQUEST@
	typedef STORVSC_REQUEST;
	@@
	-STORVSC_REQUEST
	+struct hv_storvsc_request
	
	@fixstruct__STORVSC_REQUEST@
	@@
	struct
	-_STORVSC_REQUEST
	+hv_storvsc_request
	
	@fixtypedef_PSTORVSC_REQUEST@
	typedef PSTORVSC_REQUEST;
	@@
	-PSTORVSC_REQUEST
	+struct hv_storvsc_request*
	//</smpl>
</pre>
<A HREF=ubi/category2b_add_volume.cocci>ubi/category2b_add_volume.cocci</A>  -  Bad IS_ERR test
<pre>
	----------------------------
	
	
	In case of error, the function add_volume returns an ERR pointer. The
	result of IS_ERR, which is supposed to be used in a test as it is, is
	here checked to be less than zero, which seems odd. We suggest to
	replace this test by a simple IS_ERR test.
	
	A simplified version of the semantic match that finds this problem is
	as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@def0@
	expression x;
	position p0;
	@@
	x@p0 = add_volume(...)
	
	@protected@
	expression def0.x,E;
	position def0.p0;
	position p;
	statement S;
	@@
	x@p0
	... when != x = E
	if (!IS_ERR(x) && ...) {<... x@p ...>} else S
	
	@unprotected@
	expression def0.x,E;
	identifier fld;
	position def0.p0;
	position p != protected.p;
	@@
	x@p0
	... when != x = E
	* x@p->fld
	// </smpl>
	
</pre>
<A HREF=ubifs/category2a_kthread_create.cocci>ubifs/category2a_kthread_create.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function kthread_create returns an ERR pointer,
	but never returns a NULL pointer. So a NULL test that comes before an
	IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x = kthread_create(...)
	... when != x = E
	* if (x == NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=ulfe/ulfe.cocci>ulfe/ulfe.cocci</A>  -  use list_for_each_entry
<pre>
	Use list_for_each_entry and perform some other induced simplifications.
	
	The semantic match that finds the opportunity for this reorganization is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	struct list_head *pos;
	struct list_head *head;
	statement S;
	@@
	
	*for (pos = (head)->next; pos != (head); pos = pos->next)
	S
	// </smpl>
	
</pre>
<A HREF=unsf/unsf.cocci>unsf/unsf.cocci</A>  -  Fix unsigned return type
<pre>
	The function has an unsigned return type, but returns a negative constant
	to indicate an error condition.  The result of calling the function is
	always stored in a variable of type (signed) int, and thus unsigned can be
	dropped from the return type.
	
	A sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	identifier f;
	constant C;
	@@
	
	 unsigned f(...)
	 { <+...
	*  return -C;
	 ...+> }
	// </smpl>
	
</pre>
<A HREF=unsf/unsf_ret0.cocci>unsf/unsf_ret0.cocci</A>  -  Fix unsigned return type
<pre>
	The function has an unsigned return type, but returns a negative constant
	to indicate an error condition.  The result of calling the function is
	always stored in a variable of type (signed) int, and thus unsigned can be
	dropped from the return type.
	
	A sematic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@exists@
	identifier f;
	constant C;
	@@
	
	 unsigned f(...)
	 { <+...
	*  return -C;
	 ...+> }
	// </smpl>
	
</pre>
<A HREF=unused/unused.cocci>unused/unused.cocci</A>  -  remove unused variable
<pre>
	----------------------------
	
	
	The variable gig is initialized but never used otherwise.
	
	The semantic patch that makes this change is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T;
	identifier i;
	constant C;
	@@
	
	(
	extern T i;
	|
	- T i;
	  <+... when != i
	- i = C;
	  ...+>
	)
	// </smpl>
	
</pre>
<A HREF=unused_err/unused_err.cocci>unused_err/unused_err.cocci</A>  -  Use available error codes
<pre>
	----------------------------
	
	
	Error codes are stored in err, but the return value is always 0.  Return
	err instead.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	local idexpression x;
	constant C;
	@@
	
	if (...) { ...
	  x = -C
	  ... when != x
	(
	  return <+...x...+>;
	|
	  return NULL;
	|
	  return;
	|
	* return ...;
	)
	}
	// </smpl>
	
</pre>
<A HREF=urb2/urb2.cocci>urb2/urb2.cocci</A>  -  Delete unnecessary call to usb_kill_urb
<pre>
	Since in each case nothing has been done with the recently allocated urb,
	it is not necessary to kill it before freeing it.
	
	The semantic patch that fixes this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	expression urb;
	statement S;
	position p1,p2;
	@@
	
	urb = usb_alloc_urb@p1(...);
	... when != urb
	if (urb == NULL) S
	... when != urb
	usb_kill_urb@p2(urb);
	
	@other exists@
	position r.p1,r.p2;
	@@
	
	... when != usb_alloc_urb@p1(...)
	usb_kill_urb@p2(...);
	
	@depends on !other exists@
	expression urb;
	position r.p1,r.p2;
	@@
	
	urb = usb_alloc_urb@p1(...);
	...
	(
	-usb_kill_urb@p2(urb);
	+usb_free_urb(urb);
	... when != urb
	|
	-usb_kill_urb@p2(urb);
	)
	// </smpl>
	
</pre>
<A HREF=urb8/urb8.cocci>urb8/urb8.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=usb/category2a_back_device_reg.cocci>usb/category2a_back_device_reg.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function isp1760_register returns an ERR
	pointer, but never returns a NULL pointer. So after a call to this
	function, a NULL test should be replaced by an IS_ERR test. Moreover,
	we have noticed that:
	(1) the result of isp1760_register is assigned through the function
	pci_set_drvdata without an error test,
	(2) if the call to isp1760_register fails, the current function
	(isp1761_pci_probe) returns 0, and if it succeeds, it returns -ENOMEM,
	which seems odd.
	
	Thus, we suggest to move the test before the call to pci_set_drvdata
	to correct (1), and to turn it into a non IS_ERR test to correct (2).
	
	The semantic match that finds this problem is as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@bad_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x =  isp1760_register(...)
	... when != x = E
	* if (x == NULL)
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=usb/category2a_isp1760_reg.cocci>usb/category2a_isp1760_reg.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function isp1760_register returns an ERR
	pointer, but never returns a NULL pointer. So after a call to this
	function, a NULL test should be replaced by an IS_ERR test. Moreover,
	we have noticed that:
	(1) the result of isp1760_register is assigned through the function
	pci_set_drvdata without an error test,
	(2) if the call to isp1760_register fails, the current function
	(isp1761_pci_probe) returns 0, and if it succeeds, it returns -ENOMEM,
	which seems odd.
	
	Thus, we suggest to move the test before the call to pci_set_drvdata
	to correct (1), and to turn it into a non IS_ERR test to correct (2).
	
	The semantic match that finds this problem is as follows: 
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@bad_null_test@
	expression x,E;
	statement S1, S2;
	@@
	x =  isp1760_register(...)
	... when != x = E
	* if (x == NULL)
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=usbdata/usb_get_intfdata.cocci>usbdata/usb_get_intfdata.cocci</A>  -  Use usb_set/get_intfdata
<pre>
	----------------------------
	
	
	Use the USB functions usb_get_intfdata and usb_set_intfdata instead of
	dev_get_drvdata and dev_set_drvdata, respectively.
	
	The semantic patch that makes this change for the usb_get_intfdata case is
	as follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@header@
	@@
	
	#include <linux/usb.h>
	
	@same depends on header@
	position p;
	@@
	
	usb_get_intfdata@p(...) { ... }
	
	@depends on header@
	position _p!=same.p;
	identifier _f;
	struct usb_interface*intf;
	@@
	
	_f@_p(...) { <+...
	- dev_get_drvdata(&intf->dev)
	+ usb_get_intfdata(intf)
	...+> }
	// </smpl>
	
</pre>
<A HREF=usbdata/usb_set_intfdata.cocci>usbdata/usb_set_intfdata.cocci</A>  -  Use usb_set/get_intfdata
<pre>
	----------------------------
	
	
	Use the USB functions usb_get_intfdata and usb_set_intfdata instead of
	dev_get_drvdata and dev_set_drvdata, respectively.
	
	The semantic patch that makes this change for the usb_get_intfdata case is
	as follows: (http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@header@
	@@
	
	#include <linux/usb.h>
	
	@same depends on header@
	position p;
	@@
	
	usb_get_intfdata@p(...) { ... }
	
	@depends on header@
	position _p!=same.p;
	identifier _f;
	struct usb_interface*intf;
	@@
	
	_f@_p(...) { <+...
	- dev_get_drvdata(&intf->dev)
	+ usb_get_intfdata(intf)
	...+> }
	// </smpl>
	
</pre>
<A HREF=usbdir/end.cocci>usbdir/end.cocci</A>  -  Use usb_endpoint_dir_out
<pre>
	----------------------------
	
	
	Use the usb_endpoint_dir_out API function.  Note that the use of
	USB_TYPE_MASK in the original code is incorrect; it results in a test that
	is always false.
	
	The semantic patch that makes this change is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	struct usb_endpoint_descriptor *endpoint;
	expression E;
	@@
	
	- (endpoint->bEndpointAddress & E) == USB_DIR_OUT
	+ usb_endpoint_dir_out(endpoint)
	// </smpl>
	
</pre>
<A HREF=use_freed_specific/bad_kfree.cocci>use_freed_specific/bad_kfree.cocci</A>  -  Eliminate use after free
<pre>
	----------------------------
	
	
	Use the call to snd_card_free in the error handling code at the end of the
	function, as in the other error cases.
	
	A simplified version of the semantic patch that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression E,E2;
	@@
	
	snd_card_free(E)
	...
	(
	  E = E2
	|
	* E
	)
	// </smpl>
	
</pre>
<A HREF=usefreed/bad_kfree.cocci>usefreed/bad_kfree.cocci</A>  -  Correct use after free
<pre>
	----------------------------
	
	
	If the kfree is executed, the dereference of range afterwards will
	represent a use after free.  Added goto out, as done in the other nearby
	error handling code.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e;
	identifier f;
	iterator I;
	statement S;
	@@
	
	*kfree(x);
	... when != &x
	    when != x = e
	    when != I(x,...) S
	*x->f
	// </smpl>
	
</pre>
<A HREF=usefreed/usefreed.cocci>usefreed/usefreed.cocci</A>  -  Correct use after free
<pre>
	----------------------------
	
	
	If the kfree is executed, the dereference of range afterwards will
	represent a use after free.  Added goto out, as done in the other nearby
	error handling code.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression x,e;
	identifier f;
	iterator I;
	statement S;
	@@
	
	*kfree(x);
	... when != &x
	    when != x = e
	    when != I(x,...) S
	*x->f
	// </smpl>
	
</pre>
<A HREF=uselesskfree/uselesskfree.cocci>uselesskfree/uselesskfree.cocci</A>  -  Remove useless kfree
<pre>
	Remove useless kfree() and clean up code related to the removal.
	
	The semantic patch that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r exists@
	position p1,p2;
	expression x;
	@@
	
	if (x@p1 == NULL) { ... kfree@p2(x); ... return ...; }
	
	@unchanged exists@
	position r.p1,r.p2;
	expression e <= r.x,x,e1;
	iterator I;
	statement S;
	@@
	
	if (x@p1 == NULL) { ... when != I(x,...) S
	                        when != e = e1
	                        when != e += e1
	                        when != e -= e1
	                        when != ++e
	                        when != --e
	                        when != e++
	                        when != e--
	                        when != &e
	   kfree@p2(x); ... return ...; }
	
	@ok depends on unchanged exists@
	position any r.p1;
	position r.p2;
	expression x;
	@@
	
	... when != true x@p1 == NULL
	kfree@p2(x);
	
	@depends on !ok && unchanged@
	position r.p2;
	expression x;
	@@
	
	*kfree@p2(x);
	// </smpl>
	
</pre>
<A HREF=video/patch.cocci>video/patch.cocci</A>  -  Use video_device_release rather than kfree
<pre>
	drivers/media/radio/radio-maestro.c
	
	
	Send to:
	v4l-dvb-maintainer@linuxtv.org, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH 1/2] drivers/media/radio: Use video_device_release rather than kfree
	
	------------------------------------------------------
	
	
	The file drivers/media/video/videodev.c defines both video_device_alloc and
	video_device_release.  These are essentially just kzmalloc and kfree,
	respectively, but it seems better to use video_device_release, as done in
	the other media files, rather than kfree, in case the implementation some
	day changes.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2,x3;
	int ret;
	@@
	
	  T E;
	  ...
	* E = video_device_alloc(...);
	  if (E == NULL) S
	  ... when != video_device_release(...,(T1)E,...)
	      when != if (E != NULL) { ... video_device_release(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	  if (...) {
	    ... when != video_device_release(...,(T2)E,...)
	        when != if (E != NULL) { ... video_device_release(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=write2/write2.cocci>write2/write2.cocci</A>  -  delete double assignment
<pre>
	Delete successive assignments to the same location.
	
	A simplified version of the semantic match that finds this problem is as
	follows: (http://coccinelle.lip6.fr/)
	
	// <smpl>
	@@
	expression i;
	@@
	
	*i = ...;
	 i = ...;
	// </smpl>
	
</pre>
<A HREF=wrongtest/wrongtest.cocci>wrongtest/wrongtest.cocci</A>  -  test the just-initialized value
<pre>
	Test the just-initialized value rather than some other one.
	
	The semantic match that finds this problem is as follows:
	(http://coccinelle.lip6.fr/)
	
	// <smpl>
	@r@
	identifier x,y,f!={PTR_ERR,ERR_PTR,ERR_CAST};
	statement S;
	@@
	
	x = f(...);
	(
	if (\(x == NULL\|IS_ERR(x)\)) S
	|
	*if (\(y == NULL\|IS_ERR(y)\))
	 { ... when != x
	   return ...; }
	)
	// </smpl>
	
</pre>
<A HREF=x25/patch.cocci>x25/patch.cocci</A>  -  Add missing x25_neigh_put
<pre>
	net/x25/x25_forward.c
	
	
	Send to:
	eis@baty.hanse.de, linux-kernel@vger.kernel.org, kernel-janitors@vger.kernel.org
	
	Subject: [PATCH] net/x25: Add missing x25_neigh_put
	
	------------------------------------------------------
	
	
	The function x25_get_neigh increments a reference count.  At the point of
	the second goto out, the result of calling x25_get_neigh is only stored in
	a local variable, and thus no one outside the function will be able to
	decrease the reference count.  Thus, x25_neigh_put should be called before
	the return in this case.
	
	
	The problem was found using the following semantic match.
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	
	@@
	type T,T1,T2;
	identifier E;
	statement S;
	expression x1,x2,x3;
	int ret;
	@@
	
	  T E;
	  ...
	* if ((E = x25_get_neigh(...)) == NULL)
	  S
	  ... when != x25_neigh_put(...,(T1)E,...)
	      when != if (E != NULL) { ... x25_neigh_put(...,(T1)E,...); ...}
	      when != x1 = (T1)E
	      when != E = x3;
	      when any
	  if (...) {
	    ... when != x25_neigh_put(...,(T2)E,...)
	        when != if (E != NULL) { ... x25_neigh_put(...,(T2)E,...); ...}
	        when != x2 = (T2)E
	(
	*   return;
	|
	*   return ret;
	)
	  }
	// </smpl>
	
</pre>
<A HREF=xand/xand.cocci>xand/xand.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
<A HREF=xfrm/category2a_xfrm_bundle_create.cocci>xfrm/category2a_xfrm_bundle_create.cocci</A>  -  Use an IS_ERR test rather than a NULL test
<pre>
	----------------------------
	
	
	In case of error, the function xfrm_bundle_create returns an ERR
	pointer, but never returns a NULL pointer. So a NULL test that comes
	after an IS_ERR test should be deleted.
	
	The semantic match that finds this problem is as follows:
	(http://www.emn.fr/x-info/coccinelle/)
	
	// <smpl>
	@match_bad_null_test@
	expression x, E;
	statement S1,S2;
	@@
	x =  xfrm_bundle_create(...)
	... when != x = E
	*  if (x != NULL) 
	S1 else S2
	// </smpl>
	
</pre>
<A HREF=zercst/zercst.cocci>zercst/zercst.cocci</A>  -  adjust suspicious bit operation
<pre>
	PCH_UDC_DMA_LAST is 0x08000000 so a bit-or with this value always gives a
	nonzero result.  The test is rewritten as done elsewhere in the same file.
	
	This problem was found using Coccinelle (http://coccinelle.lip6.fr/).
	
</pre>
<A HREF=zero/rezero.cocci>zero/rezero.cocci</A>  -  Description not available
<pre>
	Description not available
</pre>
</body></html>
